<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>专业数学计算器 ProMax</title>
    <!-- <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax @3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"> -->
    <!-- 引入本地文件 -->
    <!-- MathJax - 先尝试CDN，失败则使用本地 -->
    <script>
        (function() {
            var script = document.createElement('script');
            script.id = 'MathJax-script';
            script.async = true;
            script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
            script.onerror = function() {
                console.log('MathJax CDN加载失败，使用本地文件');
                var localScript = document.createElement('script');
                localScript.id = 'MathJax-script-local';
                localScript.async = true;
                localScript.src = './CDN/tex-mml-chtml.js';
                document.head.appendChild(localScript);
            };
            document.head.appendChild(script);
        })();
    </script>
    
    <!-- MathJS - 先尝试CDN，失败则使用本地 -->
    <script>
        (function() {
            var script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js';
            script.onerror = function() {
                console.log('MathJS CDN加载失败，使用本地文件');
                var localScript = document.createElement('script');
                localScript.src = './CDN/math.js';
                document.head.appendChild(localScript);
            };
            document.head.appendChild(script);
        })();
    </script>
    
    <!-- Font Awesome - 先尝试CDN，失败则使用本地 -->
    <script>
        (function() {
            var link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css';
            link.onerror = function() {
                console.log('Font Awesome CDN加载失败，使用本地文件');
                var localLink = document.createElement('link');
                localLink.rel = 'stylesheet';
                localLink.href = './CDN/all.min.css';
                document.head.appendChild(localLink);
            };
            document.head.appendChild(link);
        })();
    </script>

    <style>
        :root {
            --glass-color: rgba(255, 255, 255, 0.15);
            --text-color: #ffffff;
            --setting-icon-color: #ffd700;
            --setting-bg-color: transparent;
            --transition-fast: 0.15s;
            --transition-medium: 0.3s;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body, html {
            height: 100%;
            overflow: auto;
            color: var(--text-color);
            position: relative;
            user-select: text;
        }

        /* 高级质感渐变背景 - 优化GPU加速 */
        .gradient-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg,
                #2c3e50 0%,
                #34495e 10%,
                #3498db 25%,
                #2980b9 35%,
                #1abc9c 45%,
                #16a085 55%,
                #27ae60 65%,
                #f1c40f 80%,
                #e67e22 90%,
                #e74c3c 100%);
            background-size: 400% 400%;
            animation: gradientShift 30s ease infinite;
            z-index: -2;
            will-change: transform;
            transform: translateZ(0);
        }

        /* 背景柔和发光效果 - 优化GPU加速 */
        .glow-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 30%, rgba(52, 152, 219, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(26, 188, 156, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(241, 196, 15, 0.15) 0%, transparent 50%);
            z-index: -1;
            opacity: 0.3;
            will-change: opacity;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* 顶部标题栏 - 非固定悬浮，去除背景以避免颜色线 */
        .top-header {
            width: 100%;
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 标题容器 - 修改为顶部居中，去除下边距 */
        .header-title {
            display: inline-block;
            font-size: clamp(1.5em, 4vw, 2.5em);
            font-weight: 800;
            white-space: nowrap;
            letter-spacing: 1px;
            background-color: #000000;
            border-radius: 10px;
            padding: 8px 20px;
            box-shadow:
                0 0 15px rgba(241, 196, 15, 0.6),
                0 0 30px rgba(52, 152, 219, 0.4),
                0 0 45px rgba(26, 188, 156, 0.3);
            text-align: center;
            margin: 0;
        }

        /* 标题文字渐变效果 - 优化GPU加速 */
        .title-text {
            background: linear-gradient(135deg,
                #f1c40f 0%,
                #f7dc6f 15%,
                #1abc9c 30%,
                #ffffff 50%,
                #3498db 70%,
                #f7dc6f 85%,
                #f1c40f 100%);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleTextFlow 8s ease-in-out infinite;
            text-shadow: 0 0 15px rgba(241, 196, 15, 0.3);
            display: inline-block;
            will-change: transform;
        }

        @keyframes titleTextFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* 设置按钮容器 */
        .settings-container {
            display: flex;
            justify-content: center;
            margin: 0;
        }

        /* 优化按钮动画 - 使用GPU加速和简化动画 */
        .settings-button {
            cursor: pointer;
            font-size: 3em;
            animation: rotateSettings 48s linear infinite;
            transition: transform var(--transition-fast);
            transform-origin: center center;
            display: inline-block;
            width: 1em;
            height: 1em;
            line-height: 1;
            text-align: center;
            vertical-align: middle;
            margin-right: 20px;
            will-change: transform;
        }

        /* 搜索按钮 - 镜像效果，镜头向右，使用呼吸动画 */
        .search-button {
            cursor: pointer;
            font-size: 3em;
            animation: searchBreathe 4s ease-in-out infinite;
            transition: transform var(--transition-fast);
            transform-origin: center center;
            display: inline-block;
            width: 1em;
            height: 1em;
            line-height: 1;
            text-align: center;
            vertical-align: middle;
            margin-right: 20px;
            transform: scaleX(-1);
            will-change: transform;
        }

        /* AIOS按钮 - 机器人风格，使用放大缩小动画 */
        .aios-button {
            cursor: pointer;
            font-size: 3em;
            animation: aiosPulse 3s ease-in-out infinite;
            transition: transform var(--transition-fast);
            transform-origin: center center;
            display: inline-block;
            width: 1em;
            height: 1em;
            line-height: 1;
            text-align: center;
            vertical-align: middle;
            filter: drop-shadow(0 0 10px rgba(138, 43, 226, 0.6));
            will-change: transform;
        }

        /* 简化设置按钮旋转动画 - 减少关键帧 */
        @keyframes rotateSettings {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(4680deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(4680deg); }
            100% { transform: rotate(0deg); }
        }

        /* 设置按钮点击效果 */
        .settings-button:active {
            animation: rotateSettingsClick 0.5s ease;
        }

        @keyframes rotateSettingsClick {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 搜索按钮呼吸效果 - 上下浮动 */
        @keyframes searchBreathe {
            0% { transform: translateY(0px) scale(1); }
            25% { transform: translateY(-8px) scale(1.1); }
            50% { transform: translateY(0px) scale(1); }
            75% { transform: translateY(5px) scale(0.95); }
            100% { transform: translateY(0px) scale(1); }
        }

        /* AIOS按钮放大缩小动画 */
        @keyframes aiosPulse {
            0% { transform: scale(1); opacity: 1; }
            25% { transform: scale(1.3); opacity: 0.9; }
            50% { transform: scale(1); opacity: 1; }
            75% { transform: scale(0.8); opacity: 0.95; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* AIOS按钮点击效果 */
        .aios-button:active {
            animation: aiosActivate 0.6s ease;
        }

        @keyframes aiosActivate {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        /* 搜索按钮点击效果 */
        .search-button:active {
            animation: searchPulse 0.6s ease;
        }

        @keyframes searchPulse {
            0% { transform: scale(1); opacity: 1; }
            25% { transform: scale(1.3); opacity: 0.8; }
            50% { transform: scale(1); opacity: 1; }
            75% { transform: scale(0.8); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0px 20px 10px;
            position: relative;
            z-index: 3;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
            text-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
        }

        .calculator {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }

        .input-section, .output-section {
            flex: 1;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 0 20px rgba(241, 196, 15, 0.4),
                0 0 40px rgba(52, 152, 219, 0.3),
                0 0 60px rgba(26, 188, 156, 0.2);
        }

        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--text-color);
            border-bottom: 2px solid rgba(241, 196, 15, 0.5);
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-color);
        }

        input, select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 16px;
            transition: all var(--transition-medium);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
        }

        input:focus, select:focus, textarea:focus {
            border-color: rgba(241, 196, 15, 0.6);
            box-shadow: 0 0 0 3px rgba(241, 196, 15, 0.3);
            outline: none;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-medium);
            min-width: 140px;
        }

        .calculate-btn {
            background: rgba(52, 152, 219, 0.7);
            color: white;
            backdrop-filter: blur(5px);
        }

        .calculate-btn:hover {
            background: rgba(41, 128, 185, 0.9);
            transform: translateY(-2px);
        }

        .clear-btn {
            background: rgba(231, 76, 60, 0.7);
            color: white;
            backdrop-filter: blur(5px);
        }

        .clear-btn:hover {
            background: rgba(192, 57, 43, 0.9);
            transform: translateY(-2px);
        }

        .paste-btn {
            background: rgba(46, 204, 113, 0.7);
            color: white;
            backdrop-filter: blur(5px);
        }

        .paste-btn:hover {
            background: rgba(39, 174, 96, 0.9);
            transform: translateY(-2px);
        }

        .output {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            min-height: 200px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .math-expression {
            font-size: 1.2rem;
            text-align: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            position: relative;
            backdrop-filter: blur(5px);
        }

        .copy-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            color: rgba(52, 152, 219, 0.8);
            font-size: 1.2rem;
            transition: all var(--transition-medium);
        }

        .copy-icon:hover {
            color: rgba(41, 128, 185, 0.9);
            transform: scale(1.1);
        }

        .steps {
            margin-top: 20px;
        }

        .step {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
        }

        .step-title {
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .example-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 0 20px rgba(241, 196, 15, 0.4),
                0 0 40px rgba(52, 152, 219, 0.3),
                0 0 60px rgba(26, 188, 156, 0.2);
            margin-bottom: 30px;
        }

        .examples {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .example {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all var(--transition-medium);
            border-left: 4px solid rgba(241, 196, 15, 0.7);
            backdrop-filter: blur(5px);
        }

        .example:hover {
            background: rgba(233, 236, 239, 0.2);
            transform: translateY(-3px);
        }

        .example-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--text-color);
        }

        .example-expression {
            font-family: monospace;
            color: rgba(255, 255, 0, 0.9);
            word-break: break-all;
            white-space: normal;
        }

        .function-reference {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 0 20px rgba(241, 196, 15, 0.4),
                0 0 40px rgba(52, 152, 219, 0.3),
                0 0 60px rgba(26, 188, 156, 0.2);
        }

        .function-categories {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .function-category {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            backdrop-filter: blur(5px);
        }

        .category-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-color);
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
        }

        .function-list {
            list-style-type: none;
        }

        .function-list li {
            padding: 5px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.3);
        }

        .function-list li:last-child {
            border-bottom: none;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            color: white;
            opacity: 0.8;
        }

        .error {
            color: rgba(231, 76, 60, 0.9);
            background: rgba(250, 219, 216, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(46, 204, 113, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-20px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        .result-text {
            font-family: 'Courier New', monospace;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0 0 0;
            border-left: 4px solid rgba(52, 152, 219, 0.7);
            font-size: 1.3rem;
            line-height: 1.6;
            font-weight: bold;
            word-break: break-word;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            backdrop-filter: blur(5px);
        }

        .approximation-text {
            font-size: 0.9em;
            color: rgba(108, 117, 125, 0.9);
            margin-top: 5px;
            padding: 5px 15px;
            text-align: left;
            border-top: 1px dashed rgba(255, 255, 255, 0.3);
        }

        .exponential {
            color: rgba(231, 76, 60, 0.9);
            font-weight: bold;
        }

        .result-title {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .evaluation-input {
            margin-top: 10px;
            padding: 10px;
            background: rgba(232, 244, 252, 0.2);
            border-radius: 5px;
            backdrop-filter: blur(5px);
        }

        .evaluation-input input {
            margin: 5px;
            padding: 8px;
            width: 80px;
        }

        .infinity-warning {
            color: rgba(231, 76, 60, 0.9);
            background: rgba(253, 234, 234, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid rgba(231, 76, 60, 0.9);
        }

        /* AIOS面板 - 优化性能 */
        .aios-panel {
            position: fixed;
            top: 0;
            left: 0;
            transform: none;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            padding: 0;
            border-radius: 0;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(75, 0, 130, 0.1));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: none;
            box-shadow:
                0 0 15px rgba(138, 43, 226, 0.4),
                0 0 30px rgba(75, 0, 130, 0.3),
                0 0 45px rgba(138, 43, 226, 0.2),
                inset 0 0 20px rgba(138, 43, 226, 0.1);
            z-index: 997;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-medium);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            will-change: opacity;
        }

        .aios-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        /* 手机端优化 */
        @media (max-width: 768px) {
            .aios-panel {
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
                padding: 0;
                border-radius: 0;
            }
            
            .aios-tabs {
                flex-direction: row;
                gap: 5px;
                margin-bottom: 20px;
            }
            
            .aios-tab-btn {
                width: 80px !important;
                height: 40px !important;
                min-width: 80px !important;
                max-width: 80px !important;
                min-height: 40px !important;
                max-height: 40px !important;
                font-size: 0.8em !important;
                box-sizing: border-box !important;
            }
            
            .chat-container {
                padding: 15px;
            }
            
            .chat-messages {
                height: 350px;
            }
            
            .chat-input-container {
                flex-direction: column;
                gap: 10px;
            }
            
            #chatInput {
                padding: 15px;
                font-size: 16px;
            }
            
            .aios-send-btn {
                width: 40px !important;
                height: 40px !important;
                min-width: 40px !important;
                max-width: 40px !important;
                min-height: 40px !important;
                max-height: 40px !important;
                font-size: 1em !important;
                box-sizing: border-box !important;
            }
            
            .analysis-tools {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .tool-card {
                padding: 15px;
            }
            
            .ai-tools-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            .ai-tool-item {
                padding: 15px 10px;
            }
            
            .aios-actions {
                flex-direction: column;
                gap: 10px;
            }
            
            .aios-action-btn {
                padding: 18px;
                font-size: 1em;
            }
        }

        .aios-tabs {
            display: none; /* 原有标签页隐藏 */
        }
        
        /* 新增横向标签页样式 - 仅在桌面端显示 */
        .aios-tabs-horizontal {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .aios-tabs-horizontal .aios-tab-btn {
            width: 91px !important;
            height: 40px !important;
            min-width: 91px !important;
            max-width: 91px !important;
            min-height: 40px !important;
            max-height: 40px !important;
            padding: 0;
            border: none;
            border-radius: 6px;
            background: rgba(138, 43, 226, 0.2);
            color: var(--text-color);
            cursor: pointer;
            transition: all var(--transition-medium);
            font-size: 0.9em !important;
            font-weight: 600;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-sizing: border-box !important;
            flex-direction: column;
        }
        
        .aios-tabs-horizontal .aios-tab-btn.active {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.6));
            color: white;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
        }
        
        .aios-tabs-horizontal .aios-tab-btn:hover {
            background: rgba(138, 43, 226, 0.3);
            transform: translateY(-2px);
        }
        
        .aios-tabs-horizontal .aios-tab-btn.active:hover {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.7), rgba(75, 0, 130, 0.7));
            box-shadow: 0 6px 20px rgba(138, 43, 226, 0.5);
        }
        
        /* 手机端保持原有布局 */
        @media (max-width: 768px) {
            .aios-tabs {
                display: flex !important; /* 手机端恢复原有标签页 */
                flex-direction: row;
                gap: 5px;
                margin-bottom: 20px;
            }
            
            .aios-tabs-horizontal {
                display: none; /* 手机端隐藏横向标签页 */
            }
        }

        .aios-tab-btn {
            width: 91px !important;
            height: 69px !important;
            min-width: 91px !important;
            max-width: 91px !important;
            min-height: 69px !important;
            max-height: 69px !important;
            padding: 0;
            border: none;
            border-radius: 6px;
            background: rgba(138, 43, 226, 0.2);
            color: var(--text-color);
            cursor: pointer;
            transition: all var(--transition-medium);
            font-size: 1.2em !important;
            font-weight: 600;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-sizing: border-box !important;
            flex-direction: column;
        }

        .aios-tab-btn.active {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.6));
            color: white;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
        }

        .aios-tab-btn:hover {
            background: rgba(138, 43, 226, 0.3);
            transform: translateY(-2px);
        }

        .aios-tab-btn.active:hover {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.7), rgba(75, 0, 130, 0.7));
            box-shadow: 0 6px 20px rgba(138, 43, 226, 0.5);
        }

        .aios-tab-content {
            display: none;
        }

        .aios-tab-content.active {
            display: block;
        }

        /* API配置区域样式 */
        .api-config-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid rgba(138, 43, 226, 0.3);
            overflow: hidden;
        }

        .api-config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(138, 43, 226, 0.2);
            cursor: pointer;
            transition: background 0.3s;
        }

        .api-config-header:hover {
            background: rgba(138, 43, 226, 0.3);
        }

        .api-config-title {
            font-weight: bold;
            color: var(--text-color);
            font-size: 1.1em;
        }

        .api-config-toggle {
            color: var(--text-color);
            transition: transform 0.3s;
        }

        .api-config-content {
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
        }

        .api-config-item {
            margin-bottom: 12px;
        }

        .api-config-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: var(--text-color);
        }

        .api-config-item input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            font-size: 0.9em;
        }

        .api-config-btn {
            padding: 3px 6px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0);
            color: white;
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: 600;
            transition: all 0.3s;
            width: auto;
            height: auto;
            min-width: 30px;
            max-width: 300px;
            display: inline-block;
            text-align: center;
            line-height: 1.2;
            vertical-align: middle;
            flex-shrink: 0;
            margin-top: 10px;
        }

        .api-config-btn:hover {
            background: rgba(138, 43, 226, 0.8);
            transform: scale(1.05);
        }

        /* API配置面板样式 */
        .api-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            padding: 30px;
            border-radius: 15px;
            background: rgba(138, 43, 226, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow:
                0 0 15px rgba(138, 43, 226, 0.4),
                0 0 30px rgba(75, 0, 130, 0.3),
                0 0 45px rgba(138, 43, 226, 0.2);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-medium);
            will-change: opacity;
        }

        .api-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        .api-panel h2 {
            text-align: center;
            margin-bottom: 20px;
            color: var(--text-color);
        }

        .api-close-btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: rgba(231, 76, 60, 0.7);
            color: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .api-close-btn:hover {
            background: rgba(192, 57, 43, 0.9);
        }

        .api-config-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .api-save-btn, .api-test-btn, .api-reset-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .api-save-btn {
            background: rgba(46, 204, 113, 0.7);
            color: white;
        }

        .api-save-btn:hover {
            background: rgba(39, 174, 96, 0.9);
        }

        .api-test-btn {
            background: rgba(241, 196, 15, 0.7);
            color: #2c3e50;
        }

        .api-test-btn:hover {
            background: rgba(243, 156, 18, 0.9);
        }

        .api-reset-btn {
            background: rgba(231, 76, 60, 0.7);
            color: white;
        }

        .api-reset-btn:hover {
            background: rgba(192, 57, 43, 0.9);
        }

        /* 聊天界面样式 - 优化版本 */
        .chat-container {
            background: #333333; /* Changed to black-gray color */
            border-radius: 10px;
            padding: 10px;
            border: 1px solid rgba(138, 43, 226, 0.2);
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5); /* Darker background for messages */
            border-radius: 8px;
            min-height: 720px;
            max-height: 725px;/*电脑端聊天页面高度*/
        }
        /* 手机端适配 */
@media (max-width: 768px) {
    .chat-messages {
        /*适人握持*/
        min-height: 520px; /* 设置一个合理的手机端最小高度 */
        
    }
}

        .ai-message {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
        }

        .user-message {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
            justify-content: flex-end;
        }

        /* 思考过程样式 */
        .reasoning-container {
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(138, 43, 226, 0.2);
            overflow: hidden;
        }

        .reasoning-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: rgba(138, 43, 226, 0.1);
            cursor: pointer;
            transition: background 0.3s;
        }

        .reasoning-header:hover {
            background: rgba(138, 43, 226, 0.2);
        }

        .reasoning-toggle {
            color: rgba(255, 255, 255, 0.7);
            margin-right: 8px;
            font-size: 0.9em;
            transition: transform 0.3s;
        }

        .reasoning-title {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            font-style: italic;
        }

        .reasoning-content {
            padding: 10px 12px;
            color: rgb(255, 255, 255);
            font-size: 0.9em;
            line-height: 1.4;
            opacity: 0.8;
        }

        .reasoning-content p {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* 主内容样式 */
        .main-content {
            margin-top: 5px;
        }

        .ai-avatar {
            font-size: 1.2em;
            margin-right: 8px;
            min-width: 25px;
            flex-shrink: 0;
        }

        .user-avatar {
            font-size: 1.2em;
            margin-left: 8px;
            min-width: 25px;
            flex-shrink: 0;
        }

        /* 去除消息方框，只显示文字 */
        .message-content {
            position: relative;
        }

        .user-content {
            position: relative;
        }

        /* 消息内容支持换行展示 */
        .message-content p, .user-content p {
            margin: 0 0 15px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
        }

        /* 复制和折叠图标样式 */
        .message-actions {
            display: inline-block;
            margin-left: 5px;
            opacity: 0.7;
            transition: opacity 0.2s;
            vertical-align: middle;
        }

        .message-content:hover .message-actions,
        .user-content:hover .message-actions {
            opacity: 1;
        }

        .message-actions {
            font-size: 14px; /* Increased size */
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.2s;
            display: inline-block;
            vertical-align: middle;
        }

        .message-actions:hover {
            color: rgba(255, 255, 255, 1);
        }
        
        /* 折叠控件样式 - 移到消息上方 */
        .expand-controls {
            text-align: right;
            margin-bottom: 5px;
            padding: 3px 5px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 12px;
        }
        
        .message-action-icon {
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.2s;
            margin-left: 5px;
        }
        
        .message-action-icon:hover {
            color: rgba(255, 255, 255, 1);
        }

        /* 消息折叠样式 */
        .collapsed-message {
            max-height: 100px;
            overflow: hidden;
            position: relative;
        }

        .collapsed-message::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.5));
        }

        /* 消息内容样式 */
        .message-content p, .user-content p {
            margin: 0 0 10px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
            overflow-wrap: break-word;
            max-width: 100%;
            word-break: break-word;
            overflow-x: auto;
            font-family: inherit;
        }

        /* 聊天消息容器样式 - 固定大小 */
        .chat-messages {
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 8px;
            padding-right: 10px; /* 减少右侧内边距 */
            background: rgba(0, 0, 0, 0.5); /* Darker background for messages */
            border-radius: 8px;
            height: 520px; /* 增加固定高度 */
            max-height: 520px; /* 确保最大高度等于固定高度 */
            position: relative;
            flex-shrink: 0; /* 防止伸缩 */
            flex-grow: 0; /* 防止增长 */
        }

        .expand-indicator {
            font-size: 14px; /* Increased size */
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            margin-left: 5px;
            display: inline-block;
            vertical-align: middle;
        }

        .expand-indicator:hover {
            color: rgba(255, 255, 255, 1);
        }

        .chat-input-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-row {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }

        #chatInput {
            flex: 1;
            padding: 10px 12px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            font-size: 14px;
            font-family: 'Courier New', monospace; /* 使用等宽字体处理代码 */
            resize: none;
            min-height: 40px;
            max-height: 120px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        #chatInput:focus {
            border-color: rgba(138, 43, 226, 0.6);
            box-shadow: 0 0 0 2px rgba(138, 43, 226, 0.3);
            outline: none;
        }

        .aios-send-btn {
            width: 66px !important;
            height: 66px !important;
            min-width: 66px !important;
            max-width: 66px !important;
            min-height: 66px !important;
            max-height: 66px !important;
            border: none;
            border-radius: 6px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.6));
            color: white;
            font-size: 1.5em !important;
            cursor: pointer;
            transition: all var(--transition-medium);
            flex-shrink: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box !important;
            transform: rotate(-90deg);
        }

        .aios-send-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4);
        }
        
        /* 停止按钮状态样式 */
        .aios-send-btn.stop-mode {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.8), rgba(192, 57, 43, 0.8));
            transform: scale(1.1) rotate(-90deg);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }
        
        .aios-send-btn.stop-mode:hover {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.9), rgba(192, 57, 43, 0.9));
            transform: scale(1.15) rotate(-90deg);
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.7);
        }

        /* 数据分析工具样式 */
        .analysis-tools {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .tool-card {
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all var(--transition-medium);
        }

        .tool-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(138, 43, 226, 0.3);
            background: rgba(138, 43, 226, 0.15);
        }

        .tool-icon {
            font-size: 2em;
            margin-bottom: 8px;
        }

        .tool-card h4 {
            color: var(--text-color);
            margin-bottom: 5px;
            font-size: 1em;
        }

        .tool-card p {
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 12px;
            font-size: 0.8em;
        }

        .aios-tool-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.6));
            color: white;
            cursor: pointer;
            transition: all var(--transition-medium);
            font-weight: 600;
            font-size: 0.9em;
        }

        .aios-tool-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4);
        }

        /* AI工具网格样式 */
        .ai-tools-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .ai-tool-item {
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 8px;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-medium);
        }

        .ai-tool-item:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 15px rgba(138, 43, 226, 0.3);
            background: rgba(138, 43, 226, 0.2);
        }

        .tool-emoji {
            font-size: 1.5em;
            display: block;
            margin-bottom: 5px;
        }

        .tool-name {
            color: var(--text-color);
            font-weight: 600;
            font-size: 0.8em;
        }

        .aios-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .aios-action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.6));
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-medium);
        }

        .aios-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(138, 43, 226, 0.4);
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.7), rgba(75, 0, 130, 0.7));
        }

        /* 搜索面板 - 优化性能 */
        .search-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1280px;
            max-width: 90vw;
            max-height: 90vh;
            padding: 40px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow:
                0 0 15px rgba(52, 152, 219, 0.4),
                0 0 30px rgba(26, 188, 156, 0.3),
                0 0 45px rgba(241, 196, 15, 0.2);
            z-index: 998;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-medium);
            overflow-y: auto;
            will-change: opacity;
        }

        .search-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        .search-input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #searchInput {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 16px;
            transition: all var(--transition-medium);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
        }

        #searchInput:focus {
            border-color: rgba(52, 152, 219, 0.6);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
            outline: none;
        }

        .search-submit-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: rgba(52, 152, 219, 0.7);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-medium);
        }

        .search-submit-btn:hover {
            background: rgba(41, 128, 185, 0.9);
            transform: translateY(-2px);
        }

        .search-options {
            margin-bottom: 20px;
        }

        .search-results-container {
            margin-bottom: 20px;
        }

        .search-results {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
        }

        .search-result-item {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: all var(--transition-medium);
            border-left: 3px solid rgba(52, 152, 219, 0.7);
        }

        .search-result-item:hover {
            background: rgba(233, 236, 239, 0.2);
            transform: translateX(5px);
        }

        .search-result-title {
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 5px;
        }

        .search-result-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
        }

        .no-results {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }

        .search-actions {
            display: flex;
            gap: 10px;
        }

        /* 修复设置面板 - 优化性能 */
        .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1280px;
            max-width: 90vw;
            padding: 40px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow:
                0 0 15px rgba(241, 196, 15, 0.4),
                0 0 30px rgba(52, 152, 219, 0.3),
                0 0 45px rgba(26, 188, 156, 0.2);
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-medium);
            will-change: opacity;
        }

        .settings-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.3);
        }

        .setting-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .setting-item label {
            display: flex;
            align-items: center;
            font-weight: 600;
            min-width: 120px;
        }

        .setting-item i {
            margin-right: 8px;
            font-style: normal;
            color: var(--setting-icon-color);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(135deg, #f1c40f, #1abc9c);
        }

        input:checked + .slider:before {
            transform: translateX(91px);
        }

        select {
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            background-color: #3c3131;
            color: var(--text-color);
            font-size: 0.9em;
            cursor: pointer;
            min-width: 180px;
            width: 180px;
        }

        .range-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-value {
            min-width: 40px;
            text-align: right;
        }

        .dynamic-slider {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 120px;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg,
                #2c3e50, #3498db, #1abc9c, #16a085, #27ae60, #f1c40f, #e67e22, #e74c3c);
            background-size: 300% 100%;
            outline: none;
            cursor: pointer;
        }

        .dynamic-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.8);
            border: 2px solid #f1c40f;
            transition: all var(--transition-fast);
        }

        .dynamic-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 12px rgba(241, 196, 15, 1);
        }

        .dynamic-slider::-moz-range-thumb {
            -moz-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.8);
            border: 2px solid #f1c40f;
            transition: all var(--transition-fast);
        }

        .preview-button {
            width: 100%;
            padding: 12px;
            border-radius: 10px;
            background: linear-gradient(135deg, #f1c40f, #1abc9c);
            color: #2c3e50;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 8px;
            transition: all var(--transition-medium);
            box-shadow: 0 0 12px rgba(241, 196, 15, 0.4);
            font-size: 0.95em;
        }

        .preview-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(241, 196, 15, 0.6);
        }

        .preview-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        /* AIOS面板关闭按钮样式 - Windows/MacOS风格 */
        .aios-panel-close-btn {
            position: fixed;
            top: 20px;
            font-size: 18px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1001;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(231, 76, 60, 0.9);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: none;
        }

        .aios-panel-close-btn:hover {
            background: rgba(231, 76, 60, 1);
            transform: scale(1.1);
        }

        .aios-panel-close-left {
            left: 20px;
        }

        .aios-panel-close-right {
            right: 20px;
        }

        /* 手机端适配 */
        @media (max-width: 768px) {
            .aios-panel-close-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
                top: 10px;
            }
            
            .aios-panel-close-left {
                left: 10px;
            }
            
            .aios-panel-close-right {
                right: 10px;
            }
        }

        /* 聊天导航按钮样式 */
        .chat-nav-btn {
            padding: 4px 8px;
            background: rgba(52, 152, 219, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            margin: 5px 0;
            display: inline-block;
            white-space: nowrap;
        }

        .chat-nav-btn:hover {
            background: rgba(41, 128, 185, 0.9);
            transform: scale(1.05);
        }

        .chat-nav-top {
            align-self: flex-end;
            margin-bottom: 5px;
        }

        .chat-nav-bottom {
            align-self: flex-end;
            margin-top: 5px;
        }

        /* 聊天控制按钮容器 - 完全悬浮透明 */
        .chat-controls-container {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 13px;
            z-index: 1000;
        }

        /* 聊天控制按钮位置 - 透明样式 */
        #chatTrackBtn, #chatTopBtn, #chatBottomBtn {
            display: block;
            margin: 0;
            padding: 0;
            background: transparent;
            color: rgba(255, 255, 255, 1);
            font-size: 16px;
            cursor: pointer;
            transition: color 0.2s;
            white-space: nowrap;
        }

        #chatTrackBtn:hover, #chatTopBtn:hover, #chatBottomBtn:hover {
            color: rgba(255, 255, 255, 1);
        }

        /* AI思考加载动画 */
        .thinking-indicator {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 12px 15px;
            background: rgba(138, 43, 226, 0.1);
            border-radius: 8px;
            border-left: 3px solid rgba(138, 43, 226, 0.7);
            animation: fadeIn 0.3s ease-in;
        }
        
        /* 停止消息样式 */
        .stop-message {
            opacity: 0.8;
            background: rgba(231, 76, 60, 0.1);
            border-left: 3px solid rgba(231, 76, 60, 0.7);
        }

        .thinking-dots {
            display: flex;
            gap: 4px;
            margin-left: 10px;
        }

        .thinking-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(138, 43, 226, 0.8);
            animation: thinkingPulse 1.4s infinite ease-in-out both;
        }

        .thinking-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .thinking-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes thinkingPulse {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .calculator {
                flex-direction: column;
            }

            h1 {
                font-size: 2.2rem;
            }

            .function-categories {
                grid-template-columns: 1fr;
            }

            .result-text {
                font-size: 1.1rem;
            }

            textarea, .example-expression, .result-text {
                word-break: break-word;
                white-space: pre-wrap;
            }

            .container {
                padding: 0px 10px 0px;
            }

            .top-header {
                padding: 10px 15px;
            }

            .header-title {
                font-size: clamp(1.2em, 3.5vw, 2em);
                padding: 6px 15px;
            }

            .settings-button {
                font-size: 2.5em;
                width: 60px;
                height: 60px;
                line-height: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="gradient-background"></div>
    <div class="glow-effect"></div>

    <!-- 顶部标题栏 -->
    <div class="top-header">
        <div class="header-title">
            <span class="title-text">专业数学计算器 ProMax</span>
        </div>
    </div>

    <!-- 搜索、设置和AiOS按钮区域 -->
    <div class="settings-container">
        <div class="search-button" title="搜索">🔍</div>
        <div class="settings-button" title="设置">⚙️</div>
        <div class="aios-button" title="AiOS">🤖</div>
    </div>

    <!-- AIOS面板外部关闭按钮 -->
    <div class="aios-panel-close-btn aios-panel-close-left" id="closeAiosLeftBtn" style="display: none;">×</div>
    <div class="aios-panel-close-btn aios-panel-close-right" id="closeAiosRightBtn" style="display: none;">×</div>
    
    <div class="aios-panel">
        <div style="display: flex; justify-content: center; align-items: center; margin: 0; margin-bottom: 10px; flex-wrap: wrap;">
            <h2 style="margin: 0; margin-right: 15px;">🤖 AIOS 智能助手</h2>
            <div class="aios-tabs-horizontal">
                <button class="aios-tab-btn active" data-tab="chat">
                    <span>💬</span>
                    <span>智能对话</span>
                </button>
                <button class="aios-tab-btn" data-tab="analysis">
                    <span>📊</span>
                    <span>数据分析</span>
                </button>
                <button class="aios-tab-btn" data-tab="tools">
                    <span>🔧</span>
                    <span>AI工具</span>
                </button>
            </div>
            <button class="api-config-btn" id="apiConfigBtn" title="点击配置API，设置后可使用智能AI对话">🔗 API</button>
        </div>
        
        <div class="aios-operations">
            <!-- 智能对话标签页 -->
            <div class="aios-tab-content active" id="chat-tab">
                
                <div class="chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <!-- 聊天控制按钮 - 悬浮在中间 -->
                        <div class="chat-controls-container">
                            <span id="chatTopBtn" title="回到顶部">↑顶部</span>
                            <span id="chatTrackBtn" title="返回上次位置">↑回展↓</span>
                            <span id="chatBottomBtn" title="前往底部">↓底部</span>
                            <span id="chatClearBtn" title="清空聊天历史">🗑️清空</span>
                            <span id="voiceBtn" title="语音交互">🎤语音</span>
                            <span id="closeAiosBtn" title="关闭面板">❌关闭</span>
                        </div>
                        
                        <div class="ai-message">
                            <span class="ai-avatar">🤖</span>
                            <div class="message-content">
                                <p>您好！我是AIOS智能助手，有什么可以帮助您的吗？</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chat-input-container">
                        <div class="input-row">
                            <textarea id="chatInput" placeholder="输入您的问题... (Ctrl+Enter发送，支持数学公式)" autocomplete="off"></textarea>
                            <button class="aios-send-btn" id="sendBtn">➤</button>
                        </div>
                        <div class="math-shortcuts" style="display: flex; gap: 5px; margin-top: 5px; flex-wrap: wrap;">
                            <span class="math-shortcut" data-formula="∫" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">∫</span>
                            <span class="math-shortcut" data-formula="∂" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">∂</span>
                            <span class="math-shortcut" data-formula="∑" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">∑</span>
                            <span class="math-shortcut" data-formula="∏" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">∏</span>
                            <span class="math-shortcut" data-formula="√" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">√</span>
                            <span class="math-shortcut" data-formula="∞" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">∞</span>
                            <span class="math-shortcut" data-formula="π" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">π</span>
                            <span class="math-shortcut" data-formula="α" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">α</span>
                            <span class="math-shortcut" data-formula="β" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">β</span>
                            <span class="math-shortcut" data-formula="θ" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">θ</span>
                            <span class="math-shortcut" data-formula="λ" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">λ</span>
                            <span class="math-shortcut" data-formula="μ" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">μ</span>
                            <span class="math-shortcut" data-formula="σ" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">σ</span>
                            <span class="math-shortcut" data-formula="φ" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">φ</span>
                            <span class="math-shortcut" data-formula="ω" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">ω</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 数据分析标签页 -->
            <div class="aios-tab-content" id="analysis-tab">
                <div class="analysis-tools">
                    <div class="tool-card">
                        <div class="tool-icon">📈</div>
                        <h4>数据可视化</h4>
                        <p>将您的数据转换为图表</p>
                        <button class="aios-tool-btn">开始分析</button>
                    </div>
                    <div class="tool-card">
                        <div class="tool-icon">🔍</div>
                        <h4>智能搜索</h4>
                        <p>快速找到您需要的信息</p>
                        <button class="aios-tool-btn">开始搜索</button>
                    </div>
                    <div class="tool-card">
                        <div class="tool-icon">⚡</div>
                        <h4>快速计算</h4>
                        <p>AI驱动的数学计算</p>
                        <button class="aios-tool-btn">开始计算</button>
                    </div>
                </div>
            </div>
            
            <!-- AI工具标签页 -->
            <div class="aios-tab-content" id="tools-tab">
                <div class="ai-tools-grid">
                    <div class="ai-tool-item">
                        <span class="tool-emoji">🎨</span>
                        <span class="tool-name">图像生成</span>
                    </div>
                    <div class="ai-tool-item">
                        <span class="tool-emoji">📝</span>
                        <span class="tool-name">文本创作</span>
                    </div>
                    <div class="ai-tool-item">
                        <span class="tool-emoji">🎵</span>
                        <span class="tool-name">音乐创作</span>
                    </div>
                    <div class="ai-tool-item">
                        <span class="tool-emoji">🎬</span>
                        <span class="tool-name">视频编辑</span>
                    </div>
                    <div class="ai-tool-item">
                        <span class="tool-emoji">🌐</span>
                        <span class="tool-name">语言翻译</span>
                    </div>
                    <div class="ai-tool-item">
                        <span class="tool-emoji">🧮</span>
                        <span class="tool-name">代码生成</span>
                    </div>
                </div>
            </div>
        </div>
        
        
    </div>

    <div class="search-panel">
        <h2>🔍 搜索功能</h2>
        
        <div class="search-input-container">
            <input type="text" id="searchInput" placeholder="输入数学公式或函数名称..." autocomplete="off">
            <button id="searchBtn" class="search-submit-btn">搜索</button>
        </div>
        
        <div class="search-options">
            <div class="setting-item">
                <label for="searchCategory"><i>📁</i> 搜索类别</label>
                <select id="searchCategory">
                    <option value="all">全部</option>
                    <option value="functions">数学函数</option>
                    <option value="constants">常数</option>
                    <option value="examples">示例表达式</option>
                    <option value="operations">计算类型</option>
                </select>
            </div>
            
            <div class="setting-item">
                <label for="searchHistory"><i>📜</i> 搜索历史</label>
                <select id="searchHistory">
                    <option value="">-- 选择历史搜索 --</option>
                </select>
            </div>
        </div>
        
        <div class="search-results-container">
            <h3>搜索结果</h3>
            <div id="searchResults" class="search-results">
                <p class="no-results">暂无搜索结果</p>
            </div>
        </div>
        
        <div class="search-actions">
            <button class="preview-button" id="clearSearchBtn">
                🗑️ 清空搜索
            </button>
            <button class="preview-button" id="closeSearchBtn">
                ❌ 关闭面板
            </button>
        </div>
    </div>

    <!-- API配置面板 -->
    <div class="api-panel">
        <h2>🔑 API配置</h2>
        
        <div class="api-config-item">
            <label for="apiUrl">API网址:</label>
            <input type="text" id="apiUrl" value="https://apis.iflow.cn/v1/chat/completions" placeholder="API网址">
        </div>
        <div class="api-config-item">
            <label for="apiKey">API密钥:</label>
            <input type="text" id="apiKey" value="sk-07f5c088f32838e9d121dad3bc76a2e4" placeholder="API密钥">
        </div>
        <div class="api-config-item">
            <label for="apiModel">模型:</label>
            <select id="apiModel">
                <option value="glm-4.6" selected>glm-4.6</option>
                <option value="qwen3-235b-a22b-thinking-2507">qwen3-235b-a22b-thinking-2507</option>
                <option value="qwen3-235b-a22b-instruct">qwen3-235b-a22b-instruct</option>
                <option value="qwen3-235b">qwen3-235b</option>
                <option value="qwen3-32b">qwen3-32b</option>
                <option value="qwen3-max">qwen3-max</option>
                <option value="qwen3-vl-plus">qwen3-vl-plus</option>
                <option value="qwen3-max-preview">qwen3-max-preview</option>
                <option value="tstars2.0">tstars2.0</option>
                <option value="qwen3-coder-plus">qwen3-coder-plus</option>
                <option value="deepseek-v3.2">deepseek-v3.2</option>
                <option value="deepseek-r1">deepseek-r1</option>
                <option value="deepseek-v3">deepseek-v3</option>
                <option value="kimi-k2-0905">kimi-k2-0905</option>
                <option value="kimi-k2">kimi-k2</option>
                <option value="custom">自定义模型</option>
            </select>
            <input type="text" id="customModel" placeholder="输入自定义模型名称" style="display: none; margin-top: 5px; width: 100%;">
        </div>
        <div class="api-config-item">
            <label for="apiTemperature">Temperature:</label>
            <input type="number" id="apiTemperature" value="0.7" min="0" max="2" step="0.1">
        </div>
        <div class="api-config-item">
            <label for="apiMaxTokens">Max Tokens:</label>
            <input type="number" id="apiMaxTokens" value="3000" min="1" max="256000" step="1">
        </div>
        
        <div class="api-config-actions">
            <button class="api-save-btn" id="apiSaveBtn">保存配置</button>
            <button class="api-test-btn" id="apiTestBtn">测试连接</button>
            <button class="api-reset-btn" id="apiResetBtn">关闭API面板</button>
            <button class="api-close-btn" id="apiCloseBtn">关闭</button><!--不能直接删除 要改自己叫AI修改-->
        </div>
    </div>

    <div class="settings-panel">
        <h2>🛠️ 反馈设置</h2>

        <div class="setting-item">
            <label for="soundToggle"><i>🔊</i> 启用声音</label>
            <label class="toggle-switch">
                <input type="checkbox" id="soundToggle" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="setting-item">
            <label for="vibrateToggle"><i>📳</i> 启用震动</label>
            <label class="toggle-switch">
                <input type="checkbox" id="vibrateToggle" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="setting-item">
            <label><i>🎶</i> 声音类型</label>
            <select id="soundType">
                <option value="sine:440">纯净电子音 (440Hz)</option>
                <option value="square:880">明亮电子音 (880Hz)</option>
                <option value="sawtooth:110">低沉环境音</option>
                <option value="triangle:220">柔和脉冲音</option>
                <option value="sine:660">温暖中音</option>
                <option value="square:1320">清脆高音</option>
            </select>
        </div>

        <div class="setting-item">
            <label><i>🔊</i> 音量强度</label>
            <div class="range-container">
                <input type="range" class="dynamic-slider" id="volumeControl" min="0" max="100" value="30">
                <span class="range-value" id="volumeValue">30%</span>
            </div>
        </div>

        <div class="setting-item">
            <label><i>⚡</i> 震动模式</label>
            <select id="vibrateMode">
                <option value="short">短促 (50ms)</option>
                <option value="medium">中等 (200ms)</option>
                <option value="long">长久 (500ms)</option>
                <option value="rhythm">节奏 (100/50/100ms)</option>
                <option value="heartbeat">心跳 (100/100/100/300ms)</option>
                <option value="custom">自定义 (200/100/200ms)</option>
            </select>
        </div>

        <div class="setting-item">
            <label><i>📳</i> 震感强度</label>
            <div class="range-container">
                <input type="range" class="dynamic-slider" id="vibrationStrength" min="1" max="10" value="5">
                <span class="range-value" id="vibrationValue">5</span>
            </div>
        </div>

        <div class="preview-buttons-container">
            <button class="preview-button" id="previewVibration">
                📳 预览震动效果
            </button>
            <button class="preview-button" id="previewSound">
                🔊 预览声音效果
            </button>
        </div>
    </div>

    <div class="container">
        <header>
            <!-- 标题已移动到顶部 -->
        </header>

        <div class="calculator">
            <div class="input-section">
                <h2 class="section-title"><i class="fas fa-edit"></i> 输入表达式</h2>

                <div class="input-group">
                    <label for="expression"><i class="fas fa-square-root-alt"></i> 数学表达式</label>
                    <textarea id="expression" placeholder="例如: e + π + √(3)"></textarea>
                </div>

                <div class="input-group">
                    <label for="operation"><i class="fas fa-tasks"></i> 计算类型</label>
                    <select id="operation">
                        <option value="derivative">求导 (d/dx)</option>
                        <option value="integral">不定积分 (∫ dx)</option>
                        <option value="definite_integral">定积分 (∫[a,b] dx)</option>
                        <option value="double_integral">二重不定积分 (∬ dxdy)</option>
                        <option value="double_definite_integral">二重定积分 (∬[a,b][c,d] dxdy)</option>
                        <option value="n_definite_integral">n重定积分 (∫...∫ dx₁...dxₙ)</option>
                        <option value="second_derivative">二阶导数 (d²/dx²)</option>
                        <option value="nth_derivative">n阶导数 (dⁿ/dxⁿ)</option>
                        <option value="simplify" selected>表达式化简</option>
                        <option value="evaluate">表达式求值</option>
                    </select>
                </div>

                <div class="input-group" id="nth-derivative-group" style="display: none;">
                    <label for="nth-order"><i class="fas fa-sort-numeric-up"></i> 导数阶数 (n)</label>
                    <input type="number" id="nth-order" min="1" max="10" value="3">
                </div>

                <div class="input-group" id="definite-integral-group" style="display: none;">
                    <label><i class="fas fa-arrows-alt-h"></i> 积分区间</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div style="flex: 1;">
                            <label for="lower-limit" style="font-size: 0.9em; margin-bottom: 5px;">下限 (a)</label>
                            <input type="text" id="lower-limit" placeholder="例如: 0, pi, -1" value="0">
                        </div>
                        <div style="flex: 1;">
                            <label for="upper-limit" style="font-size: 0.9em; margin-bottom: 5px;">上限 (b)</label>
                            <input type="text" id="upper-limit" placeholder="例如: 1, pi, e" value="1">
                        </div>
                    </div>
                </div>
                
                <div class="input-group" id="double-integral-group" style="display: none;">
                    <label><i class="fas fa-th"></i> 二重积分变量</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <label for="variable2" style="font-size: 0.9em; margin-bottom: 5px;">第二个变量</label>
                            <input type="text" id="variable2" placeholder="例如: y" value="y">
                        </div>
                    </div>
                </div>
                
                <div class="input-group" id="double-definite-integral-group" style="display: none;">
                    <label><i class="fas fa-th"></i> 二重积分变量与区间</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <label for="variable2-definite" style="font-size: 0.9em; margin-bottom: 5px;">第二个变量</label>
                            <input type="text" id="variable2-definite" placeholder="例如: y" value="y">
                        </div>
                    </div>
                    <label style="margin-top: 10px;">对第一个变量的积分区间 (x)</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <label for="x-lower" style="font-size: 0.9em; margin-bottom: 5px;">x下限</label>
                            <input type="text" id="x-lower" placeholder="0" value="0">
                        </div>
                        <div style="flex: 1;">
                            <label for="x-upper" style="font-size: 0.9em; margin-bottom: 5px;">x上限</label>
                            <input type="text" id="x-upper" placeholder="1" value="1">
                        </div>
                    </div>
                    <label>对第二个变量的积分区间 (y)</label>
                    <div style="display: flex; gap: 10px;">
                        <div style="flex: 1;">
                            <label for="y-lower" style="font-size: 0.9em; margin-bottom: 5px;">y下限</label>
                            <input type="text" id="y-lower" placeholder="0" value="0">
                        </div>
                        <div style="flex: 1;">
                            <label for="y-upper" style="font-size: 0.9em; margin-bottom: 5px;">y上限</label>
                            <input type="text" id="y-upper" placeholder="1" value="1">
                        </div>
                    </div>
                </div>
                
                <div class="input-group" id="n-definite-integral-group" style="display: none;">
                    <label><i class="fas fa-layer-group"></i> n重定积分设置</label>
                    <div style="margin-bottom: 10px;">
                        <label for="n-variables" style="font-size: 0.9em; margin-bottom: 5px;">变量列表 (逗号分隔,支持任意个数)</label>
                        <input type="text" id="n-variables" placeholder="例如: x,y,z 或 x,y,z,w,v..." value="x,y,z">
                        <p style="font-size: 0.85em; color: #666; margin-top: 5px;">提示: 变量个数决定积分重数</p>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label for="n-limits" style="font-size: 0.9em; margin-bottom: 5px;">积分区间 (格式: 下1,上1;下2,上2;...)</label>
                        <textarea id="n-limits" placeholder="例如: 0,1;0,1;0,1 (区间数量必须与变量数量一致)" style="min-height: 60px;">0,1;0,1;0,1</textarea>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label for="n-samples" style="font-size: 0.9em; margin-bottom: 5px;">采样数 (6维及以上使用)</label>
                        <input type="number" id="n-samples" placeholder="默认: 10000000" value="1000000" min="1000" step="1000">
                        <p style="font-size: 0.85em; color: #666; margin-top: 5px;">提示: 采样数越大精度越高但速度越慢,建议1万-1000万</p>
                    </div>
                </div>

                <div class="input-group" id="variable-group">
                    <label for="variable"><i class="fas fa-font"></i> 变量</label>
                    <input type="text" id="variable" value="x" placeholder="例如: x, y, t...">
                </div>

                <div class="input-group" id="evaluation-inputs" style="display: none;">
                    <label><i class="fas fa-keyboard"></i> 变量赋值</label>
                    <div class="evaluation-input">
                        <div id="variable-inputs">
                            </div>
                        <p style="font-size: 0.9rem; color: #ccc; margin-top: 5px;">为表达式中的变量输入具体数值</p>
                    </div>
                </div>

                <div class="btn-group">
                    <button class="calculate-btn" id="calculate">
                        <i class="fas fa-calculator"></i> 计算
                    </button>
                    <button class="paste-btn" id="paste">
                        <i class="fas fa-paste"></i> 粘贴
                    </button>
                    <button class="clear-btn" id="clear">
                        <i class="fas fa-broom"></i> 清除
                    </button>
                </div>
            </div>

            <div class="output-section">
                <h2 class="section-title"><i class="fas fa-chart-line"></i> 计算结果 </h2>
                <div class="output" id="output">
                    <p style="text-align: center; color: #ccc; padding: 30px;">
                        计算结果将显示在这里...
                    </p>
                </div>

                <div class="steps" id="steps">
                    </div>
            </div>
        </div>

        <div class="example-section">
            <h2 class="section-title"><i class="fas fa-lightbulb"></i> 示例表达式</h2>
            <p>点击以下示例快速尝试计算器功能：</p>

            <div class="examples">
                <div class="example" data-expr="e + π + √(3)">
                    <div class="example-title">常数项数值合并/符号保留测试</div>
                    <div class="example-expression">e + π + √(3)</div>
                </div>

                <div class="example" data-expr="(x+y)^3">
                    <div class="example-title">多项式展开/积分</div>
                    <div class="example-expression">(x+y)^3</div>
                </div>

                <div class="example" data-expr="425+163+225+60+24+25+50+51+495+24*x+40+98+570+91+112+190+15*x+271+110+119+200+165+240+100+435+415+920+405+104+269+640+133+124+120+133+227+207+354+240+240+128+261+60+144+129+169+88+700+519+94+637+466+613+475+15">
                    <div class="example-title">积分/求导优化测试 (长表达式)</div>
                    <div class="example-expression">425+163+...+15*x+...+15</div>
                </div>

                <div class="example" data-expr="exp(x) * log(x)">
                    <div class="example-title">非初等函数积分 (e^x ln(x))</div>
                    <div class="example-expression">exp(x) * log(x)</div>
                </div>

                <div class="example" data-expr="tan(π/2) + x + 1/x">
                    <div class="example-title">化简/求值 无穷大测试</div>
                    <div class="example-expression">tan(π/2) + x + 1/x</div>
                </div>

                <div class="example" data-expr="ln(x) + cos(0)">
                    <div class="example-title">化简/求值 0点对数测试</div>
                    <div class="example-expression">ln(x) + cos(0)</div>
                </div>

                <div class="example" data-expr="x^4 + 3*x^2 - 6*x + x + 1">
                    <div class="example-title">多项式求导</div>
                    <div class="example-expression">x^4 + 3*x^2 - 6*x + x + 1</div>
                </div>

                <div class="example" data-expr="log3(27) + log5(1) + log(x) + π/2">
                    <div class="example-title">任意底对数 + π 显示测试</div>
                    <div class="example-expression">log3(27) + log5(1) + log(x) + π/2</div>
                </div>
                <div class="example" data-expr="log(3.14)(3.14) + log(1/2)(pi) + log(e)(pi*e)">
                    <div class="example-title">小数分数底数对数测试</div>
                    <div class="example-expression">log(3.14)(3.14) + log(1/2)(π) + log(e)(π*e)</div>
                </div>
                
                <div class="example" data-expr="3x2 + 5y3">
                    <div class="example-title">X乘法测试 (3x2=3*2)</div>
                    <div class="example-expression">3x2 + 5y3</div>
                </div>
                
                <div class="example" data-expr="ln(x)x5">
                    <div class="example-title">X乘法测试 (ln(x)x5=ln(x)*5)</div>
                    <div class="example-expression">ln(x)x5</div>
                </div>
                
                <div class="example" data-expr="3* (3+6)x9+ln(x)x5 x 6">
                    <div class="example-title">X乘法测试 (带空格的x乘法)</div>
                    <div class="example-expression">3* (3+6)x9+ln(x)x5 x 6</div>
                </div>
                
                <div class="example" data-expr="3i + 1-5i">
                    <div class="example-title">虚数支持测试</div>
                    <div class="example-expression">3i + 1-5i</div>
                </div>
                
                <div class="example" data-expr="π + 2π/3 - π/6">
                    <div class="example-title">π符号常数运算测试</div>
                    <div class="example-expression">π + 2π/3 - π/6</div>
                </div>
                
                <div class="example" data-expr="10 ÷ 2 + 3 ÷ 4">
                    <div class="example-title">÷符号除法测试</div>
                    <div class="example-expression">10 ÷ 2 + 3 ÷ 4</div>
                </div>
                
                <div class="example" data-expr="x^2" data-operation="definite_integral" data-lower="0" data-upper="1">
                    <div class="example-title">定积分示例: ∫[0,1] x² dx</div>
                    <div class="example-expression">x^2 (定积分 0到1)</div>
                </div>
                
                <div class="example" data-expr="sin(x)" data-operation="definite_integral" data-lower="0" data-upper="pi">
                    <div class="example-title">定积分示例: ∫[0,π] sin(x) dx</div>
                    <div class="example-expression">sin(x) (定积分 0到π)</div>
                </div>
                
                <div class="example" data-expr="exp(x)" data-operation="definite_integral" data-lower="0" data-upper="1">
                    <div class="example-title">定积分示例: ∫[0,1] e^x dx</div>
                    <div class="example-expression">exp(x) (定积分 0到1)</div>
                </div>
                
                <div class="example" data-expr="1/x" data-operation="definite_integral" data-lower="1" data-upper="e">
                    <div class="example-title">定积分示例: ∫[1,e] 1/x dx</div>
                    <div class="example-expression">1/x (定积分 1到e)</div>
                </div>
                
                <div class="example" data-expr="cos(x)" data-operation="definite_integral" data-lower="0" data-upper="pi/2">
                    <div class="example-title">定积分示例: ∫[0,π/2] cos(x) dx</div>
                    <div class="example-expression">cos(x) (定积分 0到π/2)</div>
                </div>
                
                <div class="example" data-expr="x*y" data-operation="double_integral">
                    <div class="example-title">二重不定积分: ∬ xy dxdy</div>
                    <div class="example-expression">x*y (二重不定积分)</div>
                </div>
                
                <div class="example" data-expr="x^2 + y^2" data-operation="double_integral">
                    <div class="example-title">二重不定积分: ∬ (x²+y²) dxdy</div>
                    <div class="example-expression">x^2 + y^2 (二重不定积分)</div>
                </div>
                
                <div class="example" data-expr="x*y" data-operation="double_definite_integral" data-x-lower="0" data-x-upper="1" data-y-lower="0" data-y-upper="1">
                    <div class="example-title">二重定积分: ∬[0,1][0,1] xy dxdy</div>
                    <div class="example-expression">x*y (二重定积分 x:0到1, y:0到1)</div>
                </div>
                
                <div class="example" data-expr="sin(x)*cos(y)" data-operation="double_definite_integral" data-x-lower="0" data-x-upper="pi" data-y-lower="0" data-y-upper="pi">
                    <div class="example-title">二重定积分: ∬[0,π][0,π] sin(x)cos(y) dxdy</div>
                    <div class="example-expression">sin(x)*cos(y) (二重定积分)</div>
                </div>
                
                <div class="example" data-expr="exp(x+y)" data-operation="double_definite_integral" data-x-lower="0" data-x-upper="1" data-y-lower="0" data-y-upper="1">
                    <div class="example-title">二重定积分: ∬[0,1][0,1] e^(x+y) dxdy</div>
                    <div class="example-expression">exp(x+y) (二重定积分)</div>
                </div>
                
                <div class="example" data-expr="x*y*z" data-operation="n_definite_integral" data-n-variables="x,y,z" data-n-limits="0,1;0,1;0,1">
                    <div class="example-title">三重定积分: ∫[0,1][0,1][0,1] xyz dxdydz</div>
                    <div class="example-expression">x*y*z (三重定积分)</div>
                </div>
                
                <div class="example" data-expr="x^2+y^2+z^2" data-operation="n_definite_integral" data-n-variables="x,y,z" data-n-limits="0,1;0,1;0,1">
                    <div class="example-title">三重定积分: ∫[0,1]³ (x²+y²+z²) dxdydz</div>
                    <div class="example-expression">x^2+y^2+z^2 (三重定积分)</div>
                </div>
                
                <div class="example" data-expr="sin(x)*cos(y)*exp(z)" data-operation="n_definite_integral" data-n-variables="x,y,z" data-n-limits="0,pi;0,pi;0,1">
                    <div class="example-title">三重定积分: sin(x)cos(y)e^z</div>
                    <div class="example-expression">sin(x)*cos(y)*exp(z)</div>
                </div>
            </div>
        </div>

        <div class="function-reference">
            <h2 class="section-title"><i class="fas fa-book"></i> 支持的函数与符号</h2>

            <div class="function-categories">
                <div class="function-category">
                    <div class="category-title">基本运算</div>
                    <ul class="function-list">
                        <li>+ (加法)</li>
                        <li>- (减法)</li>
                        <li>* 和 x (乘法)</li>
                        <li>/ 和 ÷ (除法)</li>
                        <li>^ (幂运算)</li>
                        <li>() (括号)</li>
                        <li>sqrt(x) - 平方根 √ </li>
                    </ul>
                </div>

                <div class="function-category">
                    <div class="category-title">三角函数</div>
                    <ul class="function-list">
                        <li>sin(x) - 正弦</li>
                        <li>cos(x) - 余弦</li>
                        <li>tan(x) - 正切</li>
                        <li>cot(x) - 余切</li>
                        <li>sec(x) - 正割</li>
                        <li>csc(x) - 余割</li>
                        <li>asin(x) - 反正弦</li>
                        <li>acos(x) - 反余弦</li>
                        <li>atan(x) - 反正切</li>
                    </ul>
                </div>

                <div class="function-category">
                    <div class="category-title">双曲函数</div>
                    <ul class="function-list">
                        <li>sinh(x) - 双曲正弦</li>
                        <li>cosh(x) - 双曲余弦</li>
                        <li>tanh(x) - 双曲正切</li>
                        <li>asinh(x) - 反双曲正弦</li>
                        <li>acosh(x) - 反双曲余弦</li>
                        <li>atanh(x) - 反双曲正切</li>
                    </ul>
                </div>

                <div class="function-category">
                    <div class="category-title">指数与对数 <i class="fas fa-magic"></i></div>
                    <ul class="function-list">
                        <li>exp(x) - 指数函数 e^(x)</li>
                        <li>log(x) 和 ln(x) 和 lg(x) - 对数函数</li>
                        <li>log10(x) 或 lg(x) - 以10为底的对数</li>
                        <li>logN(n) (例如 log3(5)) - 任意底的对数</li>
                    </ul>
                </div>

                <div class="function-category">
                    <div class="category-title">特殊函数与积分</div>
                    <ul class="function-list">
                        <li>abs(x) - 绝对值</li>
                        <li>factorial(n) - 阶乘</li>
                        <li>gamma(x) - 伽马函数</li>
                        <li>∫(e^x/x)dx - 指数积分 (非初等函数) </li>
                    </ul>
                </div>

                <div class="function-category">
                    <div class="category-title">常数</div>
                    <ul class="function-list">
                        <li>pi 和 π - 圆周率 π </li>
                        <li>e - 自然常数</li>
                        <li>i - 虚数单位</li>
                        <li>inf 和 ∞ - 无穷大</li>
                    </ul>
                </div>
            </div>
        </div>

        <footer>
            <p>专业数学计算器 ProMax &copy; 2025</p>
        </footer>
    </div>

    <script>
        // 极致性能优化：使用单例模式和高效缓存
        const App = {
            // 性能监控
            performance: {
                startTime: performance.now(),
                measure: function(name) {
                    return performance.now() - this.startTime;
                }
            },

            // 全局缓存系统
            cache: {
                dom: new Map(),
                results: new Map(),
                calculations: new Map(),
                maxSize: 100,
                
                get(key) {
                    const value = this.results.get(key);
                    if (value) {
                        // LRU: 移动到最后
                        this.results.delete(key);
                        this.results.set(key, value);
                    }
                    return value;
                },
                
                set(key, value) {
                    if (this.results.size >= this.maxSize) {
                        // 删除最旧的项
                        const firstKey = this.results.keys().next().value;
                        this.results.delete(firstKey);
                    }
                    this.results.set(key, value);
                },
                has(key) {
                    return this.results.has(key);
                },
     
                clear() {
                    this.results.clear();
                }
            },

            // DOM元素缓存
            elements: {},
            
            // 声音控制变量
            audio: {
                context: null,
                oscillator: null,
                gainNode: null,
                isPlaying: false,
                
                init() {
                    if (!this.context) {
                        this.context = new (window.AudioContext || window.webkitAudioContext)();
                        this.gainNode = this.context.createGain();
                        this.gainNode.connect(this.context.destination);
                        this.gainNode.gain.value = 0.06; // 初始音量降低
                    }
                    return this.context;
                },
                
                play(type, freq, duration = 0.3) {
                    if (!App.elements.soundToggle.checked) return;
                    
                    const audioCtx = this.init();
                    
                    if (this.isPlaying && this.oscillator) {
                        this.oscillator.stop();
                    }
                    
                    this.oscillator = audioCtx.createOscillator();
                    this.oscillator.connect(this.gainNode);
                    this.oscillator.type = type;
                    this.oscillator.frequency.setValueAtTime(parseFloat(freq), audioCtx.currentTime);
                    this.oscillator.start(0);
                    this.oscillator.stop(audioCtx.currentTime + duration);
                    this.isPlaying = true;
                    
                    setTimeout(() => {
                        this.isPlaying = false;
                    }, duration * 1000);
                }
            },

            // 振动控制
            vibration: {
                patterns: {
                    'short': 50,
                    'medium': 200,
                    'long': 500,
                    'rhythm': [100, 50, 100],
                    'heartbeat': [100, 100, 100, 300],
                    'custom': [200, 100, 200]
                },
                
                trigger(patternName) {
                    if (!App.elements.vibrateToggle.checked || !navigator.vibrate) return;
                    
                    const pattern = this.patterns[patternName];
                    const strength = parseInt(App.elements.vibrationStrength.value);
                    let adjustedPattern;
                    
                    if (Array.isArray(pattern)) {
                        adjustedPattern = pattern.map(val => Math.min(val * strength / 5, 1000));
                    } else {
                        adjustedPattern = Math.min(pattern * strength / 5, 1000);
                    }
                    
                    navigator.vibrate(adjustedPattern);
                }
            },

            // 搜索数据库
            searchData: {
                functions: [
                    { name: 'sin', description: '正弦函数', example: 'sin(x)', category: 'functions' },
                    { name: 'cos', description: '余弦函数', example: 'cos(x)', category: 'functions' },
                    { name: 'tan', description: '正切函数', example: 'tan(x)', category: 'functions' },
                    { name: 'log', description: '对数函数', example: 'log(x)', category: 'functions' },
                    { name: 'ln', description: '自然对数', example: 'ln(x)', category: 'functions' },
                    { name: 'sqrt', description: '平方根', example: 'sqrt(x)', category: 'functions' },
                    { name: 'exp', description: '指数函数', example: 'exp(x)', category: 'functions' },
                    { name: 'abs', description: '绝对值', example: 'abs(x)', category: 'functions' },
                    { name: 'derivative', description: '求导', example: 'derivative(x^2)', category: 'operations' },
                    { name: 'integral', description: '积分', example: 'integral(x^2)', category: 'operations' }
                ],
                constants: [
                    { name: 'pi', description: '圆周率 π', example: 'pi', category: 'constants' },
                    { name: 'e', description: '自然常数', example: 'e', category: 'constants' },
                    { name: 'i', description: '虚数单位', example: 'i', category: 'constants' }
                ],
                examples: [
                    { name: '二次函数求导', description: 'x² 的导数', example: 'derivative(x^2)', category: 'examples' },
                    { name: '三角函数积分', description: 'sin(x) 的积分', example: 'integral(sin(x))', category: 'examples' },
                    { name: '复合函数', description: 'e^x + ln(x)', example: 'exp(x) + ln(x)', category: 'examples' },
                    { name: '平方根计算', description: '√(x² + 1)', example: 'sqrt(x^2 + 1)', category: 'examples' }
                ]
            },

            // 搜索历史
            searchHistory: JSON.parse(localStorage.getItem('searchHistory') || '[]'),

            // 聊天位置跟踪
            chatTracking: {
                lastExpandedMessage: null,
                trackExpandedMessage: function(messageElement) {
                    // 记录展开/折叠的消息元素
                    this.lastExpandedMessage = messageElement;
                },
                returnToPosition: function() {
                    if (this.lastExpandedMessage) {
                        // 获取消息元素的位置
                        let targetElement = this.lastExpandedMessage;
                        
                        // 如果记录的是AI消息，尝试找到其中的思考过程容器
                        if (targetElement.classList.contains('ai-message')) {
                            const reasoningContainer = targetElement.querySelector('.reasoning-container');
                            if (reasoningContainer) {
                                targetElement = reasoningContainer;
                            }
                        }
                        
                        const messageRect = targetElement.getBoundingClientRect();
                        const chatMessages = App.elements.chatMessages;
                        const chatRect = chatMessages.getBoundingClientRect();
                        
                        // 计算消息相对于聊天容器的位置
                        const relativeTop = messageRect.top - chatRect.top + chatMessages.scrollTop;
                        
                        // 平滑滚动到消息位置
                        chatMessages.scrollTo({
                            top: relativeTop - 50, // 稍微向上偏移，确保消息完全可见
                            behavior: 'smooth'
                        });
                        
                        // 添加视觉反馈
                        this.addVisualFeedback(targetElement);
                    } else {
                        // 如果没有记录的位置，显示提示
                        App.calculator.showSuccessMessage('没有记录的回展位置，请先点击思考过程的回展按钮');
                    }
                },
                addVisualFeedback: function(messageElement) {
                    // 为消息元素添加临时高亮效果
                    const originalBorder = messageElement.style.border;
                    const originalBoxShadow = messageElement.style.boxShadow;
                    
                    messageElement.style.border = '2px solid rgba(241, 196, 15, 0.8)';
                    messageElement.style.boxShadow = '0 0 15px rgba(241, 196, 15, 0.6)';
                    messageElement.style.transition = 'border 0.3s, box-shadow 0.3s';
                    
                    // 2秒后恢复原始样式
                    setTimeout(() => {
                        messageElement.style.border = originalBorder;
                        messageElement.style.boxShadow = originalBoxShadow;
                    }, 2000);
                }
            },

            // API配置管理
            apiConfig: {
                defaultConfig: {
                    url: 'https://apis.iflow.cn/v1/chat/completions',
                    key: 'sk-07f5c088f32838e9d121dad3bc76a2e4',
                    model: 'glm-4.6',
                    temperature: 0.7,
                    maxTokens: 1000
                },
                
                connectionStatus: false,
                
                getConfig() {
                    const savedConfig = localStorage.getItem('apiConfig');
                    if (savedConfig) {
                        try {
                            return JSON.parse(savedConfig);
                        } catch (e) {
                            console.error('解析API配置失败:', e);
                            return { ...this.defaultConfig };
                        }
                    }
                    return { ...this.defaultConfig };
                },
                
                saveConfig(config) {
                    try {
                        localStorage.setItem('apiConfig', JSON.stringify(config));
                        return true;
                    } catch (e) {
                        console.error('保存API配置失败:', e);
                        return false;
                    }
                },
                
                resetToDefault() {
                    this.saveConfig(this.defaultConfig);
                    return this.defaultConfig;
                },
                
                // 测试API连接
                async testConnection(config) {
                    try {
                        console.log('测试API连接:', config.url);
                        
                        const response = await fetch(config.url, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${config.key}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                model: config.model,
                                messages: [
                                    { role: 'user', content: '你好，这是一个连接测试' }
                                ],
                                temperature: parseFloat(config.temperature),
                                max_tokens: 10
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP错误: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        if (data.choices && data.choices.length > 0) {
                            this.connectionStatus = true;
                            return { success: true, message: '连接成功' };
                        } else {
                            throw new Error('API返回数据格式错误');
                        }
                    } catch (error) {
                        this.connectionStatus = false;
                        throw error;
                    }
                },
                
                async callAPI(messages) {
                    const config = this.getConfig();
                    
                    try {
                        console.log('=== AIOS API调用开始 (非流式) ===');
                        console.log('API URL:', config.url);
                        console.log('使用模型:', config.model);
                        console.log('Temperature:', config.temperature);
                        console.log('Max Tokens:', config.maxTokens);
                        
                        // 处理消息格式：如果是字符串，转换为标准格式；如果是数组，直接使用
                        let messagesArray;
                        if (typeof messages === 'string') {
                            messagesArray = [
                                { role: 'user', content: messages }
                            ];
                            console.log('发送消息:', messages);
                        } else if (Array.isArray(messages)) {
                            messagesArray = messages;
                            console.log('发送消息数组:', JSON.stringify(messages, null, 2));
                        } else {
                            throw new Error('消息格式错误，应该是字符串或数组');
                        }
                        
                        const requestBody = {
                            model: config.model,
                            messages: messagesArray,
                            temperature: parseFloat(config.temperature),
                            max_tokens: parseInt(config.maxTokens)
                        };
                        
                        console.log('请求体:', JSON.stringify(requestBody, null, 2));
                        
                        // 使用fetch发送请求
                        const response = await fetch(config.url, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${config.key}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(requestBody)
                        });
                        
                        console.log('API响应状态:', response.status, response.statusText);
                        
                        const data = await response.json();
                        console.log('API响应数据:', JSON.stringify(data, null, 2));
                        
                        if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                            console.log('API调用成功，返回内容:', data.choices[0].message.content);
                            console.log('=== AIOS API调用结束 (非流式) ===');
                            return data.choices[0].message.content;
                        } else {
                            console.error('API返回数据格式:', JSON.stringify(data, null, 2));
                            // 检查特定错误并返回友好提示
                            if (data.status === "435" && data.msg === "Model not support") {
                                const availableModels = 'glm-4.6, qwen3-235b-a22b-thinking-2507, qwen3-235b-a22b-instruct, qwen3-235b, qwen3-32b, qwen3-max, qwen3-vl-plus, qwen3-max-preview, tstars2.0, qwen3-coder-plus, deepseek-v3.2, deepseek-r1, deepseek-v3, kimi-k2-0905, kimi-k2';
                                const error = new Error(`当前模型不被支持，请尝试更换为以下可用模型之一：${availableModels}`);
                                console.error('模型不支持错误:', error);
                                console.log('=== AIOS API调用结束 (非流式) ===');
                                throw error;
                            } else {
                                // 提供更详细的错误信息
                                const errorMsg = `API返回数据格式错误。状态码: ${response.status}, 返回数据: ${JSON.stringify(data)}`;
                                const error = new Error(errorMsg);
                                console.error('数据格式错误:', error);
                                console.log('=== AIOS API调用结束 (非流式) ===');
                                throw error;
                            }
                        }
                    } catch (error) {
                        console.error('API调用错误:', error);
                        console.error('错误详情:', {
                            name: error.name,
                            message: error.message,
                            stack: error.stack
                        });
                        console.log('=== AIOS API调用结束 (非流式) ===');
                        throw error;
                    }
                },
                
                // 新增流式API调用方法
                async callStreamAPI(messages, onChunk, abortController) {
                    const config = this.getConfig();
                    
                    // 初始化流式缓冲区
                    this.streamBuffer = '';
                    let requestActive = true; // 添加请求状态标志
                    let reader = null; // 保存reader引用以便取消
                    let response = null; // 保存响应对象
                    
                    // 创建取消处理函数
                    const handleAbort = () => {
                        console.log('收到取消请求，正在停止...');
                        requestActive = false;
                        
                        // 取消reader
                        if (reader) {
                            try {
                                reader.cancel('用户停止生成').catch(e => {
                                    console.log('取消reader时的预期错误:', e);
                                });
                            } catch (e) {
                                console.log('取消reader时出错:', e);
                            }
                        }
                        
                        // 取消fetch请求
                        if (abortController) {
                            try {
                                abortController.abort('用户停止生成');
                            } catch (e) {
                                console.log('取消请求时出错:', e);
                            }
                        }
                    };
                    
                    // 监听取消信号
                    if (abortController.signal.aborted) {
                        console.log('请求在开始前已被取消');
                        return;
                    }
                    
                    abortController.signal.addEventListener('abort', handleAbort);
                    
                    try {
                        console.log('=== AIOS API调用开始 ===');
                        console.log('API URL:', config.url);
                        console.log('使用模型:', config.model);
                        console.log('Temperature:', config.temperature);
                        console.log('Max Tokens:', config.maxTokens);
                        
                        // 处理消息格式：如果是字符串，转换为标准格式；如果是数组，直接使用
                        let messagesArray;
                        if (typeof messages === 'string') {
                            messagesArray = [
                                { role: 'user', content: messages }
                            ];
                            console.log('发送消息:', messages);
                        } else if (Array.isArray(messages)) {
                            messagesArray = messages;
                            console.log('发送消息数组:', JSON.stringify(messages, null, 2));
                        } else {
                            throw new Error('消息格式错误，应该是字符串或数组');
                        }
                        
                        const requestBody = {
                            model: config.model,
                            messages: messagesArray,
                            temperature: parseFloat(config.temperature),
                            max_tokens: parseInt(config.maxTokens),
                            stream: true  // 启用流式输出
                        };
                        
                        console.log('请求体:', JSON.stringify(requestBody, null, 2));
                        
                        // 使用fetch发送流式请求
                        const response = await fetch(config.url, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${config.key}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(requestBody),
                            signal: abortController.signal
                        });
                        
                        // 检查请求是否已被取消
                        if (abortController.signal.aborted) {
                            console.log('请求在发送后但处理响应前被取消');
                            throw new DOMException('请求被取消', 'AbortError');
                        }
                        
                        console.log('响应状态:', response.status, response.statusText);
                        
                        if (!response.ok) {
                            console.error('API请求失败，状态码:', response.status);
                            throw new Error(`API请求失败，状态码: ${response.status}`);
                        }
                        
                        console.log('开始处理流式响应...');
                        
                        // 处理流式响应
                        reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let chunkCount = 0;
                        
                        while (requestActive && !abortController.signal.aborted) {
                            try {
                                // 检查是否已被取消
                                if (abortController.signal.aborted) {
                                    console.log('检测到取消信号，停止读取数据');
                                    break;
                                }
                                
                                const { done, value } = await reader.read();
                                if (done) {
                                    console.log('流式响应完成，总共接收到', chunkCount, '个数据块');
                                    break;
                                }
                                
                                // 再次检查是否已被取消
                                if (abortController.signal.aborted) {
                                    console.log('读取数据后检测到取消信号');
                                    break;
                                }
                                
                                // 解码数据块
                                const chunk = decoder.decode(value, { stream: true });
                                chunkCount++;
                                
                                console.log(`--- 数据块 #${chunkCount} ---`);
                                console.log('原始数据长度:', chunk.length);
                                
                                // 处理可能不完整的JSON数据
                                let buffer = (this.streamBuffer || '') + chunk;
                                let processedLines = [];
                                
                                // 简化的解析方法：直接按data:分割
                                const dataSections = buffer.split(/data:\s*/);
                                
                                for (let i = 0; i < dataSections.length && requestActive && !abortController.signal.aborted; i++) {
                                    const section = dataSections[i].trim();
                                    if (!section) continue;
                                    
                                    if (section === '[DONE]') {
                                        console.log('收到流式结束标记 [DONE]');
                                        requestActive = false;
                                        return;
                                    }
                                    
                                    // 尝试找到完整的JSON字符串
                                    let jsonStr = '';
                                    let braceCount = 0;
                                    let inString = false;
                                    let escapeNext = false;
                                    
                                    for (let j = 0; j < section.length; j++) {
                                        const char = section[j];
                                        
                                        if (escapeNext) {
                                            escapeNext = false;
                                            jsonStr += char;
                                            continue;
                                        }
                                        
                                        if (char === '\\') {
                                            escapeNext = true;
                                            jsonStr += char;
                                            continue;
                                        }
                                        
                                        if (char === '"' && !escapeNext) {
                                            inString = !inString;
                                            jsonStr += char;
                                            continue;
                                        }
                                        
                                        if (!inString) {
                                            if (char === '{') {
                                                braceCount++;
                                            } else if (char === '}') {
                                                braceCount--;
                                            }
                                        }
                                        
                                        jsonStr += char;
                                        
                                        if (braceCount === 0 && jsonStr.startsWith('{')) {
                                            break;
                                        }
                                    }
                                    
                                    if (jsonStr && jsonStr.startsWith('{') && braceCount === 0) {
                                        try {
                                            const data = JSON.parse(jsonStr);
                                            processedLines.push(data);
                                        } catch (e) {
                                            console.error('解析JSON失败:', e);
                                        }
                                    }
                                }
                                
                                // 检查是否有未处理的数据（可能是不完整的JSON）
                                const lastSection = dataSections[dataSections.length - 1];
                                const hasIncompleteJson = lastSection && !lastSection.includes('}') && lastSection.trim();
                                
                                if (hasIncompleteJson) {
                                    // 如果缓冲区还有不完整的数据，保存到下一次处理
                                    this.streamBuffer = lastSection;
                                } else {
                                    this.streamBuffer = '';
                                }
                                
                                // 处理解析成功的数据
                                for (const data of processedLines) {
                                    // 再次检查是否已被取消
                                    if (abortController.signal.aborted) {
                                        console.log('处理数据前检测到取消信号');
                                        requestActive = false;
                                        return;
                                    }
                                    
                                    const delta = data.choices?.[0]?.delta;
                                    
                                    // 分别处理 content 和 reasoning_content
                                    if (delta?.content && delta.content.trim()) {
                                        // 调用回调函数处理正常内容
                                        onChunk(delta.content, 'content');
                                    }
                                    
                                    if (delta?.reasoning_content && delta.reasoning_content.trim()) {
                                        // 调用回调函数处理思考过程
                                        onChunk(delta.reasoning_content, 'reasoning');
                                    }
                                    
                                    // 检查是否完成
                                    if (data.choices?.[0]?.finish_reason) {
                                        console.log('流式响应完成原因:', data.choices[0].finish_reason);
                                        requestActive = false;
                                        return;
                                    }
                                }
                            } catch (readError) {
                                if (readError.name === 'AbortError' || abortController.signal.aborted) {
                                    console.log('读取数据时检测到取消信号');
                                    requestActive = false;
                                    break;
                                } else {
                                    throw readError;
                                }
                            }
                        }
                        
                        // 确保请求状态被正确设置
                        requestActive = false;
                        
                    } catch (error) {
                        console.log('=== AIOS API调用结束 ===');
                        requestActive = false;
                        
                        // 移除事件监听器
                        abortController.signal.removeEventListener('abort', handleAbort);
                        
                        if (error.name === 'AbortError' || abortController.signal.aborted) {
                            console.log('API请求已被取消');
                            // 不抛出错误，让调用方处理取消
                            return;
                        } else {
                            console.error('流式API调用错误:', error);
                            console.error('错误详情:', {
                                name: error.name,
                                message: error.message,
                                stack: error.stack
                            });
                            throw error;
                        }
                    } finally {
                        // 移除事件监听器
                        abortController.signal.removeEventListener('abort', handleAbort);
                    }
                }
            },

            // 优化后的计算器核心
            calculator: {
                tolerance: 1e-10,
                
                init() {
                    this.cacheDOM();
                    this.bindEvents();
                    this.setupPasteHandler();
                    this.handleOperationChange();
                },
                
                cacheDOM() {
                    App.elements = {
                        // 设置面板元素
                        settingsButton: document.querySelector('.settings-button'),
                        searchButton: document.querySelector('.search-button'),
                        aiosButton: document.querySelector('.aios-button'),
                        settingsPanel: document.querySelector('.settings-panel'),
                        searchPanel: document.querySelector('.search-panel'),
                        aiosPanel: document.querySelector('.aios-panel'),
                        soundToggle: document.getElementById('soundToggle'),
                        vibrateToggle: document.getElementById('vibrateToggle'),
                        soundType: document.getElementById('soundType'),
                        vibrateMode: document.getElementById('vibrateMode'),
                        volumeControl: document.getElementById('volumeControl'),
                        volumeValue: document.getElementById('volumeValue'),
                        vibrationStrength: document.getElementById('vibrationStrength'),
                        vibrationValue: document.getElementById('vibrationValue'),
                        previewVibrationBtn: document.getElementById('previewVibration'),
                        previewSoundBtn: document.getElementById('previewSound'),
                        
                        // 搜索元素
                        searchInput: document.getElementById('searchInput'),
                        searchBtn: document.getElementById('searchBtn'),
                        searchCategory: document.getElementById('searchCategory'),
                        searchHistory: document.getElementById('searchHistory'),
                        searchResults: document.getElementById('searchResults'),
                        clearSearchBtn: document.getElementById('clearSearchBtn'),
                        closeSearchBtn: document.getElementById('closeSearchBtn'),
                        
                        // AIOS元素
                        chatInput: document.getElementById('chatInput'),
                        sendBtn: document.getElementById('sendBtn'),
                        chatMessages: document.getElementById('chatMessages'),
                        voiceBtn: document.getElementById('voiceBtn'),
                        closeAiosBtn: document.getElementById('closeAiosBtn'),
                        
                        // API配置元素
                        apiConfigBtn: document.getElementById('apiConfigBtn'),
                        apiPanel: document.querySelector('.api-panel'),
                        apiCloseBtn: document.getElementById('apiCloseBtn'),
                        apiUrl: document.getElementById('apiUrl'),
                        apiKey: document.getElementById('apiKey'),
                        apiModel: document.getElementById('apiModel'),
                        customModel: document.getElementById('customModel'),
                        apiTemperature: document.getElementById('apiTemperature'),
                        apiMaxTokens: document.getElementById('apiMaxTokens'),
                        apiSaveBtn: document.getElementById('apiSaveBtn'),
                        apiTestBtn: document.getElementById('apiTestBtn'),
                        apiResetBtn: document.getElementById('apiResetBtn'),
                        
                        // 新增元素
                        closeAiosLeftBtn: document.getElementById('closeAiosLeftBtn'),
                        closeAiosRightBtn: document.getElementById('closeAiosRightBtn'),
                        chatTopBtn: document.getElementById('chatTopBtn'),
                        chatBottomBtn: document.getElementById('chatBottomBtn'),
                        chatTrackBtn: document.getElementById('chatTrackBtn'),
                        chatClearBtn: document.getElementById('chatClearBtn'),
                        
                        // 计算器元素
                        expressionInput: document.getElementById('expression'),
                        operationSelect: document.getElementById('operation'),
                        variableInput: document.getElementById('variable'),
                        nthDerivativeGroup: document.getElementById('nth-derivative-group'),
                        nthOrderInput: document.getElementById('nth-order'),
                        definiteIntegralGroup: document.getElementById('definite-integral-group'),
                        lowerLimitInput: document.getElementById('lower-limit'),
                        upperLimitInput: document.getElementById('upper-limit'),
                        doubleIntegralGroup: document.getElementById('double-integral-group'),
                        variable2Input: document.getElementById('variable2'),
                        doubleDefiniteIntegralGroup: document.getElementById('double-definite-integral-group'),
                        variable2DefiniteInput: document.getElementById('variable2-definite'),
                        xLowerInput: document.getElementById('x-lower'),
                        xUpperInput: document.getElementById('x-upper'),
                        yLowerInput: document.getElementById('y-lower'),
                        yUpperInput: document.getElementById('y-upper'),
                        nDefiniteIntegralGroup: document.getElementById('n-definite-integral-group'),
                        nVariablesInput: document.getElementById('n-variables'),
                        nLimitsInput: document.getElementById('n-limits'),
                        nSamplesInput: document.getElementById('n-samples'),
                        evaluationInputs: document.getElementById('evaluation-inputs'),
                        variableInputs: document.getElementById('variable-inputs'),
                        calculateBtn: document.getElementById('calculate'),
                        pasteBtn: document.getElementById('paste'),
                        clearBtn: document.getElementById('clear'),
                        outputDiv: document.getElementById('output'),
                        stepsDiv: document.getElementById('steps'),
                        examples: document.querySelectorAll('.example')
                    };
                },
                
                bindEvents() {
                    const { operationSelect, calculateBtn, clearBtn, examples, expressionInput } = App.elements;
                    
                    // 使用防抖优化输入事件
                    const debouncedUpdateVariableInputs = this.debounce(() => {
                        if (operationSelect.value === 'evaluate') {
                            this.updateVariableInputs();
                        }
                    }, 300);
                    
                    operationSelect.addEventListener('change', () => this.handleOperationChange());
                    calculateBtn.addEventListener('click', () => this.handleCalculate());
                    clearBtn.addEventListener('click', () => this.handleClear());
                    
                    examples.forEach(example => {
                        example.addEventListener('click', (e) => {
                            const expression = e.currentTarget.getAttribute('data-expr');
                            const operation = e.currentTarget.getAttribute('data-operation');
                            const lower = e.currentTarget.getAttribute('data-lower');
                            const upper = e.currentTarget.getAttribute('data-upper');
                            const xLower = e.currentTarget.getAttribute('data-x-lower');
                            const xUpper = e.currentTarget.getAttribute('data-x-upper');
                            const yLower = e.currentTarget.getAttribute('data-y-lower');
                            const yUpper = e.currentTarget.getAttribute('data-y-upper');
                            const nVariables = e.currentTarget.getAttribute('data-n-variables');
                            const nLimits = e.currentTarget.getAttribute('data-n-limits');
                        
                            expressionInput.value = expression;
                            if (operationSelect.value === 'evaluate') {
                                this.updateVariableInputs();
                            }

                            // 如果示例指定了操作类型,切换到对应操作
                            if (operation) {
                                operationSelect.value = operation;
                                this.handleOperationChange();
                                
                                // 如果是定积分,设置上下限
                                if (operation === 'definite_integral' && lower && upper) {
                                    App.elements.lowerLimitInput.value = lower;
                                    App.elements.upperLimitInput.value = upper;
                                }
                                
                                // 如果是二重定积分,设置上下限
                                if (operation === 'double_definite_integral' && xLower && xUpper && yLower && yUpper) {
                                    App.elements.xLowerInput.value = xLower;
                                    App.elements.xUpperInput.value = xUpper;
                                    App.elements.yLowerInput.value = yLower;
                                    App.elements.yUpperInput.value = yUpper;
                                }
                                
                                // 如果是n重定积分,设置变量和区间
                                if (operation === 'n_definite_integral' && nVariables && nLimits) {
                                    App.elements.nVariablesInput.value = nVariables;
                                    App.elements.nLimitsInput.value = nLimits;
                                }
                            }
                            if (operationSelect.value === 'evaluate') {
                                this.updateVariableInputs();
                            }

                            // 当选择n重定积分时，自动更新变量列表
                            if (operationSelect.value === 'n_definite_integral') {
                                this.updateNDefiniteIntegralVariables();
                            }
                        });
                    });
                    
                    expressionInput.addEventListener('input', debouncedUpdateVariableInputs);
                },
                
                // 防抖函数
                debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                },
                
                setupPasteHandler() {
                const { pasteBtn, expressionInput } = App.elements;
                
                pasteBtn.addEventListener('click', async () => {
                    try {
                        if (navigator.clipboard && navigator.clipboard.readText) {
                            const pastedText = await navigator.clipboard.readText();
                            if (pastedText) {
                                expressionInput.value = pastedText;
                                if (App.elements.operationSelect.value === 'evaluate') {
                                    this.updateVariableInputs();
                                }
                                this.showSuccessMessage('内容已粘贴！');
                                return;
                            }
                        }
                        
                        const tempTextarea = document.createElement('textarea');
                        tempTextarea.style.position = 'fixed';
                        tempTextarea.style.left = '0';
                        tempTextarea.style.top = '0';
                        tempTextarea.style.opacity = '0';
                        document.body.appendChild(tempTextarea);
                        tempTextarea.focus();
                        
                        setTimeout(() => {
                            if (tempTextarea.value) {
                                expressionInput.value = tempTextarea.value;
                                if (App.elements.operationSelect.value === 'evaluate') {
                                    this.updateVariableInputs();
                                }
                                this.showSuccessMessage('内容已粘贴！');
                            } else {
                                this.showSuccessMessage('请手动在输入框中粘贴内容 (Ctrl+V)');
                                expressionInput.focus();
                            }
                            document.body.removeChild(tempTextarea);
                        }, 100);
                        
                    } catch (error) {
                        this.showSuccessMessage('请手动在输入框中粘贴内容 (Ctrl+V)');
                        expressionInput.focus();
                    }
                });
            },
            
            handleOperationChange() {
                const { operationSelect, nthDerivativeGroup, definiteIntegralGroup, doubleIntegralGroup, 
                        doubleDefiniteIntegralGroup, nDefiniteIntegralGroup, evaluationInputs } = App.elements;
                
                // 先隐藏所有特殊输入组
                nthDerivativeGroup.style.display = 'none';
                definiteIntegralGroup.style.display = 'none';
                doubleIntegralGroup.style.display = 'none';
                doubleDefiniteIntegralGroup.style.display = 'none';
                nDefiniteIntegralGroup.style.display = 'none';
                evaluationInputs.style.display = 'none';
                
                // 根据选择显示对应的输入组
                if (operationSelect.value === 'nth_derivative') {
                    nthDerivativeGroup.style.display = 'block';
                } else if (operationSelect.value === 'definite_integral') {
                    definiteIntegralGroup.style.display = 'block';
                } else if (operationSelect.value === 'double_integral') {
                    doubleIntegralGroup.style.display = 'block';
                } else if (operationSelect.value === 'double_definite_integral') {
                    doubleDefiniteIntegralGroup.style.display = 'block';
                } else if (operationSelect.value === 'n_definite_integral') {
                    nDefiniteIntegralGroup.style.display = 'block';
                    // 当选择n重定积分时，自动更新变量列表
                    this.updateNDefiniteIntegralVariables();
                } else if (operationSelect.value === 'evaluate') {
                    evaluationInputs.style.display = 'block';
                    this.updateVariableInputs();
                }
            },
            
            updateVariableInputs() {
                const { expressionInput, variableInputs } = App.elements;
                const expression = expressionInput.value.trim();
                
                if (!expression) {
                    variableInputs.innerHTML = '';
                    return;
                }
                
                const cacheKey = `variables_${expression}`;
                //cache App
                const cachedHTML = App.cache.get(cacheKey);
                if (App.cache.has(cacheKey)) {
                    variableInputs.innerHTML = App.cache.get(cacheKey);
                    return;
                }
                if (cachedHTML) {
                        variableInputs.innerHTML = cachedHTML;
                        return;
                    }
                
                try {
                    const node = math.parse(expression);
                    const variables = this.extractVariables(node);
                    
                    let html = '';
                    variables.forEach(variable => {
                        html += `
                            <div>
                                <label for="var-${variable}">${variable} = </label>
                                <input type="number" id="var-${variable}" value="1" step="any">
                            </div>
                        `;
                    });
                    
                    variableInputs.innerHTML = html;
                    App.cache.set(cacheKey, html);
                    
                } catch (error) {
                    variableInputs.innerHTML = '<p style="color: #e74c3c;">无法解析表达式</p>';
                }
            },
            
            // 新增：自动更新n重积分的变量列表
            updateNDefiniteIntegralVariables() {
                const { expressionInput, nVariablesInput } = App.elements;
                const expression = expressionInput.value.trim();
                
                if (!expression) {
                    nVariablesInput.value = 'x';
                    return;
                }
                
                try {
                    // 自动检测表达式中的变量
                    const detectedVars = this.detectVariables(expression);
                    
                    // 如果没有检测到变量，使用默认变量x
                    const variables = detectedVars.length > 0 ? detectedVars : ['x'];
                    
                    // 更新变量列表
                    nVariablesInput.value = variables.join(',');
                    
                    // 更新积分阶数显示
                    const integralOrderDisplay = document.querySelector('#n-definite-integral-group .fa-layer-group').nextSibling;
                    if (integralOrderDisplay) {
                        integralOrderDisplay.textContent = ` n重定积分设置 (当前: ${variables.length}重, 自动检测变量: ${variables.join(', ')})`;
                    }
                    
                    // 自动调整积分区间数量以匹配变量数量
                    const currentLimits = App.elements.nLimitsInput.value.trim().split(';').map(limit => {
                        const [lower, upper] = limit.split(',').map(v => v.trim());
                        return { lower, upper };
                    });
                    
                    // 如果区间数量不足，使用默认区间[0,1]补充
                    if (currentLimits.length < variables.length) {
                        let newLimits = currentLimits.map(l => `${l.lower},${l.upper}`).join(';');
                        for (let i = currentLimits.length; i < variables.length; i++) {
                            newLimits += (newLimits ? ';' : '') + '0,1';
                        }
                        App.elements.nLimitsInput.value = newLimits;
                    }
                    // 区间数量多于变量数量时，保持不变，正常计算即可
                    
                } catch (error) {
                    console.error('变量检测失败:', error);
                    nVariablesInput.value = 'x';
                }
            },
            
            extractVariables(node) {
                const variables = new Set();
                
                const traverse = (node) => {
                    if (node.type === 'SymbolNode') {
                        if (!['pi', 'e', 'i'].includes(node.name)) {
                            variables.add(node.name);
                        }
                    } else if (node.type === 'FunctionNode') {
                        node.args.forEach(traverse);
                    } else if (node.type === 'OperatorNode') {
                        node.args.forEach(traverse);
                    } else if (node.type === 'ParenthesisNode') {
                        traverse(node.content);
                    }
                };
                
                traverse(node);
                return Array.from(variables);
            },
            
            handleCalculate() {
                const { expressionInput, operationSelect, variableInput, nthOrderInput, lowerLimitInput, upperLimitInput, 
                        variable2Input, variable2DefiniteInput, xLowerInput, xUpperInput, yLowerInput, yUpperInput, 
                        outputDiv, stepsDiv } = App.elements;
                const expression = expressionInput.value.trim();
                const operation = operationSelect.value;
                const variable = variableInput.value.trim() || 'x';
                const nthOrder = nthOrderInput.value;
                
                // 获取定积分的上下限
                const lowerLimit = lowerLimitInput ? lowerLimitInput.value.trim() : '';
                const upperLimit = upperLimitInput ? upperLimitInput.value.trim() : '';
                
                // 获取二重积分的参数
                const var2 = variable2Input ? variable2Input.value.trim() : '';
                const var2Def = variable2DefiniteInput ? variable2DefiniteInput.value.trim() : '';
                const xLower = xLowerInput ? xLowerInput.value.trim() : '';
                const xUpper = xUpperInput ? xUpperInput.value.trim() : '';
                const yLower = yLowerInput ? yLowerInput.value.trim() : '';
                const yUpper = yUpperInput ? yUpperInput.value.trim() : '';
                
                // 获取n重定积分的参数
                const nVariables = App.elements.nVariablesInput ? App.elements.nVariablesInput.value.trim() : '';
                const nLimits = App.elements.nLimitsInput ? App.elements.nLimitsInput.value.trim() : '';
                const nSamples = App.elements.nSamplesInput ? App.elements.nSamplesInput.value : '';
                
                // 调试信息
                console.log('=== handleCalculate 调试信息 ===');
                console.log('nSamples值:', nSamples);
                console.log('nSamples类型:', typeof nSamples);
                
                if (!expression) {
                    alert('请输入数学表达式！');
                    return;
                }
                
                stepsDiv.innerHTML = '';
                outputDiv.innerHTML = '';
                
                try {
                    // 缓存键包含所有相关参数(包括n重积分的采样数)
                    const cacheKey = `${operation}_${expression}_${variable}_${nthOrder}_${lowerLimit}_${upperLimit}_${var2}_${var2Def}_${xLower}_${xUpper}_${yLower}_${yUpper}_${nVariables}_${nLimits}_${nSamples}`;
                    console.log('缓存键:', cacheKey);
                    console.log('缓存中是否存在:', App.cache.has(cacheKey));
                    if (App.cache.has(cacheKey)) {
                        console.log('使用缓存结果');
                        this.displayResult(App.cache.get(cacheKey));
                        return;
                    }
                    console.log('计算新结果');
                    
                    const processedExpression = this.preprocessExpression(expression);
                    
                    // 检查是否是n重定积分，如果是则使用异步处理
                    if (operation === 'n_definite_integral') {
                        // 自动检测表达式中的变量，而不是使用用户输入的变量列表
                        const detectedVars = this.detectVariables(expression);
                        
                        // 如果没有检测到变量，使用默认变量x
                        const nVariables = detectedVars.length > 0 ? detectedVars : ['x'];
                        
                        // 获取用户输入的积分区间
                        const nLimits = App.elements.nLimitsInput.value.trim().split(';').map(limit => {
                            const [lower, upper] = limit.split(',').map(v => v.trim());
                            return { lower, upper };
                        });
                        
                        // 如果用户输入的区间数量与检测到的变量数量不匹配，调整区间数量
                        if (nLimits.length < nVariables.length) {
                            // 如果区间数量不足，使用默认区间[0,1]补充
                            while (nLimits.length < nVariables.length) {
                                nLimits.push({ lower: '0', upper: '1' });
                            }
                        }
                        // 区间数量多于变量数量时，保持不变，正常计算即可
                        
                        const userSamples = parseInt(nSamples) || 10000000;
                        const nDefiniteResult = this.calculateNDefiniteIntegral(expression, nVariables, nLimits, userSamples);
                        
                        // 检查结果是否是Promise（大于5维的情况）
                        if (nDefiniteResult && typeof nDefiniteResult.then === 'function') {
                            // 异步处理
                            App.elements.calculateBtn.disabled = true;
                            App.elements.calculateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 计算中...';
                            
                            nDefiniteResult.then(result => {
                                result.originalExpression = expression; // 保存原始表达式
                                result.displayExpression = this.formatOriginalExpression(expression); // 保存用于显示的原始表达式
                                App.cache.set(cacheKey, result);
                                this.displayResult(result);
                                
                                // 恢复计算按钮
                                App.elements.calculateBtn.disabled = false;
                                App.elements.calculateBtn.innerHTML = '<i class="fas fa-calculator"></i> 计算';
                            }).catch(error => {
                                // 检查是否是取消计算的错误
                                if (error.message === '计算已由用户取消') {
                                    App.elements.outputDiv.innerHTML = `
                                        <div class="error">
                                            <strong>计算已取消</strong> 用户取消了计算过程
                                        </div>
                                    `;
                                } else {
                                    this.displayError(error.message || '计算失败', expression);
                                }
                                
                                // 恢复计算按钮
                                App.elements.calculateBtn.disabled = false;
                                App.elements.calculateBtn.innerHTML = '<i class="fas fa-calculator"></i> 计算';
                            });
                        } else {
                            // 同步处理（5维及以下）
                            result = nDefiniteResult;
                            result.originalExpression = expression; // 保存原始表达式
                            result.displayExpression = this.formatOriginalExpression(expression); // 保存用于显示的原始表达式
                            App.cache.set(cacheKey, result);
                            this.displayResult(result);
                        }
                    } else {
                        // 非n重定积分，使用同步计算
                        const result = this.calculate(processedExpression, operation, variable, nthOrder, nSamples);
                        result.originalExpression = expression; // 保存原始表达式
                        result.displayExpression = this.formatOriginalExpression(expression); // 保存用于显示的原始表达式
                        App.cache.set(cacheKey, result);
                        this.displayResult(result);
                    }
                    
                } catch (error) {
                    this.displayError(error.message, expression);
                }
            },
            
            // 预处理表达式 - 增强了对数无括号支持和 logN(v) 转换
            preprocessExpression(expr) {
                let processed = expr;
                
                // 1. 处理√符号
                processed = processed.replace(/√\s*\(([^)]+)\)/g, 'sqrt($1)');
                processed = processed.replace(/√\s*([a-zA-Z0-9.]+)/g, 'sqrt($1)');
                
                // 2. 处理角度符号 - 保留原始形式用于显示
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d*\.?\d+)\s*°\s*\)/g, '$1($2*pi/180)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d*\.?\d+)\s*°/g, '$1($2*pi/180)');
                
                // 3. 关键修复：处理三角函数中单个π或e的情况 - 保留原始形式
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*π\s*\)/g, '$1(3.141592653589793)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*e\s*\)/g, '$1(2.718281828459045)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*pi\s*\)/g, '$1(3.141592653589793)');
                
                // 4. 处理其他π表达式 - 增强支持更多格式
                // 4.1 处理带括号的π表达式
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d*\.?\d*)\s*\*\s*π\s*\)/g, '$1($2*3.141592653589793)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d*\.?\d*)\s*π\s*\)/g, '$1($2*3.141592653589793)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*π\s*\/\s*(\d+)\s*\)/g, '$1(3.141592653589793/$2)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d+)\s*\*\s*π\s*\/\s*(\d+)\s*\)/g, '$1($2*3.141592653589793/$3)');
                
                // 4.2 处理不带括号的π表达式 (如 sin2π, cos3π)
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d*\.?\d*)π/g, (match, func, num) => {
                    const number = num === '' || num === '-' ? '1' : num;
                    const sign = num.startsWith('-') ? '-' : '';
                    return `${func}(${sign}${number.replace('-', '')}*3.141592653589793)`;
                });
                
                // 4.3 处理更复杂的π表达式 (如 sin(2π/3), cos(3π/2))
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d+)\s*π\s*\/\s*(\d+)\s*\)/g, '$1($2*3.141592653589793/$3)');
                
                // 4.4 处理π在分子的情况 (如 sin(π/2), cos(π/3))
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*π\s*\/\s*(\d+)\s*\)/g, '$1(3.141592653589793/$2)');
                
                // 4.5 处理π的分数形式 (如 sin(π/6), cos(π/4))
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*π\s*\/\s*(\d+)\s*\)/g, '$1(3.141592653589793/$2)');
                
                // 5. 处理一般数字参数
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d*\.?\d+)(?![a-zA-Z0-9.(])/g, '$1($2)');
                
                // 6. 处理反三角函数
                processed = processed.replace(/arc(sin|cos|tan|cot|sec|csc)/g, 'a$1');
                
                // 7. 关键修复：先处理 log(底数)(真数) 格式，避免与其他格式冲突
                // 匹配 log(底数)(真数) 格式，支持各种底数形式
                // 例如：log(3.14)(3.14), log(1/2)(π), log(e)(π*e)
                // 使用更严格的匹配，确保括号正确匹配
                processed = processed.replace(/\blog\s*\(\s*([^()]+)\s*\)\s*\(\s*([^()]+)\s*\)/g, 'log($2, $1)');
                
                // 7.5. 增强: 任意底对数支持 logN(v) -> log(v, N)
                // 匹配 log 紧跟一个或多个数字 (底数)，然后是括号内的参数 (值)
                // 修复：支持log和数字之间有空格的情况
                processed = processed.replace(/\blog([0-9]+)\s*\(([^)]+)\)/g, 'log($2, $1)');
                processed = processed.replace(/\blog\s+([0-9]+)\s*\(([^)]+)\)/g, 'log($2, $1)');

                // 8. 增强的对数无括号支持 (仅对 ln, lg)
                processed = this.processLogarithmWithoutParentheses(processed);
                
                // 8.5. 新增：处理三角函数无括号情况 (如 sinx, cosi, tan30°)
                processed = this.processTrigonometricWithoutParentheses(processed);
                
                // 9. 将 ln(x) 替换为 math.js 的 log(x) (自然对数)
                processed = processed.replace(/ln\(/g, 'log('); 
                
                // 10. 将 lg(x) 替换为 math.js 的 log10(x) (以10为底)
                processed = processed.replace(/lg\(/g, 'log10('); 
                
                // 11. 新增：处理÷符号为除法
                processed = processed.replace(/÷/g, '/');
                
                // 12. 新增：处理表达式化简中的X乘法（仅在化简模式）
                if (App.elements.operationSelect.value === 'simplify') {
                    processed = this.processXMultiplication(processed);
                }
                
                // 13. 处理π符号为pi
                // 调试信息
                console.log('=== 预处理表达式调试 ===');
                console.log('处理π符号前:', processed);
                processed = processed.replace(/π/g, 'pi');
                console.log('处理π符号后:', processed);
                
                // 14. 修复虚数处理 - 移除之前的处理，让math.js自然处理
                // 不再进行i^2=-1的预转换，让math.js自然处理
                
                console.log('最终预处理结果:', processed);
                return processed;
            },
            
            // 新增：处理X乘法 (仅在表达式化简模式) - 修复为只有x和X代表乘法，排除exp(x)等函数
            processXMultiplication(expr) {
                // 在表达式化简中，只要x和X的前后不是运算符，都应该把x看成乘法
                // 例如：ln(x)x5 应该变成 ln(x)*5
                // 例如：3x2 应该变成 3*2
                // 例如：xsin(x) 应该变成 *sin(x)（如果x在开头）
                // 例如：ln(x)x 6 应该变成 ln(x)*6
                // 排除：exp(x) 不应该被处理为 e*p(x)
                
                let processed = expr;
                
                // 先保护函数名，避免被误处理
                const functionNames = ['exp', 'sin', 'cos', 'tan', 'cot', 'sec', 'csc', 'asin', 'acos', 'atan', 'acot', 'asec', 'acsc', 
                                     'sinh', 'cosh', 'tanh', 'asinh', 'acosh', 'atanh', 'log', 'ln', 'lg', 'sqrt', 'abs', 'factorial', 'gamma'];
                
                // 创建函数名保护的正则表达式
                const functionNamePattern = new RegExp(`\\b(${functionNames.join('|')})\\b`, 'g');
                
                // 使用占位符保护函数名
                const functionPlaceholders = [];
                let placeholderIndex = 0;
                processed = processed.replace(functionNamePattern, (match) => {
                    const placeholder = `__FUNC_PLACEHOLDER_${placeholderIndex++}__`;
                    functionPlaceholders.push(match);
                    return placeholder;
                });
                
                // 先移除x/X前后的多余空格，但保留必要的空格
                processed = processed.replace(/\s*([xX])\s*/g, '$1');
                
                // 处理各种x/X乘法情况
                
                // 1. 数字后跟x/X再跟数字: 3x2 -> 3*2
                processed = processed.replace(/(\d+)([xX])(\d+)/g, (match, num1, letter, num2) => {
                    return `${num1}*${num2}`;
                });
                
                // 2. 数字后跟x/X再跟字母/函数: 3xsin(x) -> 3*sin(x)
                processed = processed.replace(/(\d+)([xX])([a-zA-Z])/g, (match, num1, letter, nextChar) => {
                    return `${num1}*${nextChar}`;
                });
                
                // 3. 字母/变量/函数后跟x/X再跟数字: sin(x)x5 -> sin(x)*5
                processed = processed.replace(/([a-zA-Z\)\]}])([xX])(\d+)/g, (match, prevChar, letter, num2) => {
                    return `${prevChar}*${num2}`;
                });
                
                // 4. 字母/变量/函数后跟x/X再跟字母/函数: sin(x)xcos(x) -> sin(x)*cos(x)
                processed = processed.replace(/([a-zA-Z\)\]}])([xX])([a-zA-Z\(])/g, (match, prevChar, letter, nextChar) => {
                    return `${prevChar}*${nextChar}`;
                });
                
                // 5. 处理开头的x/X: x5 -> *5, xsin(x) -> *sin(x)
                processed = processed.replace(/^([xX])(\d+)/g, (match, letter, num2) => {
                    return `*${num2}`;
                });
                processed = processed.replace(/^([xX])([a-zA-Z\(])/g, (match, letter, nextChar) => {
                    return `*${nextChar}`;
                });
                
                // 6. 处理运算符后的x/X: +x5 -> +*5, -xsin(x) -> -*-sin(x)
                processed = processed.replace(/([+\-*/÷^=,!\s\[\{])([xX])(\d+)/g, (match, op, letter, num2) => {
                    return `${op}*${num2}`;
                });
                processed = processed.replace(/([+\-*/÷^=,!\s\[\{])([xX])([a-zA-Z\(])/g, (match, op, letter, nextChar) => {
                    return `${op}*${nextChar}`;
                });
                
                // 7. 处理括号后的x/X: )x5 -> )*5
                processed = processed.replace(/(\))([xX])(\d+)/g, (match, paren, letter, num2) => {
                    return `${paren}*${num2}`;
                });
                processed = processed.replace(/(\))([xX])([a-zA-Z\(])/g, (match, paren, letter, nextChar) => {
                    return `${paren}*${nextChar}`;
                });
                
                // 恢复函数名
                for (let i = 0; i < functionPlaceholders.length; i++) {
                    processed = processed.replace(`__FUNC_PLACEHOLDER_${i}__`, functionPlaceholders[i]);
                }
                
                return processed;
            },
            
            // 新增：预处理表达式用于显示（包含X乘法处理）
            preprocessExpressionForDisplay(expr) {
                let processed = expr;
                
                // 处理X乘法，用于显示
                processed = processed.replace(/(\d+)([xX])(\d+)/g, (match, num1, letter, num2) => {
                    // 将 3x2 转换为 3*2 用于显示，而不是 3*x*2
                    return `${num1}*${num2}`;
                });
                
                return processed;
            },
            
            // 增强的对数无括号支持处理 (已移除 log2)
            processLogarithmWithoutParentheses(expr) {
                let processed = expr;
                
                // 处理 ln, lg 后紧跟数字、e、pi 或它们的组合
                const logPatterns = [
                    { regex: /(ln|lg)\s*(-?[0-9]+(?:\.[0-9]+)?)(?=\W|$)/g, handler: this.processSimpleNumberLog },
                    { regex: /(ln|lg)\s*([a-zA-Z\u03c0]+)(?=\W|$)/g, handler: this.processSimpleSymbolLog },
                    { regex: /(ln|lg)\s*(-?[0-9]+(?:\.[0-9]+)?[a-zA-Z\u03c0]+)(?=\W|$)/g, handler: this.processNumberSymbolLog },
                    { regex: /(ln|lg)\s*([a-zA-Z\u03c0]+-?[0-9]+(?:\.[0-9]+)?)(?=\W|$)/g, handler: this.processSymbolNumberLog },
                    { regex: /(ln|lg)\s*(-?[0-9]+(?:\.[0-9]+)?[a-zA-Z\u03c0]+-?[0-9]*(?:\.[0-9]+)?)(?=\W|$)/g, handler: this.processComplexLog },
                    // 新增：处理带括号的负数 ln(-e), lg(-3) 等
                    { regex: /(ln|lg)\s*\(\s*(-[0-9]+(?:\.[0-9]+)?)\s*\)/g, handler: this.processNegativeNumberLog },
                    { regex: /(ln|lg)\s*\(\s*(-[a-zA-Z\u03c0]+)\s*\)/g, handler: this.processNegativeSymbolLog }
                ];
                
                logPatterns.forEach(pattern => {
                    processed = processed.replace(pattern.regex, (match, func, arg) => {
                        return pattern.handler.call(this, func, arg);
                    });
                });
                
                // 处理 logN 无括号的情况 (例如 log39 -> log3(9))
                // 注意: 这必须在 logN(...) 转换之后执行
                const logNDigitPattern = /\blog([0-9]+)\s*(-?[0-9]+)(?=\W|$)/g;
                processed = processed.replace(logNDigitPattern, (match, base, arg) => {
                    return `log${base}(${arg})`;
                });

                return processed;
            },
            
            processSimpleNumberLog(func, arg) {
                // 处理 ln100, lg1000 等
                return `${func}(${arg})`;
            },
            
            processSimpleSymbolLog(func, arg) {
                // 处理 lne, lnπ, lge, lni 等
                let processedArg = arg;
                if (arg === 'π') processedArg = 'pi';
                // 保持i不变，math.js会自动处理
                return `${func}(${processedArg})`;
            },
            
            processNumberSymbolLog(func, arg) {
                // 处理 ln2e, lg10π 等
                let processedArg = arg.replace(/([0-9\.]+)([a-zA-Z\u03c0])/g, '$1*$2');
                processedArg = processedArg.replace(/π/g, 'pi');
                return `${func}(${processedArg})`;
            },
            
            processSymbolNumberLog(func, arg) {
                // 处理 lne2, lnπ3 等
                let processedArg = arg.replace(/([a-zA-Z\u03c0])([0-9\.]+)/g, '$1*$2');
                processedArg = processedArg.replace(/π/g, 'pi');
                return `${func}(${processedArg})`;
            },
            
            processComplexLog(func, arg) {
                // 处理更复杂的组合 ln2e3π, lg10π2 等
                let processedArg = arg
                    .replace(/(-?[0-9\.]+)([a-zA-Z\u03c0])/g, '$1*$2')
                    .replace(/([a-zA-Z\u03c0])(-?[0-9\.]+)/g, '$1*$2')
                    .replace(/([e\u03c0])([e\u03c0])/g, '$1*$2');
                processedArg = processedArg.replace(/π/g, 'pi');
                return `${func}(${processedArg})`;
            },
            
            // 新增：处理带负号的数字 ln(-3), lg(-2.5) 等
            processNegativeNumberLog(func, arg) {
                // 直接使用负数作为参数
                return `${func}(${arg})`;
            },
            
            // 新增：处理带负号的符号 ln(-e), lg(-π) 等
            processNegativeSymbolLog(func, arg) {
                let processedArg = arg;
                if (arg === '-π') processedArg = '-pi';
                // 保持-i不变，math.js会自动处理
                return `${func}(${processedArg})`;
            },
            
            // 新增：处理三角函数无括号情况 (如 sinx, cosi, tan30°)
            processTrigonometricWithoutParentheses(expr) {
                // 调试信息
                console.log('=== processTrigonometricWithoutParentheses 函数调试 ===');
                console.log('输入表达式:', expr);
                
                let processed = expr;
                
                // 处理三角函数后紧跟数字、变量、e、pi 或它们的组合
                const trigPatterns = [
                    // 处理 sinx, cosi, tanx 等简单情况（包括负数）
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*([a-zA-Z\u03c0])(?=\W|$)/g, handler: this.processSimpleTrig },
                    // 处理 sin30°, cos45°, tan60° 等角度情况（包括负数）
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d+\.?\d*)\s*°/g, handler: this.processTrigWithDegrees },
                    // 处理 sin30, cos45, tan60 等数字情况（默认为弧度，包括负数）
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d+\.?\d*)(?=\W|$)/g, handler: this.processTrigWithRadians },
                    // 处理 sin2x, cos3y, tan4z 等数字变量组合（包括负数）
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d+\.?\d*)([a-zA-Z\u03c0])/g, handler: this.processTrigNumberVariable },
                    // 处理 sin2π, cos3π 等数字π组合（包括负数）
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d+\.?\d*)π/g, handler: this.processTrigNumberPi },
                    // 新增：处理 sin(-x), cos(-i) 等带负号的变量
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*-([a-zA-Z\u03c0])\s*\)/g, handler: this.processNegativeVariableTrig },
                    // 新增：处理 sin(-30°), cos(-45°) 等带负号的角度
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d+\.?\d+)\s*°\s*\)/g, handler: this.processNegativeDegreeTrig },
                    // 新增：处理 sin(-30), cos(-45) 等带负号的弧度
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d+\.?\d+)\s*\)/g, handler: this.processNegativeRadianTrig }
                ];
                
                trigPatterns.forEach(pattern => {
                    const beforeReplace = processed;
                    processed = processed.replace(pattern.regex, (match, func, ...args) => {
                        console.log('匹配到模式:', pattern.regex);
                        console.log('匹配内容:', match);
                        console.log('函数名:', func);
                        console.log('参数:', args);
                        
                        const result = pattern.handler.call(this, func, ...args);
                        console.log('处理结果:', result);
                        return result;
                    });
                    
                    if (beforeReplace !== processed) {
                        console.log('表达式已改变:', beforeReplace, '->', processed);
                    }
                });

                console.log('最终处理结果:', processed);
                return processed;
            },
            
            // 处理简单三角函数 sinx, cosi 等
            processSimpleTrig(func, arg) {
                // 调试信息
                console.log('=== processSimpleTrig 函数调试 ===');
                console.log('函数名:', func);
                console.log('参数:', arg);
                
                // 处理特殊情况：sinx -> sin(x), cosi -> cos(i)
                let processedArg = arg;
                if (arg === 'π') processedArg = 'pi';
                // 保持i不变，math.js会自动处理
                
                const result = `${func}(${processedArg})`;
                console.log('处理结果:', result);
                return result;
            },
            
            // 处理带角度的三角函数 sin30°, cos45° 等
            processTrigWithDegrees(func, arg) {
                // 将角度转换为弧度：30° -> 30*pi/180
                return `${func}(${arg}*pi/180)`;
            },
            
            // 处理带弧度数字的三角函数 sin30, cos45 等
            processTrigWithRadians(func, arg) {
                // 直接使用数字作为弧度值
                return `${func}(${arg})`;
            },
            
            // 处理数字变量组合 sin2x, cos3y 等
            processTrigNumberVariable(func, num, variable) {
                // 将 sin2x 转换为 sin(2*x)
                let processedVariable = variable;
                if (variable === 'π') processedVariable = 'pi';
                return `${func}(${num}*${processedVariable})`;
            },
            
            // 处理数字π组合 sin2π, cos3π 等
            processTrigNumberPi(func, num) {
                // 将 sin2π 转换为 sin(2*pi)
                return `${func}(${num}*pi)`;
            },
            
            // 新增：处理带负号的变量 sin(-x), cos(-i) 等
            processNegativeVariableTrig(func, variable) {
                let processedVariable = variable;
                if (variable === 'π') processedVariable = 'pi';
                // 保持i不变，math.js会自动处理
                return `${func}(-${processedVariable})`;
            },
            
            // 新增：处理带负号的角度 sin(-30°), cos(-45°) 等
            processNegativeDegreeTrig(func, degrees) {
                // 将 sin(-30°) 转换为 sin(-30*pi/180)
                return `${func}(${degrees}*pi/180)`;
            },
            
            // 新增：处理带负号的弧度 sin(-30), cos(-45) 等
            processNegativeRadianTrig(func, radians) {
                // 直接使用负数作为弧度值
                return `${func}(${radians})`;
            },

            // 检查无穷大情况 (用于求导/积分)
            checkForInfinity(expr, operation, variable) {
                if (operation === 'simplify' || operation === 'evaluate') {
                    // For simplify/evaluate, we use the granular getInfiniteTerms method
                    return { isInfinity: false };
                }
                
                const infinityPatterns = [
                    { pattern: /(tan|sec|atan|asec)\s*\(\s*3\.141592653589793\s*\/\s*2\s*\)/, message: '函数在π/2处为无穷大' },
                    { pattern: /(tan|sec|atan|asec)\s*\(\s*90\s*\*\s*3\.141592653589793\s*\/\s*180\s*\)/, message: '函数在90°处为无穷大' },
                    { pattern: /(tan|sec|atan|asec)\s*\(\s*270\s*\*\s*3\.141592653589793\s*\/\s*180\s*\)/, message: '函数在270°处为无穷大' },
                    { pattern: /(cot|csc|acot|acsc)\s*\(\s*0\s*\)/, message: '函数在0处为无穷大' },
                    { pattern: /(cot|csc|acot|acsc)\s*\(\s*3\.141592653589793\s*\)/, message: '函数在π处为无穷大' },
                    // Log(0) check
                    { pattern: /log\s*\(\s*0\s*\)/, message: 'ln(0) 为无穷大' },
                    { pattern: /log10\s*\(\s*0\s*\)/, message: 'lg(0) 为无穷大' },
                ];
                
                for (const { pattern, message } of infinityPatterns) {
                    if (pattern.test(expr)) {
                        return { isInfinity: true, message };
                    }
                }
                
                return { isInfinity: false };
            },

            // 检查无穷大项 (用于化简/求值，提取出项)
            getInfiniteTerms(expr, varName) {
                const tolerance = this.tolerance;
                let scope = { [varName]: 1, pi: math.pi, e: math.e, i: math.i }; // 新增：支持虚数单位
                
                // For evaluation mode, use the assigned variable values
                if (App.elements.operationSelect.value === 'evaluate') {
                    App.elements.variableInputs.querySelectorAll('input').forEach(input => {
                        const vName = input.id.replace('var-', '');
                        scope[vName] = parseFloat(input.value) || 0;
                    });
                }
                
                const allTerms = [];
                try {
                    this.extractTerms(math.parse(expr), allTerms);
                } catch (e) {
                    // Cannot parse, return all as finite (or let the main calc fail)
                    return { finiteTerms: allTerms, infiniteTerms: [] };
                }

                let finiteTerms = [];
                let infiniteTerms = [];
                
                allTerms.forEach(term => {
                    const termStr = term.node.toString();
                    let isInfinite = false;
                    let infinitySign = 1; // 1 for positive infinity, -1 for negative infinity

                    // 1. Logarithmic check (ln(x) where x <= 0 or 1/ln(x) where x=1)
                    // 匹配 log(x) 或 log(v, N)
                    const logPattern = /log\(([^)]+)\)/g; 
                    let match;
                    let tempStr = termStr;
                    while ((match = logPattern.exec(tempStr)) !== null) {
                        const arg = match[1];
                        
                        let base = 'e';
                        let value = arg;

                        // 检查是否是 log(v, N) 形式
                        if (arg.includes(',')) {
                            const parts = arg.split(',').map(s => s.trim());
                            value = parts[0];
                            base = parts[1];
                        }
                        
                        try {
                            const argValue = math.evaluate(value, scope);
                            const baseValue = math.evaluate(base, scope);
                            
                            // 修改：对于 log(负数) 或 log(底数为负数) 或 log(底数为1)，改为NaN而不是无穷大
                            if (argValue < 0) { // 真数为负数
                                isInfinite = true;
                                infinitySign = 'NaN'; // 标记为NaN
                                break;
                            }
                            
                            if (argValue === 0) { // 真数为0，保持原来的负无穷大处理
                                isInfinite = true;
                                infinitySign = -1;
                                break;
                            }
                            
                            // 检查底数是否为 1 或负数
                            if (baseValue === 1) {
                                isInfinite = true;
                                infinitySign = 'NaN'; // 标记为NaN
                                break;
                            }
                            
                            if (baseValue < 0) { // 底数为负数
                                isInfinite = true;
                                infinitySign = 'NaN'; // 标记为NaN
                                break;
                            }
                        } catch (e) {
                            // If it contains the variable and evaluation fails, assume it might be problematic
                            if (value.includes(varName)) isInfinite = true;
                        }
                    }
                    
                    // 2. Trigonometric singularities (tan(pi/2), cot(0) etc.)
                    // 首先检查特殊情况
                    if (termStr.includes('cot(0)') || termStr.includes('csc(0)')) {
                        isInfinite = true;
                    }
                    // 检查 tan(pi/2) 和 sec(pi/2)
                    else if (termStr.includes('tan(3.141592653589793/2)') || termStr.includes('tan(90*pi/180)') || 
                             termStr.includes('sec(3.141592653589793/2)') || termStr.includes('sec(90*pi/180)')) {
                        isInfinite = true;
                    }
                    // 检查 tan(-pi/2) 和 sec(-pi/2) - 修复：这些是负无穷大
                    else if (termStr.includes('tan(-3.141592653589793/2)') || termStr.includes('tan(-90*pi/180)') || 
                             termStr.includes('sec(-3.141592653589793/2)') || termStr.includes('sec(-90*pi/180)')) {
                        isInfinite = true;
                        infinitySign = -1; // 负无穷大
                    }
                    // 检查 tan(3pi/2) 和 sec(3pi/2) - 修复：这些是负无穷大
                    else if (termStr.includes('tan(3*3.141592653589793/2)') || termStr.includes('tan(270*pi/180)') || 
                             termStr.includes('sec(3*3.141592653589793/2)') || termStr.includes('sec(270*pi/180)')) {
                        isInfinite = true;
                        infinitySign = -1; // 负无穷大
                    }
                    // 检查 tan(-3pi/2) 和 sec(-3pi/2) - 修复：这些是正无穷大
                    else if (termStr.includes('tan(-3*3.141592653589793/2)') || termStr.includes('tan(-270*pi/180)') || 
                             termStr.includes('sec(-3*3.141592653589793/2)') || termStr.includes('sec(-270*pi/180)')) {
                        isInfinite = true;
                        // infinitySign = 1 (正无穷大，保持默认值)
                    }
                    // 一般三角函数检查
                    else {
                        const trigPattern = /(tan|cot|sec|csc)\(([^)]+)\)/g;
                        tempStr = termStr;
                        while ((match = trigPattern.exec(tempStr)) !== null) {
                            const func = match[1];
                            const arg = match[2];
                            try {
                                const argValue = math.evaluate(arg, { pi: math.pi });
                                const val = argValue / math.pi;
                                
                                if (func === 'tan' || func === 'sec') {
                                    // Singularities at (n + 1/2) * pi
                                    const n = Math.round(val - 0.5);
                                    if (Math.abs(val - (n + 0.5)) < tolerance) {
                                        isInfinite = true;
                                        // 确定无穷大的符号：tan和sec在奇数倍π/2处符号交替变化
                                        // tan(π/2) = +∞, tan(3π/2) = -∞, tan(5π/2) = +∞, ...
                                        // tan(-π/2) = -∞, tan(-3π/2) = +∞, tan(-5π/2) = -∞, ...
                                        if (n % 2 === 0) {
                                            // n为偶数时，如π/2, 5π/2, -3π/2等
                                            infinitySign = Math.sign(Math.cos(argValue)) > 0 ? 1 : -1;
                                        } else {
                                            // n为奇数时，如3π/2, 7π/2, -π/2等
                                            infinitySign = Math.sign(Math.cos(argValue)) > 0 ? -1 : 1;
                                        }
                                        break;
                                    }
                                }
                                if (func === 'cot' || func === 'csc') {
                                    // Singularities at n * pi
                                    const n = Math.round(val);
                                    if (Math.abs(val - n) < tolerance) {
                                        isInfinite = true;
                                        break;
                                    }
                                }
                            } catch (e) {
                                // Ignore
                            }
                        }
                    }

                    // 3. General 1/0 check
                    if (!isInfinite) {
                        try {
                            const evaluatedValue = math.evaluate(termStr, scope);
                            // 特殊处理：单个虚数i不是无穷大
                            if (termStr === 'i' || termStr === '-i') {
                                isInfinite = false;
                            } else if (!isFinite(evaluatedValue)) {
                                // 检查是否是虚数结果
                                if (evaluatedValue.toString().includes('i') || 
                                    (typeof evaluatedValue === 'object' && evaluatedValue !== null && 're' in evaluatedValue && 'im' in evaluatedValue)) {
                                    // 虚数不是无穷大
                                    isInfinite = false;
                                } else {
                                    // 修复：不覆盖原始符号，无穷大项的值不影响项前面的符号
                                    isInfinite = true;
                                }
                            }
                        } catch (e) {
                            // Ignore for now.
                        }
                    }

                    if (isInfinite) {
                        // Keep the original node, but format the display string
                        const displayStr = this.formatExpressionForDisplay(termStr.replace(/^\s*\+/, '').replace(/^\s*\-/, '-'));
                        // 修复：保留原始表达式中的符号，不受无穷大值的影响
                        const sign = term.sign || 1;
                        infiniteTerms.push({ display: displayStr, node: term.node, sign: sign, infinitySign: infinitySign });
                    } else {
                        finiteTerms.push(term);
                    }
                });
                
                return { finiteTerms, infiniteTerms };
            },

            // **修正 Issue 2 (丢失 +-号) 和 Issue 1 (多余 1) 的核心函数**
            reconstructExpression(terms) {
                if (terms.length === 0) return '0';
                
                // 1. 合并同类项
                const mergedTerms = this.mergeTerms(terms, App.elements.variableInput.value.trim() || 'x');
                
                let result = '';
                
                mergedTerms.forEach((term, index) => {
                    if (Math.abs(term.coefficient) < this.tolerance) return;

                    const isPositive = term.coefficient >= 0;
                    const absCoeff = Math.abs(term.coefficient);
                    
                    // 确定符号前缀
                    let signPrefix = '';
                    if (index > 0) {
                        signPrefix = isPositive ? ' + ' : ' - ';
                    } else if (!isPositive) {
                        signPrefix = '-';
                    }
                    
                    let termStr = '';
                    
                    // 特殊处理：如果是数值常数项（在 mergeTerms 中被标记为 '_NUMERICAL_CONSTANT_'）
                    if (term.variablePart === '_NUMERICAL_CONSTANT_') {
                         termStr = this.formatCoefficient(absCoeff, true); // 强制格式化为数字
                    } 
                    // 常数项（符号常数或纯常数）
                    else if (term.variablePart === '') {
                        // 常数项: 获取系数的格式化结果（不带符号，符号由 signPrefix 或第一个项的负号处理）
                        termStr = this.formatCoefficient(absCoeff, true); 
                    } else {
                        // 变量项 / 符号常数项 (e, pi, i, sqrt(3)等)
                        const formattedCoeff = this.formatCoefficient(absCoeff); // Magnitude-only, returns '' for 1
                        
                        // **修正: 积分结果中常数项的系数为 1 时，不显示 1***
                        const isConstantIntegralTerm = App.elements.operationSelect.value === 'integral' && 
                        (term.variablePart.endsWith(App.elements.variableInput.value.trim() || 'x')) && 
                        Math.abs(absCoeff - 1) < this.tolerance;

                        if (isConstantIntegralTerm && formattedCoeff === '') {
                             // 检查是否是 x, 如果是，直接用 term.variablePart
                             if (term.variablePart === App.elements.variableInput.value.trim() || 'x') {
                                termStr = term.variablePart;
                             } else {
                                // 如果是 y*x 这样的，保留乘号
                                termStr = term.variablePart.replace(/^(.*)\*?x$/, '$1*x');
                             }
                        } else {
                            // 特殊处理虚数单位 i
                            if (term.variablePart === 'i') {
                                termStr = formattedCoeff === '' ? 'i' : `${formattedCoeff}i`;
                            } else {
                                termStr = formattedCoeff === '' ? term.variablePart : `${formattedCoeff}*${term.variablePart}`;
                            }
                        }
                    }

                    // 附加项
                    result += signPrefix + termStr;
                });
                
                // 最终清理
                result = result.replace(/\s+\-\s+/g, ' - ') // 规范化减法间距
                             .replace(/\s+\+\s+/g, ' + ') // 规范化加法间距
                             .replace(/^\s*\+\s*/, '') // 移除前导 '+ '
                             .replace(/^\s*/, ''); // 移除任何剩余的前导空格
                
                // 最终清理：移除任何多余的 1*，以防格式化失败
                result = result.replace(/\b1\*(e|pi|sqrt|log|lg|ln)/g, '$1');
                // 特殊处理：移除 1*i 中的 1
                result = result.replace(/\b1\*i/g, 'i');
                
                return result || '0';
            },

            // **修正 Issue 2 (丢失 +-号) 的核心函数**
            appendInfiniteTerms(finiteResult, infiniteTerms) {
                if (infiniteTerms.length === 0) {
                    return { expression: finiteResult, copyText: finiteResult };
                }

                // 对有限部分进行智能求值
                let displayResult = finiteResult;
                let copyText = displayResult;
                
                // 如果有限部分不为空，尝试进行智能求值
                if (displayResult.trim() !== '' && displayResult.trim() !== '0') {
                    console.log('=== appendInfiniteTerms 中的智能求值调试 ===');
                    console.log('有限部分输入:', displayResult);
                    const scope = { pi: math.pi, e: math.e, i: math.i };
                    displayResult = this.intelligentEvaluate(displayResult, scope);
                    console.log('智能求值结果:', displayResult);
                    copyText = displayResult;
                } else {
                    // 使用 cleanMathJSText 进行格式化
                    displayResult = this.cleanMathJSText(finiteResult);
                    copyText = displayResult;
                }
                
                // 移除有限部分的 '0'
                if (displayResult.trim() === '0' || displayResult.trim() === '') {
                    displayResult = '';
                    copyText = '';
                }

                // 按照用户要求处理无穷大项：原始表达式 = 有限计算结果-无穷大项+无穷大项【项1=±∞/NaN，项2=±∞/NaN，...】
                const infiniteTermsList = infiniteTerms.map((term, index) => {
                    // 获取原始表达式并格式化为显示形式
                    const originalTermStr = term.node.toString();
                    const displayTerm = this.formatOriginalExpressionForInfiniteTerm(originalTermStr);
                    
                    // 使用预先计算的infinitySign属性来判断无穷大的符号或NaN
                    let actualInfinityType;
                    
                    // 检查是否为NaN情况
                    if (term.infinitySign === 'NaN') {
                        actualInfinityType = 'NaN';
                    } else {
                        // 正常的无穷大处理
                        actualInfinityType = term.infinitySign === -1 ? '-∞' : '∞';
                    }
                    
                    // 如果没有infinitySign属性，则尝试计算
                    if (term.infinitySign === undefined) {
                        try {
                            const scope = { pi: math.pi, e: math.e, i: math.i };
                            const evaluatedValue = math.evaluate(originalTermStr, scope);
                            if (!isFinite(evaluatedValue) && evaluatedValue < 0) {
                                actualInfinityType = '-∞';
                            }
                        } catch (e) {
                            // 如果无法求值，使用特殊判断
                            if (originalTermStr.includes('log(0)') || originalTermStr.includes('ln(0)')) {
                                actualInfinityType = '-∞'; // ln(0) 是负无穷大
                            } else if (originalTermStr.includes('tan(90*pi/180)') || originalTermStr.includes('tan(3.141592653589793/2)')) {
                                actualInfinityType = '∞'; // tan(90°) 是正无穷大
                            } else if (originalTermStr.includes('tan(-90*pi/180)') || originalTermStr.includes('tan(-3.141592653589793/2)')) {
                                actualInfinityType = '-∞'; // tan(-90°) 是负无穷大
                            } else if (originalTermStr.includes('tan(270*pi/180)') || originalTermStr.includes('tan(3*3.141592653589793/2)')) {
                                actualInfinityType = '-∞'; // tan(270°) 是负无穷大
                            } else if (originalTermStr.includes('tan(-270*pi/180)') || originalTermStr.includes('tan(-3*3.141592653589793/2)')) {
                                actualInfinityType = '∞'; // tan(-270°) 是正无穷大
                            }
                        }
                    }
                    
                    // 确定符号前缀
                    let signPrefix = '';
                    if (index > 0) {
                        signPrefix = '，';
                    }
                    
                    // 使用新格式：项=±∞
                    return `${signPrefix}${displayTerm}=${actualInfinityType}`;
                });
                
                // 将所有无穷大项合并到一个列表中
                const infiniteTermsStr = infiniteTermsList.join('');
                
                // 构建带有无穷大项的表达式部分
                const infiniteExpressionPart = infiniteTerms.map(term => {
                    const originalTermStr = term.node.toString();
                    const displayTerm = this.formatOriginalExpressionForInfiniteTerm(originalTermStr);
                    // 修复：保留原始表达式中的符号，不受无穷大值的影响
                    const originalSign = term.sign || 1;
                    const signPrefix = originalSign === -1 ? '-' : '+';
                    return `${signPrefix}${displayTerm}`;
                }).join('');
                
                // 构建最终结果
                let finalResult;
                let finalCopyText;
                
                if (displayResult !== '') {
                    // 如果有有限部分，构建完整表达式
                    finalResult = `${displayResult}${infiniteExpressionPart}【${infiniteTermsStr}】`;
                    finalCopyText = `${copyText}${infiniteExpressionPart}【${infiniteTermsStr}】`;
                } else {
                    // 如果没有有限部分，只显示无穷大项
                    finalResult = `${infiniteExpressionPart}【${infiniteTermsStr}】`;
                    finalCopyText = `${infiniteExpressionPart}【${infiniteTermsStr}】`;
                }
                
                // 最终清理: 移除可能的前导符号和空格
                finalResult = finalResult.replace(/^\s*\+\s*/, '').replace(/^\s*\-\s*/, '-');
                finalCopyText = finalCopyText.replace(/^\s*\+\s*/, '').replace(/^\s*\-\s*/, '-');
                
                return { expression: finalResult, copyText: finalCopyText.replace(/\s+/g, ' ') };
            },
            
            // 新增：为无穷大项格式化原始表达式
            formatOriginalExpressionForInfiniteTerm(termStr) {
                // 特殊处理 tan(pi/2) 等无穷大项，保留原始形式
                let formatted = termStr;
                
                // 将 tan(3.141592653589793/2) 转换为 tan(π/2)
                formatted = formatted.replace(/(tan|cot|sec|csc|atan|acot|asec|acsc)\s*\(\s*3\.141592653589793\s*\/\s*2\s*\)/g, '$1(π/2)');
                
                // 将 tan(90*pi/180) 转换为 tan(90°)
                formatted = formatted.replace(/(tan|cot|sec|csc|atan|acot|asec|acsc)\s*\(\s*90\s*\*\s*pi\s*\/\s*180\s*\)/g, '$1(90°)');
                
                // 将 cot(0) 转换为 cot(0)
                formatted = formatted.replace(/(tan|cot|sec|csc|atan|acot|asec|acsc)\s*\(\s*0\s*\)/g, '$1(0)');
                
                // 将 log(0) 转换为 ln(0)
                formatted = formatted.replace(/log\s*\(\s*0\s*\)/g, 'ln(0)');
                
                // 将 log10(0) 转换为 lg(0)
                formatted = formatted.replace(/log10\s*\(\s*0\s*\)/g, 'lg(0)');
                
                // 处理对数函数，保留原始格式以便识别NaN情况
                // 将 log(a, b) 格式转换为 log_b(a)
                formatted = formatted.replace(/log\s*\(\s*([^,]+)\s*,\s*([^)]+)\s*\)/g, 'log<sub>$2</sub>($1)');
                
                // 修复：保留数字之间的乘法符号，移除其他情况下的乘号符号
                // 保留数字之间的乘法：3*2 -> 3*2
                // 移除函数和变量之间的乘法：sin(x)*y -> sin(x)y
                // 移除常数和变量之间的乘法：3*x -> 3x
                // 注意：这里不再移除所有乘号，而是只移除特定情况下的乘号
                formatted = formatted.replace(/([a-zA-Z\)\)])\*([a-zA-Z\(])/g, '$1$2'); // 函数/变量与函数/变量之间的乘号
                formatted = formatted.replace(/(\d)\*([a-zA-Z\(])/g, '$1$2'); // 数字与函数/变量之间的乘号
                formatted = formatted.replace(/([a-zA-Z\)\)])\*(\d)/g, '$1$2'); // 函数/变量与数字之间的乘号
                formatted = formatted.replace(/([a-zA-Z])\*(\d)/g, '$1$2'); // 单个变量与数字之间的乘号
                
                // 去除多余的空格
                formatted = formatted.replace(/\s+/g, ' '); // 将多个连续空格替换为单个空格
                formatted = formatted.replace(/\s*\(\s*/g, '('); // 去除括号前后的空格
                formatted = formatted.replace(/\s*\)\s*/g, ')'); // 去除右括号前后的空格
                formatted = formatted.replace(/\s*\+\s*/g, '+'); // 去除加号前后的空格
                formatted = formatted.replace(/\s*-\s*/g, '-'); // 去除减号前后的空格
                formatted = formatted.replace(/\s*\/\s*/g, '/'); // 去除除号前后的空格
                formatted = formatted.replace(/\s*\^\s*/g, '^'); // 去除幂号前后的空格
                formatted = formatted.replace(/\s*=\s*/g, '='); // 去除等号前后的空格
                formatted = formatted.replace(/^\s+|\s+$/g, ''); // 去除首尾空格
                
                return formatted;
            },
            
            // 清理和转换 math.js 输出，以方便显示 (用于步骤)
            cleanMathJSText(text) {
                let cleaned = text;
                
                // 0. 特殊处理对数导数格式，如 1/xln2【最终计算值/x】
                cleaned = cleaned.replace(/(\d+)\/(\w+)ln(\d+(?:\.\d+)?)【([^】]+)】/g, (match, numerator, variable, base, calc) => {
                    return `${numerator}/${variable}ln${base}【${calc}】`;
                });
                cleaned = cleaned.replace(/(\d+)\/(\w+)ln\(([^)]+)\)【([^】]+)】/g, (match, numerator, variable, base, calc) => {
                    return `${numerator}/${variable}ln(${base})【${calc}】`;
                });
                
                // 1. log(v, b) 转换为 logbase(b, v) 占位符（底数，真数）
                cleaned = cleaned.replace(/log\(([^,]+),([^)]+)\)/g, 'logbase($2, $1)'); 
                
                // 2. log10(v) 转换为 lg(v)
                cleaned = cleaned.replace(/log10\(([^)]+)\)/g, 'lg($1)');
                
                // 3. log(v) (自然对数) 转换为 ln(v)
                // 修复：使用负向预查避免匹配 logbase 和 log(底数)(真数) 格式
                cleaned = cleaned.replace(/\blog\(([^,]+)\)(?!\s*,)(?!\s*\()(?!\s*\()/g, 'ln($1)'); 

                // 修复：保留数字之间的乘法符号，移除其他情况下的乘号符号
                // 保留数字之间的乘法：3*2 -> 3*2
                // 移除函数和变量之间的乘法：sin(x)*y -> sin(x)y
                // 移除常数和变量之间的乘法：3*x -> 3x
                // 注意：这里不再移除所有乘号，而是只移除特定情况下的乘号
                cleaned = cleaned.replace(/([a-zA-Z\)\)])\*([a-zA-Z\(])/g, '$1$2'); // 函数/变量与函数/变量之间的乘号
                cleaned = cleaned.replace(/(\d)\*([a-zA-Z\(])/g, '$1$2'); // 数字与函数/变量之间的乘号
                cleaned = cleaned.replace(/([a-zA-Z\)\)])\*(\d)/g, '$1$2'); // 函数/变量与数字之间的乘号
                cleaned = cleaned.replace(/([a-zA-Z])\*(\d)/g, '$1$2'); // 单个变量与数字之间的乘号
                
                // 修复: 在步骤中显示 π 和 √ 
                cleaned = cleaned.replace(/pi/g, 'π');
                cleaned = cleaned.replace(/sqrt\(([^)]+)\)/g, '√($1)');
                
                // 新增：将π的数值表示替换为π符号
                cleaned = cleaned.replace(/3\.141592653589793/g, 'π');
                
                // 新增：将e的数值表示替换为e符号
                cleaned = cleaned.replace(/2\.718281828459045/g, 'e');
                
                // 新增：处理π的常见分数形式
                cleaned = cleaned.replace(/π\/2/g, 'π/2');
                cleaned = cleaned.replace(/π\/3/g, 'π/3');
                cleaned = cleaned.replace(/π\/4/g, 'π/4');
                cleaned = cleaned.replace(/π\/6/g, 'π/6');
                cleaned = cleaned.replace(/2\*π/g, '2π');
                cleaned = cleaned.replace(/3\*π/g, '3π');
                cleaned = cleaned.replace(/π\*2/g, '2π');
                cleaned = cleaned.replace(/π\*3/g, '3π');
                
                // 去除多余的空格，但保留乘号前后的空格
                cleaned = cleaned.replace(/\s+/g, ' '); // 将多个连续空格替换为单个空格
                cleaned = cleaned.replace(/\s*\(\s*/g, '('); // 去除括号前后的空格
                cleaned = cleaned.replace(/\s*\)\s*/g, ')'); // 去除右括号前后的空格
                cleaned = cleaned.replace(/\s*\+\s*/g, '+'); // 去除加号前后的空格
                cleaned = cleaned.replace(/\s*-\s*/g, '-'); // 去除减号前后的空格
                // 修复：不再移除乘号前后的空格，保留乘号
                // cleaned = cleaned.replace(/\s*\*\s*/g, ''); // 去除乘号前后的空格
                cleaned = cleaned.replace(/\s*\/\s*/g, '/'); // 去除除号前后的空格
                cleaned = cleaned.replace(/\s*\^\s*/g, '^'); // 去除幂号前后的空格
                cleaned = cleaned.replace(/\s*=\s*/g, '='); // 去除等号前后的空格
                cleaned = cleaned.replace(/^\s+|\s+$/g, ''); // 去除首尾空格
                
                return cleaned;
            },
            
            // **修正 Issue 1 (多余 1) 和 Issue 1 (分数转换) 的核心函数**
            formatCoefficient(coeff, isConstant = false) {
                const tolerance = this.tolerance;
                
                if (Math.abs(coeff) < tolerance) return '0';
                
                // 1. 尝试用 math.js 格式化为分数
                try {
                    const fraction = math.fraction(coeff);
                    // 仅当分母不是 1 时显示分数形式, 且分母不能大于 100 (防止将 1.732... 转换为大分数)
                    if (fraction.d !== 1 && fraction.d < 100 && math.abs(math.subtract(coeff, fraction.valueOf())) < tolerance) {
                        const n = fraction.n * (fraction.d < 0 ? -1 : 1);
                        const d = Math.abs(fraction.d);
                        return `${n}/${d}`;
                    }
                } catch (e) {
                    // 忽略错误
                }
                
                const absValue = Math.abs(coeff);

                // 2. 如果是变量系数 (isConstant=false)
                if (!isConstant) {
                    // 如果系数的绝对值接近 1，返回空字符串 (修复多余的 1)
                    if (Math.abs(absValue - 1) < tolerance) return ''; 
                    
                    // 否则返回绝对值
                    if (Math.abs(absValue - Math.round(absValue)) < tolerance) {
                        return Math.round(absValue).toString();
                    }
                }
                
                // 3. 最终回退 (常数项或非整数系数)
                if (Math.abs(coeff - Math.round(coeff)) < tolerance) {
                    return Math.round(coeff).toString();
                }
                
                // 最终回退到小数格式
                return coeff.toFixed(6).replace(/\.?0+$/, '');
            },
            
            // ... [其他辅助函数保持不变] ...
            evaluateTrigonometricExpression(expr) {
                // 调试信息
                console.log('=== evaluateTrigonometricExpression 函数调试 ===');
                console.log('输入表达式:', expr);
                
                let result = expr;
                let changed = true;
                const tolerance = this.tolerance;
                
                const safeTrigPattern = /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(([^)]+)\)/g;
                let match;
                while ((match = safeTrigPattern.exec(expr)) !== null) {
                    const originalMatch = match[0];
                    const func = match[1];
                    let arg = match[2];
                    
                    console.log('处理三角函数:', originalMatch);
                    console.log('函数名:', func);
                    console.log('参数:', arg);
                    
                    try {
                        // 使用包含π和e的scope计算参数值
                        const scope = { pi: 3.141592653589793, e: 2.718281828459045, i: math.i }; // 新增：支持虚数单位
                        const argValue = math.evaluate(arg, scope);
                        
                        console.log('参数计算值:', argValue);
                        console.log('参数值类型:', typeof argValue);
                        
                        // 检查是否包含虚数（更严格的检查，排除含有i的单词如pi）
                        const argStr = arg.toString();
                        console.log('参数字符串:', argStr);
                        
                        // 更严格的检查：确保i前后不是字母，排除函数名中的i
                        const hasImaginaryI = /(^|\W|[-+*\/])(\d*\.*\d*)\s*i\s*($|\W|[-+*\/])(?![a-zA-Z])/.test(argStr);
                        console.log('hasImaginaryI 正则匹配结果:', hasImaginaryI);
                        
                        const isImaginary = hasImaginaryI || 
                                         (typeof argValue === 'object' && argValue !== null && 'im' in argValue && argValue.im !== 0);
                        
                        console.log('isImaginary:', isImaginary);
                        
                        // 如果是虚数参数，不进行计算，保持原样
                        if (isImaginary) {
                            console.log('跳过虚数参数的计算，保持原样');
                            // 跳过虚数参数的计算，保持原样
                            continue;
                        }
                        
                        // 获取精确值
                        const exactValue = this.getExactTrigValue(func, argValue);
                        
                        if (exactValue && exactValue !== '∞' && exactValue !== '-∞') {
                            result = result.replace(originalMatch, exactValue);
                            changed = true;
                            // 由于替换，表达式长度可能改变，需要重新从头开始搜索
                            safeTrigPattern.lastIndex = 0;
                            expr = result;
                            continue;
                        } else if (exactValue && (exactValue === '∞' || exactValue === '-∞')) {
                            // 遇到无穷大，停止替换
                        } else {
                            // Fallback to numerical evaluation for all cases
                            let funcValue;
                            switch(func) {
                                case 'sin': funcValue = Math.sin(argValue); break;
                                case 'cos': funcValue = Math.cos(argValue); break;
                                case 'tan': funcValue = Math.tan(argValue); break;
                                case 'cot': funcValue = 1 / Math.tan(argValue); break;
                                case 'sec': funcValue = 1 / Math.cos(argValue); break;
                                case 'csc': funcValue = 1 / Math.sin(argValue); break;
                                case 'asin': funcValue = Math.asin(argValue); break;
                                case 'acos': funcValue = Math.acos(argValue); break;
                                case 'atan': funcValue = Math.atan(argValue); break;
                                default: continue;
                            }
                            
                            // 检查是否是有限值
                            if (!isFinite(funcValue)) {
                                // 无穷大情况，替换为∞或-∞
                                // 特殊处理：确保tan(-90°)和tan(-3π/2)显示为-∞
                                let infinityValue = funcValue > 0 ? '∞' : '-∞';
                                
                                // 额外检查特殊情况
                                if (func === 'tan') {
                                    // 检查是否是-90°或-π/2
                                    if ((Math.abs(argValue + Math.PI/2) < tolerance) || 
                                        (Math.abs(argValue + 90*Math.PI/180) < tolerance)) {
                                        infinityValue = '-∞';
                                    }
                                    // 检查是否是3π/2或270°
                                    else if ((Math.abs(argValue - 3*Math.PI/2) < tolerance) || 
                                            (Math.abs(argValue - 270*Math.PI/180) < tolerance)) {
                                        infinityValue = '-∞';
                                    }
                                    // 检查是否是-3π/2或-270°
                                    else if ((Math.abs(argValue + 3*Math.PI/2) < tolerance) || 
                                            (Math.abs(argValue + 270*Math.PI/180) < tolerance)) {
                                        infinityValue = '∞';
                                    }
                                }
                                
                                result = result.replace(originalMatch, infinityValue);
                                // 由于替换，表达式长度可能改变，需要重新从头开始搜索
                                safeTrigPattern.lastIndex = 0;
                                expr = result;
                                changed = true;
                                continue;
                            }
                            
                            let replacement = null;
                            
                            // 检查常见精确值
                            if (Math.abs(funcValue) < tolerance) {
                                replacement = '0';
                            } else if (Math.abs(funcValue - 1) < tolerance) {
                                replacement = '1';
                            } else if (Math.abs(funcValue + 1) < tolerance) {
                                replacement = '-1';
                            } else if (Math.abs(funcValue - 0.5) < tolerance) {
                                replacement = '1/2';
                            } else if (Math.abs(funcValue + 0.5) < tolerance) {
                                replacement = '-1/2';
                            } else if (Math.abs(funcValue - Math.sqrt(2)/2) < tolerance) {
                                replacement = '√2/2';
                            } else if (Math.abs(funcValue + Math.sqrt(2)/2) < tolerance) {
                                replacement = '-√2/2';
                            } else if (Math.abs(funcValue - Math.sqrt(3)/2) < tolerance) {
                                replacement = '√3/2';
                            } else if (Math.abs(funcValue + Math.sqrt(3)/2) < tolerance) {
                                replacement = '-√3/2';
                            } else if (Math.abs(funcValue - 1/Math.sqrt(2)) < tolerance) {
                                replacement = '1/√2';
                            } else if (Math.abs(funcValue + 1/Math.sqrt(2)) < tolerance) {
                                replacement = '-1/√2';
                            } else if (Math.abs(funcValue - 1/Math.sqrt(3)) < tolerance) {
                                replacement = '1/√3';
                            } else if (Math.abs(funcValue + 1/Math.sqrt(3)) < tolerance) {
                                replacement = '-1/√3';
                            } else if (Math.abs(funcValue - Math.sqrt(3)) < tolerance) {
                                replacement = '√3';
                            } else if (Math.abs(funcValue + Math.sqrt(3)) < tolerance) {
                                replacement = '-√3';
                            } else if (Math.abs(funcValue - Math.sqrt(2)) < tolerance) {
                                replacement = '√2';
                            } else if (Math.abs(funcValue + Math.sqrt(2)) < tolerance) {
                                replacement = '-√2';
                            } else {
                                // 对于其他值，使用数值近似
                                replacement = funcValue.toFixed(6).replace(/\.?0+$/, '');
                            }
                            
                            if (replacement !== null) {
                                result = result.replace(originalMatch, replacement);
                                safeTrigPattern.lastIndex = 0;
                                expr = result;
                                changed = true;
                                continue;
                            }
                        }
                    } catch (e) {
                        // 忽略解析错误
                    }
                }
                return result;
            },
            
            // 简化数值表达式
            evaluateMathematicalExpression(expr) {
                try {
                    // 如果表达式只包含常数，则直接计算
                    if (this.isConstantExpression(expr)) {
                        // 针对 pi 和 e 的特殊处理
                        if (expr === 'pi') { return 'π'; }
                        if (expr === 'e') { return 'e'; }
                        if (expr === 'i') { return 'i'; }
                        
                        // 创建包含π、e和i的scope
                        const scope = { pi: 3.141592653589793, e: 2.718281828459045, i: math.i }; // 支持虚数单位
                        const result = math.evaluate(expr, scope);
                        
                        // 检查是否为无穷大
                        if (!isFinite(result)) {
                            // 检查是否是虚数结果
                            if (result.toString().includes('i') || 
                                (typeof result === 'object' && result !== null && 're' in result && 'im' in result)) {
                                // 虚数不是无穷大，继续处理
                            } else {
                                // 返回∞或-∞
                                return result > 0 ? '∞' : '-∞';
                            }
                        }
                        
                        // 如果是特殊值，返回精确表示
                        const exactValue = this.getExactValue(result);
                        if (exactValue) {
                            return exactValue;
                        }
                        
                        // 检查结果是否为常见的π和e的组合
                        if (this.isPiOrECombination(result)) {
                            return this.formatPiOrECombination(result);
                        }
                        
                        // 处理虚数结果
                        if (this.containsImaginary(expr)) {
                            return this.formatComplexNumber(result);
                        }
                        
                        // 否则返回数值
                        if (Math.abs(result) < this.tolerance) return '0';
                        return Math.abs(result - Math.round(result)) < this.tolerance ? Math.round(result).toString() : result.toFixed(6).replace(/\.?0+$/, '');
                    }
                    return expr;
                } catch (error) {
                    return expr;
                }
            },
            
            // 新增：检查结果是否为π和e的组合
            isPiOrECombination(value) {
                const tolerance = this.tolerance;
                const pi = math.pi;
                const e = math.e;
                
                // 检查是否为π的倍数
                if (Math.abs(value / pi - Math.round(value / pi)) < tolerance) {
                    return true;
                }
                
                // 检查是否为e的倍数
                if (Math.abs(value / e - Math.round(value / e)) < tolerance) {
                    return true;
                }
                
                // 检查是否为π+e的组合
                if (Math.abs(value - (pi + e)) < tolerance) {
                    return true;
                }
                
                // 检查是否为π-e的组合
                if (Math.abs(value - (pi - e)) < tolerance) {
                    return true;
                }
                
                // 检查是否为e-π的组合
                if (Math.abs(value - (e - pi)) < tolerance) {
                    return true;
                }
                
                return false;
            },
            
            // 新增：格式化π和e的组合
            formatPiOrECombination(value) {
                const tolerance = this.tolerance;
                const pi = math.pi;
                const e = math.e;
                
                // 检查是否为π的倍数
                const piMultiple = Math.round(value / pi);
                if (Math.abs(value / pi - piMultiple) < tolerance) {
                    if (piMultiple === 1) return 'π';
                    if (piMultiple === -1) return '-π';
                    if (piMultiple === 0) return '0';
                    return `${piMultiple}π`;
                }
                
                // 检查是否为e的倍数
                const eMultiple = Math.round(value / e);
                if (Math.abs(value / e - eMultiple) < tolerance) {
                    if (eMultiple === 1) return 'e';
                    if (eMultiple === -1) return '-e';
                    if (eMultiple === 0) return '0';
                    return `${eMultiple}e`;
                }
                
                // 检查是否为π+e的组合
                if (Math.abs(value - (pi + e)) < tolerance) {
                    return 'π + e';
                }
                
                // 检查是否为π-e的组合
                if (Math.abs(value - (pi - e)) < tolerance) {
                    return 'π - e';
                }
                
                // 检查是否为e-π的组合
                if (Math.abs(value - (e - pi)) < tolerance) {
                    return 'e - π';
                }
                
                // 如果都不是，返回数值
                return value.toFixed(6).replace(/\.?0+$/, '');
            },
            
            // 修改：检查表达式是否包含无理数（更严格的条件）
            containsIrrational(expr) {
                // 只有e和π等无理数参加的常数运算才使用≈
                // 三角函数及反三角函数，函数中含π的最终结果都应该化简到最简
                
                // 检查是否包含π和e的常数运算
                const hasPi = expr.includes('pi') || expr.includes('π');
                const hasE = expr.includes('e');
                
                // 检查是否包含sqrt
                const hasSqrt = expr.includes('sqrt') || expr.includes('√');
                
                // 检查是否包含对数
                const hasLog = expr.includes('log') || expr.includes('ln') || expr.includes('lg');
                
                // 只有当表达式包含π、e、sqrt或对数，并且不包含变量时，才认为是无理数运算
                const hasVariable = /[a-df-hj-np-qt-wyz]/i.test(expr.replace(/pi|e|π|3\.141592653589793|2\.718281828459045|i/g, ''));
                
                return (hasPi || hasE || hasSqrt || hasLog) && !hasVariable;
            },
            
            // 新增：格式化复数结果
            formatComplexNumber(result) {
                // 如果结果是复数对象
                if (typeof result === 'object' && result !== null && 're' in result && 'im' in result) {
                    const re = result.re;
                    const im = result.im;
                    const tolerance = this.tolerance;
                    
                    // 处理实部
                    let realPart = '';
                    if (Math.abs(re) > tolerance) {
                        if (Math.abs(re - Math.round(re)) < tolerance) {
                            realPart = Math.round(re).toString();
                        } else {
                            realPart = re.toFixed(6).replace(/\.?0+$/, '');
                        }
                    }
                    
                    // 处理虚部
                    let imagPart = '';
                    if (Math.abs(im) > tolerance) {
                        if (Math.abs(Math.abs(im) - 1) < tolerance) {
                            imagPart = im > 0 ? 'i' : '-i';
                        } else {
                            const absIm = Math.abs(im);
                            if (Math.abs(absIm - Math.round(absIm)) < tolerance) {
                                imagPart = (im > 0 ? '' : '-') + Math.round(absIm) + 'i';
                            } else {
                                imagPart = (im > 0 ? '' : '-') + absIm.toFixed(6).replace(/\.?0+$/, '') + 'i';
                            }
                        }
                    }
                    
                    // 组合结果
                    if (realPart && imagPart) {
                        return realPart + (imagPart.startsWith('-') ? imagPart : '+' + imagPart);
                    } else if (realPart) {
                        return realPart;
                    } else if (imagPart) {
                        return imagPart;
                    } else {
                        return '0';
                    }
                }
                
                // 如果结果是字符串形式的复数
                if (typeof result === 'string') {
                    // 直接返回字符串形式的结果
                    return result;
                }
                
                // 其他情况返回原始结果
                return result.toString();
            },
            
            // 新增：检查结果是否包含虚数
            containsImaginary(result) {
                // 调试信息
                console.log('=== containsImaginary 函数调试 ===');
                console.log('输入结果:', result);
                
                // 首先检查结果字符串是否包含i，但要排除函数名中的i
                // 例如：sin, cos, tan, asin, acos, atan等函数名中的i不应该被识别为虚数
                if (result.includes('i')) {
                    console.log('结果包含字母 i');
                    
                    // 修改：使用更精确的正则表达式匹配各种形式的虚数
                    // 匹配单独的i、数字+i、数字-i、i+数字、i-数字等形式
                    // 更严格的检查：确保i前后不是字母，排除函数名中的i
                    const hasImaginaryI = /(^|\W|[-+*\/])(\d*\.*\d*)\s*i\s*($|\W|[-+*\/])(?![a-zA-Z])/.test(result);
                    console.log('hasImaginaryI 正则匹配结果:', hasImaginaryI);
                    
                    if (hasImaginaryI) {
                        console.log('返回 true (hasImaginaryI)');
                        return true;
                    }
                    
                    // 检查是否在函数参数中有i，如 sin(i), cos(i) 等
                    // 修复：排除函数参数中的 pi，避免错误匹配
                    const hasImaginaryInFunction = /(sin|cos|tan|cot|sec|csc|asin|acos|atan|log|ln|lg|sqrt|exp)\s*\(\s*[^)]*i[^)]*\)/.test(result) && !/pi/i.test(result);
                    console.log('hasImaginaryInFunction 正则匹配结果:', hasImaginaryInFunction);
                    
                    if (hasImaginaryInFunction) {
                        console.log('返回 true (hasImaginaryInFunction)');
                        return true;
                    }
                    
                    // 检查是否在函数后有i，如 cosi, sini 等
                    const hasImaginaryAfterFunction = /(sin|cos|tan|cot|sec|csc|asin|acos|atan|log|ln|lg|sqrt|exp)i\b/.test(result);
                    console.log('hasImaginaryAfterFunction 正则匹配结果:', hasImaginaryAfterFunction);
                    
                    if (hasImaginaryAfterFunction) {
                        console.log('返回 true (hasImaginaryAfterFunction)');
                        return true;
                    }
                } else {
                    console.log('结果不包含字母 i');
                }
                
                // 检查结果是否是复数对象
                try {
                    const evaluated = math.evaluate(result, { i: math.i });
                    console.log('math.evaluate 结果:', evaluated);
                    console.log('evaluated 类型:', typeof evaluated);
                    
                    if (typeof evaluated === 'object' && evaluated !== null && 're' in evaluated && 'im' in result) {
                        console.log('evaluated.im:', evaluated.im);
                        const hasImaginaryPart = evaluated.im !== 0;
                        console.log('返回', hasImaginaryPart, '(复数对象虚部不为0)');
                        return hasImaginaryPart;
                    }
                } catch (e) {
                    console.log('math.evaluate 出错:', e.message);
                }
                
                console.log('返回 false (没有找到虚数)');
                return false;
            },
            
            // 新增：检查结果是否是复数结果（用于显示虚数提示）
            isComplexResult(expression) {
                // 如果表达式为空或无效，直接返回false
                if (!expression || expression.trim() === '') {
                    return false;
                }
                
                try {
                    // 尝试计算表达式，检查结果是否包含虚数部分
                    const scope = { pi: math.pi, e: math.e, i: math.i };
                    const result = math.evaluate(expression, scope);
                    
                    // 如果结果是复数对象且虚部不为0
                    if (typeof result === 'object' && result !== null && 're' in result && 'im' in result) {
                        return Math.abs(result.im) > this.tolerance;
                    }
                    
                    // 如果结果字符串包含i且不是函数名或pi中的i
                    if (typeof result === 'string' && result.includes('i')) {
                        // 检查是否是真正的虚数表达式
                        return /(^|\W)i($|\W)/.test(result) && !/sin|cos|tan|asin|acos|atan|pi/.test(result);
                    }
                    
                    return false;
                } catch (e) {
                    return false;
                }
            },
            
            // 新增：评估虚数表达式，化简虚数幂运算
            evaluateImaginaryExpression(expr) {
                console.log('=== evaluateImaginaryExpression 函数调试 ===');
                console.log('输入表达式:', expr);
                
                let processed = expr;
                
                // 化简虚数幂运算
                // i^1 = i, i^2 = -1, i^3 = -i, i^4 = 1, i^5 = i, ...
                processed = processed.replace(/\bi\^(\d+)\b/g, (match, power) => {
                    const n = parseInt(power);
                    const remainder = n % 4;
                    
                    switch (remainder) {
                        case 0: return '1';
                        case 1: return 'i';
                        case 2: return '-1';
                        case 3: return '-i';
                        default: return 'i^' + power;
                    }
                });
                
                // 合并同类项
                const scope = { i: math.i };
                try {
                    // 使用math.js进行化简，但保留虚数形式
                    const simplified = math.simplify(processed).toString();
                    console.log('math.simplify 结果:', simplified);
                    
                    // 如果结果包含复数，格式化为标准形式
                    if (simplified.includes('i')) {
                        return this.formatComplexNumber(math.evaluate(simplified, scope));
                    } else {
                        return simplified;
                    }
                } catch (e) {
                    console.log('math.simplify 出错:', e.message);
                    return processed;
                }
            },
            
            // 新增：检查值是否是精确值
            isExactValue(value) {
                const tolerance = this.tolerance;
                
                // 检查常见的精确值
                const exactValues = [
                    0, 1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8, 9, -9, 10, -10,
                    0.5, -0.5, 0.25, -0.25, 0.75, -0.75,
                    Math.sqrt(2), -Math.sqrt(2), Math.sqrt(3), -Math.sqrt(3), Math.sqrt(5), -Math.sqrt(5),
                    Math.sqrt(2)/2, -Math.sqrt(2)/2, Math.sqrt(3)/2, -Math.sqrt(3)/2, Math.sqrt(3)/3, -Math.sqrt(3)/3,
                    1/Math.sqrt(2), -1/Math.sqrt(2), 1/Math.sqrt(3), -1/Math.sqrt(3),
                    math.pi, -math.pi, math.pi/2, -math.pi/2, math.pi/3, -math.pi/3, math.pi/4, -math.pi/4, math.pi/6, -math.pi/6,
                    2*math.pi, -2*math.pi, 3*math.pi, -3*math.pi,
                    math.e, -math.e, math.e/2, -math.e/2,
                    Math.log(2), -Math.log(2), Math.log(10), -Math.log(10)
                ];
                
                return exactValues.some(exact => Math.abs(value - exact) < tolerance);
            },
            
            // 新增：检查原始表达式中是否包含虚数操作
            hasImaginaryOperation(originalExpr, resultExpr) {
                // 调试信息
                console.log('=== hasImaginaryOperation 函数调试 ===');
                console.log('原始表达式:', originalExpr);
                console.log('结果表达式:', resultExpr);
                
                // 检查原始表达式中是否包含虚数单位i
                if (!originalExpr.includes('i')) {
                    console.log('原始表达式不包含字母 i，返回 false');
                    return false;
                }
                
                console.log('原始表达式包含字母 i');
                
                // 检查是否是真正的虚数表达式，排除函数名中的i
                // 更严格的检查：确保i前后不是字母，排除函数名中的i
                const hasImaginaryI = /(^|\W|[-+*\/])(\d*\.*\d*)\s*i\s*($|\W|[-+*\/])(?![a-zA-Z])/.test(originalExpr);
                console.log('hasImaginaryI 正则匹配结果:', hasImaginaryI);
                
                if (hasImaginaryI) {
                    console.log('返回 true (hasImaginaryI)');
                    return true;
                }
                
                // 检查是否在函数参数中有i，如 sin(i), cos(i) 等
                // 修复：排除函数参数中的 pi，避免错误匹配
                const hasImaginaryInFunction = /(sin|cos|tan|cot|sec|csc|asin|acos|atan|log|ln|lg|sqrt|exp)\s*\(\s*[^)]*i[^)]*\)/.test(originalExpr) && !/pi/i.test(originalExpr);
                console.log('hasImaginaryInFunction 正则匹配结果:', hasImaginaryInFunction);
                
                if (hasImaginaryInFunction) {
                    console.log('返回 true (hasImaginaryInFunction)');
                    return true;
                }
                
                // 检查是否在函数后有i，如 cosi, sini 等
                const hasImaginaryAfterFunction = /(sin|cos|tan|cot|sec|csc|asin|acos|atan|log|ln|lg|sqrt|exp)i\b/.test(originalExpr);
                console.log('hasImaginaryAfterFunction 正则匹配结果:', hasImaginaryAfterFunction);
                
                if (hasImaginaryAfterFunction) {
                    console.log('返回 true (hasImaginaryAfterFunction)');
                    return true;
                }
                
                console.log('返回 false (没有找到虚数操作)');
                return false;
            },
            
            // 检查是否是只包含常数的表达式 
            isConstantExpression(expr) {
                // 先移除函数名，再检查变量
                let exprWithoutFunctions = expr;
                
                // 移除常见的函数名，只保留参数部分
                const functionNames = ['sin', 'cos', 'tan', 'cot', 'sec', 'csc', 'asin', 'acos', 'atan', 'acot', 'asec', 'acsc', 
                                     'sinh', 'cosh', 'tanh', 'asinh', 'acosh', 'atanh',
                                     'log', 'ln', 'lg', 'log10', 'sqrt', 'exp', 'abs', 'factorial', 'gamma'];
                
                functionNames.forEach(funcName => {
                    const regex = new RegExp(funcName + '\\s*\\(', 'g');
                    exprWithoutFunctions = exprWithoutFunctions.replace(regex, '(');
                });
                
                // 检查是否包含变量（除了pi、e、i等常数）
                // 排除 π, e 和 i
                const variablePattern = /[a-df-hj-np-qt-wyz]/i;
                if (variablePattern.test(exprWithoutFunctions.replace(/pi|e|π|3\.141592653589793|2\.718281828459045|i/g, ''))) {
                    return false;
                }
                return true;
            },
            
            // 获取精确值表示 (不变)
            getExactValue(value) {
                const tolerance = this.tolerance;
                const pi = 3.141592653589793;
                const e = 2.718281828459045;
                
                // 检查常见精确值
                if (Math.abs(value - pi) < tolerance) return 'π';
                if (Math.abs(value + pi) < tolerance) return '-π';
                if (Math.abs(value - e) < tolerance) return 'e';
                if (Math.abs(value + e) < tolerance) return '-e';
                
                // 检查分数 π/n, nπ/m 等
                for (let i = 2; i <= 6; i++) {
                    if (Math.abs(value - pi/i) < tolerance) return `π/${i}`;
                    if (Math.abs(value + pi/i) < tolerance) return `-π/${i}`;
                }
                
                return null;
            },
            
            // 修改：获取精确三角函数值（增强化简，确保含π的三角函数化简到最简）
            getExactTrigValue(func, value) {
                const tolerance = this.tolerance;
                const pi = 3.141592653589793;
                
                // 常见角度值表（含π的三角函数的最简形式）
                const commonAngles = {
                    '0': { sin: '0', cos: '1', tan: '0', cot: '∞', sec: '1', csc: '∞', 
                           asin: '0', acos: 'π/2', atan: '0', acot: 'π/2', asec: '0', acsc: '∞' },
                    '0.5235987755982988': { sin: '1/2', cos: '√3/2', tan: '1/√3', cot: '√3', sec: '2/√3', csc: '2', // π/6
                                           asin: 'π/6', acos: 'π/3', atan: 'π/6', acot: 'π/3', asec: 'π/3', acsc: 'π/6' },
                    '0.7853981633974483': { sin: '√2/2', cos: '√2/2', tan: '1', cot: '1', sec: '√2', csc: '√2', // π/4
                                           asin: 'π/4', acos: 'π/4', atan: 'π/4', acot: 'π/4', asec: 'π/4', acsc: 'π/4' },
                    '1.0471975511965976': { sin: '√3/2', cos: '1/2', tan: '√3', cot: '1/√3', sec: '2', csc: '2/√3', // π/3
                                           asin: 'π/3', acos: 'π/6', atan: 'π/3', acot: 'π/6', asec: 'π/6', acsc: 'π/3' },
                    '1.5707963267948966': { sin: '1', cos: '0', tan: '∞', cot: '0', sec: '∞', csc: '1', // π/2
                                           asin: 'π/2', acos: '0', atan: 'π/2', acot: '0', asec: '∞', acsc: 'π/2' },
                    '3.141592653589793': { sin: '0', cos: '-1', tan: '0', cot: '∞', sec: '-1', csc: '∞', // π
                                          asin: '0', acos: 'π', atan: '0', acot: 'π', asec: 'π', acsc: '∞' }
                };
                
                // 检查 nπ 的情况
                if (Math.abs(value % pi) < tolerance) {
                    const n = Math.round(value / pi);
                    if (func === 'sin' || func === 'tan') return '0';
                    if (func === 'cos') return n % 2 === 0 ? '1' : '-1';
                    if (func === 'cot' || func === 'csc') {
                        // 检查是否为负无穷大
                        if (func === 'cot' && n % 2 !== 0) return '-∞';
                        return '∞';
                    }
                }
                
                // 检查 nπ + π/2 的情况
                if (Math.abs((value - pi/2) % pi) < tolerance) {
                    const n = Math.round((value - pi/2) / pi);
                    if (func === 'cos' || func === 'cot') return '0';
                    if (func === 'sin') return n % 2 === 0 ? '1' : '-1';
                    if (func === 'tan' || func === 'sec') {
                        // 正确处理tan和sec的无穷大符号
                        // tan(π/2) = +∞, tan(3π/2) = -∞, tan(5π/2) = +∞, ...
                        // tan(-π/2) = -∞, tan(-3π/2) = +∞, tan(-5π/2) = -∞, ...
                        if (n % 2 === 0) {
                            // n为偶数时，如π/2, 5π/2, -3π/2等
                            return (value > 0) ? '∞' : '-∞';
                        } else {
                            // n为奇数时，如3π/2, 7π/2, -π/2等
                            return (value > 0) ? '-∞' : '∞';
                        }
                    }
                }
                
                // 检查常见角度
                for (const [angle, values] of Object.entries(commonAngles)) {
                    const angleNum = parseFloat(angle);
                    
                    // 检查正角度
                    if (Math.abs(value - angleNum) < tolerance) {
                        return values[func];
                    }
                    
                    // 检查负角度
                    if (Math.abs(value + angleNum) < tolerance) {
                        const negativeValues = {
                            'sin': values.sin === '0' || values.sin === '∞' ? values.sin : `-${values.sin}`,
                            'cos': values.cos,
                            'tan': values.tan === '0' || values.tan === '∞' ? values.tan : `-${values.tan}`,
                            'cot': values.cot === '0' || values.cot === '∞' ? values.cot : `-${values.cot}`,
                            'sec': values.sec,
                            'csc': values.csc === '0' || values.csc === '∞' ? values.csc : `-${values.csc}`
                        };
                        return negativeValues[func].replace(/--/g, ''); // 确保不是双重负号
                    }
                }
                
                return null;
            },

            // **新增或修改:** 提取并生成常数近似值注解
            generateApproximationNote(originalExpr, finalValue) {
                const scope = { pi: math.pi, e: math.e, i: math.i }; // 新增：支持虚数单位
                const approximations = [];
                const uniqueSymbols = new Set();
                
                // 检查是否包含无理数
                let hasIrrational = false;
                
                // 1. 扫描 e 和 pi
                if (originalExpr.includes('e')) {
                    uniqueSymbols.add('e');
                    hasIrrational = true;
                }
                if (originalExpr.includes('pi') || originalExpr.includes('π')) {
                    uniqueSymbols.add('π');
                    hasIrrational = true;
                }
                
                // 2. 扫描 sqrt(N) 和 √N
                const sqrtPatterns = [
                    /sqrt\(([^)]+)\)/g,  // sqrt(N) 形式
                    /√\(([^)]+)\)/g,     // √(N) 形式
                    /√(\d+)/g           // √N 形式 (如 √2, √3)
                ];
                
                sqrtPatterns.forEach(sqrtPattern => {
                    let match;
                    while ((match = sqrtPattern.exec(originalExpr)) !== null) {
                        try {
                            const arg = match[1];
                            const value = math.evaluate(arg, scope);
                            // 考虑所有正数参数
                            if (Number.isFinite(value) && value > 0 && value !== 1) {
                                // 如果是 √N 形式，显示为 √N 而不是 √(N)
                                const displaySymbol = match[0].startsWith('√(') ? `√${value}` : `√(${value})`;
                                uniqueSymbols.add(displaySymbol);
                                hasIrrational = true;
                            }
                        } catch (e) { /* 忽略复杂的 sqrt */ }
                    }
                });
                
                // 3. 扫描 ln/lg/logN
                // 转换后的形式: log(v, N), log10(v), log(v) (自然对数)
                const logPattern = /(log\(([^,]+)\)|log10\(([^)]+)\)|log\(([^,]+),([^)]+)\))/g;
                let normalizedExpr = originalExpr.replace(/ln\(/g, 'log(').replace(/lg\(/g, 'log10(');
                normalizedExpr = normalizedExpr.replace(/\blog([0-9]+)\s*\(([^)]+)\)/g, 'log($2, $1)');
                // 新增：转换 log(底数)(真数) 格式为 log(真数, 底数)
                normalizedExpr = normalizedExpr.replace(/\blog\s*\(\s*([^()]+)\s*\)\s*\(\s*([^()]+)\s*\)/g, 'log($2, $1)');

                normalizedExpr.match(logPattern)?.forEach(logTerm => {
                     uniqueSymbols.add(logTerm);
                     hasIrrational = true;
                });
                
                // 4. 新增：扫描常见无理数组合，如 π/2, π/3, π/4, π/6 等
                const piPatterns = [
                    { pattern: /pi\/2/, symbol: 'π/2' },
                    { pattern: /pi\/3/, symbol: 'π/3' },
                    { pattern: /pi\/4/, symbol: 'π/4' },
                    { pattern: /pi\/6/, symbol: 'π/6' },
                    { pattern: /2\*pi/, symbol: '2π' },
                    { pattern: /3\*pi/, symbol: '3π' },
                    { pattern: /pi\*2/, symbol: '2π' },
                    { pattern: /pi\*3/, symbol: '3π' }
                ];
                
                piPatterns.forEach(({ pattern, symbol }) => {
                    if (pattern.test(originalExpr)) {
                        uniqueSymbols.add(symbol);
                        hasIrrational = true;
                    }
                });
                
                // 5. 格式化列表
                uniqueSymbols.forEach(symbol => {
                    let value;
                    let displaySymbol;
                    
                    if (symbol === 'e') {
                        value = math.e;
                        displaySymbol = 'e';
                    } else if (symbol === 'π') {
                        value = math.pi;
                        displaySymbol = 'π';
                    } else if (symbol.startsWith('√(')) {
                        const num = parseFloat(symbol.substring(2, symbol.length - 1));
                        value = Math.sqrt(num);
                        displaySymbol = `√${num}`;
                    } else if (symbol.startsWith('π/')) {
                        // 处理 π/n 形式
                        const denominator = parseFloat(symbol.substring(2));
                        value = math.pi / denominator;
                        displaySymbol = `π/${denominator}`;
                    } else if (symbol.endsWith('π')) {
                        // 处理 nπ 形式
                        const multiplier = parseFloat(symbol.substring(0, symbol.length - 1));
                        value = multiplier * math.pi;
                        displaySymbol = `${multiplier}π`;
                    } else if (symbol.startsWith('log')) {
                        // For log/ln/lg terms, evaluate their value but display the function
                         try {
                            // 检查是否是log(底数)(真数)格式，如果是则转换为log(真数, 底数)进行计算
                            let evalSymbol = symbol;
                            const logBaseFormat = symbol.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                            if (logBaseFormat) {
                                evalSymbol = `log(${logBaseFormat[2]}, ${logBaseFormat[1]})`;
                            }
                            
                            value = math.evaluate(evalSymbol, scope);
                            // 转换回显示符号 (使用新的格式化逻辑)
                            if (symbol.startsWith('log10')) displaySymbol = symbol.replace(/log10\(([^)]+)\)/, 'lg($1)');
                            else if (symbol.includes(',')) displaySymbol = symbol.replace(/log\(([^,]+),([^)]+)\)/, 'log<sub>$2</sub>($1)');
                            else if (logBaseFormat) {
                                displaySymbol = `log<sub>${logBaseFormat[1]}</sub>(${logBaseFormat[2]})`;
                            } else {
                                displaySymbol = symbol.replace(/log\(([^)]+)\)/, 'ln($1)');
                            }
                            
                            // 调试信息
                            console.log('=== generateApproximationNote 中的log处理 ===');
                            console.log('原始symbol:', symbol);
                            console.log('计算用的evalSymbol:', evalSymbol);
                            console.log('计算值:', value);
                            console.log('转换后的displaySymbol:', displaySymbol);
                         } catch (e) {
                            console.log('无法求值的对数项:', symbol, e.message);
                            return; // 无法求值的对数项
                         }
                    } else {
                        return;
                    }
                    
                    // 仅添加有限的、非零的近似值
                    if (isFinite(value) && Math.abs(value) > this.tolerance) {
                        // 检查是否是精确值（如 log2(2)=1）
                        const isExactValue = this.isExactValue(value);
                        const symbol = isExactValue ? '=' : '≈';
                        approximations.push(`${displaySymbol}${symbol}${value.toFixed(6).replace(/\.?0+$/, '')}`);
                    }
                });

                // 修正：判断最终结果是否是无理数
                let finalIsIrrational = false;
                try {
                    const numericalResult = parseFloat(finalValue);
                    if (!isNaN(numericalResult)) {
                        // 检查最终结果是否是常见的无理数值
                        const commonIrrationals = [
                            { value: Math.sqrt(2), tolerance: 1e-10 },
                            { value: Math.sqrt(3), tolerance: 1e-10 },
                            { value: Math.sqrt(5), tolerance: 1e-10 },
                            { value: math.pi, tolerance: 1e-10 },
                            { value: math.e, tolerance: 1e-10 },
                            { value: Math.sqrt(2)/2, tolerance: 1e-10 }, // √2/2
                            { value: Math.sqrt(3)/2, tolerance: 1e-10 }, // √3/2
                            { value: Math.sqrt(3)/3, tolerance: 1e-10 }, // √3/3
                            { value: 1/Math.sqrt(2), tolerance: 1e-10 }, // 1/√2
                            { value: 1/Math.sqrt(3), tolerance: 1e-10 }, // 1/√3
                        ];
                        
                        finalIsIrrational = commonIrrationals.some(irr => 
                            Math.abs(numericalResult - irr.value) < irr.tolerance
                        );
                    }
                } catch (e) {
                    // 如果无法解析为数值，假设不是无理数
                }

                // 修改：当表达式包含无理数时，总是显示近似值注释
                const note = approximations.length > 0 ? `【${approximations.join(', ')}】` : '';
                
                // 根据最终结果是否是无理数决定使用≈还是=
                const symbol = finalIsIrrational ? '≈' : '=';
                return `${symbol} ${finalValue} ${note}`;
            },
            
            displayResult(result) {
                const { outputDiv, stepsDiv } = App.elements;
                
                const integralConstant = (result.operation === 'integral') ? ' + C' : ''; // 只有不定积分才加C
                
                // 检查是否有无穷大项 - 对于所有操作类型都检查
                const hasInfiniteTerms = result.copyText && result.copyText.includes('【') && (result.copyText.includes('∞】') || result.copyText.includes('-∞】'));
                // 检查是否有NaN项但没有无穷大项
                const hasOnlyNaN = result.copyText && result.copyText.includes('log') && 
                                  (result.copyText.includes('log(-3)') || result.copyText.includes('log1(1)') || result.copyText.includes('log(-2)') || result.copyText.includes('=NaN')) &&
                                  !hasInfiniteTerms;
                
                let finalExpression = result.expression;
                let finalCopyText = result.copyText;
                
                // Set Title and Input Display
                let resultTitle = '';
                let inputDisplay = '';

                if (result.operation === 'integral') {
                    inputDisplay = `∫(${this.formatExpressionForDisplay(result.originalExpression)}) d${result.variable}`;
                    resultTitle = '不定积分结果:';
                } else if (result.operation === 'definite_integral') {
                    const lowerDisplay = this.formatExpressionForDisplay(result.lowerLimit || '0');
                    const upperDisplay = this.formatExpressionForDisplay(result.upperLimit || '1');
                    inputDisplay = `∫<sub>${lowerDisplay}</sub><sup>${upperDisplay}</sup>(${this.formatExpressionForDisplay(result.originalExpression)}) d${result.variable}`;
                    resultTitle = '定积分结果:';
                    finalExpression = result.expression;
                    finalCopyText = result.copyText || result.expression;
                } else if (result.operation === 'double_integral') {
                    inputDisplay = `∬(${this.formatExpressionForDisplay(result.originalExpression)}) d${result.variable}d${result.variable2}`;
                    resultTitle = '二重不定积分结果:';
                } else if (result.operation === 'double_definite_integral') {
                    const xLowerDisp = this.formatExpressionForDisplay(result.xLower || '0');
                    const xUpperDisp = this.formatExpressionForDisplay(result.xUpper || '1');
                    const yLowerDisp = this.formatExpressionForDisplay(result.yLower || '0');
                    const yUpperDisp = this.formatExpressionForDisplay(result.yUpper || '1');
                    inputDisplay = `∬<sub>${xLowerDisp}</sub><sup>${xUpperDisp}</sup><sub>${yLowerDisp}</sub><sup>${yUpperDisp}</sup>(${this.formatExpressionForDisplay(result.originalExpression)}) d${result.variable}d${result.variable2}`;
                    resultTitle = '二重定积分结果:';
                    finalExpression = result.expression;
                    finalCopyText = result.copyText || result.expression;
                } else if (result.operation === 'n_definite_integral') {
                    const limitsDisplay = result.limits.map(lim => `[${this.formatExpressionForDisplay(lim.lower)},${this.formatExpressionForDisplay(lim.upper)}]`).join('');
                    const varsDisplay = result.variables.map(v => `d${v}`).join('');
                    inputDisplay = `∫${limitsDisplay}(${this.formatExpressionForDisplay(result.originalExpression)}) ${varsDisplay}`;
                    resultTitle = `${result.integralOrder}重定积分结果:`;
                    finalExpression = result.expression;
                    finalCopyText = result.copyText || result.expression;
                } else if (result.operation === 'simplify') {
                    // **FIX 2: 为纯常数化简修改最终输出格式**
                    const isPureConstant = this.isConstantExpression(result.originalExpression) && !result.originalExpression.includes(result.variable);
                    
                    if (isPureConstant && !hasInfiniteTerms) {
                        inputDisplay = this.formatExpressionForDisplay(result.originalExpression);
                        resultTitle = '数值化简结果:';
                    } else {
                        // 对于化简操作，不在这里预先添加符号，符号将在generateApproximationNote中处理
                        inputDisplay = `${this.formatExpressionForDisplay(result.originalExpression)} `;
                        resultTitle = '化简结果:';
                    }
                } else if (result.operation === 'evaluate') {
                    // inputDisplay for evaluate is handled by appendInfiniteTerms for clarity
                    resultTitle = '求值结果:';
                } else {
                    resultTitle = '计算结果:';
                }
                
                // 定积分、二重定积分和n重定积分直接显示,不需要进一步处理
                if (result.operation === 'definite_integral' || result.operation === 'double_definite_integral' || result.operation === 'n_definite_integral') {
                    // 跳过后续处理,直接显示结果
                } else if (!hasInfiniteTerms) {
                    // 检查表达式是否包含虚数
                    const hasImaginaryInExpression = this.containsImaginary(result.expression) || 
                                                   this.hasImaginaryOperation(result.originalExpression, result.expression);
                    
                    // 调试信息
                    console.log('=== displayResult 中的虚数检查 ===');
                    console.log('result.expression:', result.expression);
                    console.log('hasImaginaryInExpression:', hasImaginaryInExpression);
                    
                    // 只有在不包含虚数时才进行三角函数和数值简化
                    if (!hasImaginaryInExpression) {
                        console.log('表达式不包含虚数，进行三角函数和数值简化');
                        const trigEvaluated = this.evaluateTrigonometricExpression(result.expression);
                        if (trigEvaluated !== result.expression) {
                            finalExpression = trigEvaluated;
                            finalCopyText = finalCopyText.replace(result.expression, trigEvaluated);
                        }
                        
                        const fullyEvaluated = this.evaluateMathematicalExpression(finalExpression);
                        if (fullyEvaluated !== finalExpression) {
                            finalExpression = fullyEvaluated;
                            finalCopyText = finalCopyText.replace(trigEvaluated, fullyEvaluated);
                        }
                        
                        // 确保所有Infinity和-Infinity都被替换为∞和-∞
                        finalExpression = finalExpression.replace(/Infinity/g, '∞').replace(/-Infinity/g, '-∞');
                        finalCopyText = finalCopyText.replace(/Infinity/g, '∞').replace(/-Infinity/g, '-∞');
                        
                        // 确保所有NaN都被保留
                        finalExpression = finalExpression.replace(/NaN/g, 'NaN');
                        finalCopyText = finalCopyText.replace(/NaN/g, 'NaN');
                    } else {
                        console.log('表达式包含虚数，进行虚数特殊处理');
                        // 对虚数表达式进行特殊处理，化简虚数幂运算
                        const imaginaryEvaluated = this.evaluateImaginaryExpression(result.expression);
                        if (imaginaryEvaluated !== result.expression) {
                            finalExpression = imaginaryEvaluated;
                            finalCopyText = finalCopyText.replace(result.expression, imaginaryEvaluated);
                        }
                    }
                }
                
                // **关键点: 确保最终显示和 CopyText 都经过 formatExpressionForDisplay 处理**
                const displayExpression = this.formatExpressionForDisplay(finalExpression);
                // 清理displayExpression中的HTML标签，用于原始表达式显示
                const cleanDisplayExpression = this.stripHtmlTags(displayExpression);

                let constantApproximationHTML = '';

                // **FIX 2: 最终结果注解**
                if (result.operation === 'simplify' && !hasInfiniteTerms && resultTitle.startsWith('数值化简结果')) {
                    // 保存finalExpression的值，用于虚数检查
                    const savedFinalExpression = finalExpression;
                    
                    // 对于数值化简，需要显示处理后的原始表达式（包含乘法符号）
                    const processedOriginalExpr = result.displayExpression || this.formatOriginalExpression(result.originalExpression);
                    const approximationNote = this.generateApproximationNote(
                        result.originalExpression, 
                        finalExpression // 已经是最终数值
                    );
                    
                    // 在这里进行虚数检查
                    const hasImaginary = this.containsImaginary(savedFinalExpression);
                    // 只有在原始表达式中真正包含i时才检查虚数操作
                    const hasImaginaryOp = result.originalExpression.includes('i') ? this.hasImaginaryOperation(result.originalExpression, savedFinalExpression) : false;
                    
                    // 调试信息
                    console.log('=== 数值化简情况下的虚数检查 ===');
                    console.log('原始表达式:', result.originalExpression);
                    console.log('savedFinalExpression:', savedFinalExpression);
                    console.log('hasImaginary:', hasImaginary);
                    console.log('result.originalExpression.includes("i"):', result.originalExpression.includes('i'));
                    console.log('hasImaginaryOp:', hasImaginaryOp);
                    
                    const imaginaryNote = (hasImaginary || hasImaginaryOp) ? '<span style="color: #9b59b6; font-size: 0.9em;">【i为虚数】</span>' : '';
                    
                    constantApproximationHTML = `
                        <div class="approximation-text">
                            ${processedOriginalExpr} ${approximationNote} ${imaginaryNote}
                        </div>
                    `;
                    // 最终显示结果不再重复显示原表达式和近似值
                    finalExpression = ''; 
                }
                
                let outputHTML = '';
                
                // 对于化简和求值操作，需要添加适当的等于/约等于符号
                let finalOutputText;
                let finalCopyValue;
                
                if (hasInfiniteTerms) {
                    // 如果有无穷大项，显示原始表达式等于结果
                    const originalExpr = result.displayExpression || this.formatOriginalExpression(result.originalExpression);
                    finalOutputText = `${originalExpr} = ${finalCopyText}`;
                    finalCopyValue = `${this.stripHtmlTags(originalExpr)} = ${finalCopyText}`;
                } else if (hasOnlyNaN) {
                    // 如果只有NaN项而没有真正的无穷大项，也显示原始表达式等于结果
                    const originalExpr = result.displayExpression || this.formatOriginalExpression(result.originalExpression);
                    finalOutputText = `${originalExpr} = ${finalCopyText}`;
                    finalCopyValue = `${this.stripHtmlTags(originalExpr)} = ${finalCopyText}`;
                } else if (constantApproximationHTML) {
                    // 数值化简情况，已经在constantApproximationHTML中处理了符号
                    finalOutputText = '';
                    finalCopyValue = finalExpression;
                } else if (result.operation === 'definite_integral' || result.operation === 'double_definite_integral' || result.operation === 'n_definite_integral') {
                    // 定积分、二重定积分和n重定积分特殊处理: 直接显示积分符号 = 结果
                    finalOutputText = `${inputDisplay} = ${displayExpression}`;
                    finalCopyValue = `${this.stripHtmlTags(inputDisplay)} = ${this.stripHtmlTags(displayExpression)}`;
                } else if (result.operation === 'evaluate' || result.operation === 'simplify') {
                    // 对于求值和化简，使用generateApproximationNote确定符号
                    const approximationNote = this.generateApproximationNote(
                        result.originalExpression, 
                        cleanDisplayExpression
                    );
                    
                    // 从approximationNote中提取符号和结果
                    const symbolMatch = approximationNote.match(/^(=|≈)\s+(.+?)(?:\s*\【|$)/);
                    if (symbolMatch) {
                        const symbol = symbolMatch[1];
                        const resultValue = symbolMatch[2];
                        const displayExpr = result.displayExpression || this.formatOriginalExpression(result.originalExpression);
                        finalOutputText = `${displayExpr} ${symbol} ${resultValue}${integralConstant}`;
                        finalCopyValue = `${this.stripHtmlTags(displayExpr)} ${symbol} ${resultValue}${integralConstant}`;
                    } else {
                        // 备用方案
                        finalOutputText = `${inputDisplay}${displayExpression}${integralConstant}`;
                        finalCopyValue = `${this.stripHtmlTags(inputDisplay)}${this.stripHtmlTags(displayExpression)}${integralConstant}`;
                    }
                    
                    // 添加近似值注释到最终输出
                    const approximationNoteMatch = approximationNote.match(/【(.+?)】$/);
                    if (approximationNoteMatch) {
                        const approximationText = approximationNoteMatch[1];
                        finalOutputText += ` 【${approximationText}】`;
                        finalCopyValue += ` 【${approximationText}】`;
                    }
                } else {
                    // 其他操作类型
                    finalOutputText = `${inputDisplay}${displayExpression}${integralConstant}`;
                    finalCopyValue = `${this.stripHtmlTags(inputDisplay)}${this.stripHtmlTags(displayExpression)}${integralConstant}`;
                }

                // 检查是否包含虚数 - 只有在结果中真正包含虚数时才显示提示
                // 修复：当finalExpression为空时（数值化简情况），不检查虚数
                let hasImaginary = false;
                let imaginaryNote = '';
                
                if (finalExpression && finalExpression.trim() !== '') {
                    hasImaginary = this.containsImaginary(finalExpression);
                    imaginaryNote = hasImaginary && (finalExpression.includes('i') || this.isComplexResult(finalExpression)) ? '<span style="color: #9b59b6; font-size: 0.9em;">【i为虚数】</span>' : '';
                }

                outputHTML += `
                    <div class="math-expression">
                        <div class="result-title">${resultTitle}</div>
                        ${constantApproximationHTML ? constantApproximationHTML : `<div class="result-text">${finalOutputText} ${imaginaryNote}</div>`}
                        <i class="fas fa-copy copy-icon" title="复制结果" data-text="${finalCopyValue}"></i>
                    </div>
                `;
                
                outputDiv.innerHTML = outputHTML;
                
                if (result.steps && result.steps.length > 0 && !hasInfiniteTerms) {
                    const stepsTitle = document.createElement('h3');
                    stepsTitle.innerHTML = '<i class="fas fa-list-ol"></i> 计算步骤';
                    stepsDiv.appendChild(stepsTitle);
                    
                    // Display steps with formatting
                    result.steps.forEach((step, index) => {
                        const stepElement = document.createElement('div');
                        stepElement.className = 'step';
                        
                        // 使用 cleanMathJSText 确保步骤中的 pi 和 sqrt 被正确格式化
                        let displayStep = this.cleanMathJSText(step);
                        
                        // 对于第一个步骤（原函数），使用原始表达式形式
                        if (index === 0) {
                            displayStep = displayStep.replace(this.formatExpressionForDisplay(result.originalExpression), 
                                                          result.displayExpression || this.formatOriginalExpression(result.originalExpression));
                        }
                        
                        displayStep = this.formatExpressionForDisplay(displayStep);
                            
                        stepElement.innerHTML = `
                            <div class="step-title">
                                <i class="fas fa-arrow-right"></i> 步骤 ${index + 1} 
                            </div>
                            <div class="result-text">${displayStep}</div>
                        `;
                        stepsDiv.appendChild(stepElement);
                    });
                }
                
                this.addCopyFunctionality();
            },
            
            displayError(message, expression) {
                const { outputDiv } = App.elements;
                // 添加调试信息
                console.error('显示错误信息:', {
                    message: message,
                    expression: expression,
                    stack: new Error().stack
                });
                outputDiv.innerHTML = `
                    <div class="error">
                        <strong>计算错误:</strong> ${message} 
                    </div>
                    <div class="math-expression">
                        <div class="result-title">输入表达式:</div>
                        <div class="result-text">${this.formatExpressionForDisplay(expression)}</div>
                    </div>
                `;
            },
            
            handleClear() {
                const { expressionInput, outputDiv, stepsDiv, variableInputs } = App.elements;
                expressionInput.value = '';
                outputDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d; padding: 30px;">计算结果将显示在这里...</p>';
                stepsDiv.innerHTML = '';
                variableInputs.innerHTML = '';
                App.cache.clear();
            },
            
            calculate(expression, operation, variable, nthOrder, nSamples) {
                const lowerLimit = App.elements.lowerLimitInput?.value || '0';
                const upperLimit = App.elements.upperLimitInput?.value || '1';
                const var2 = App.elements.variable2Input?.value || 'y';
                const var2Def = App.elements.variable2DefiniteInput?.value || 'y';
                
                const nIntegralOrder = App.elements.nVariablesInput?.value.split(',').length || 'n';
                
                const operationNames = {
                    'derivative': '一阶导数 (d/dx)',
                    'integral': '积分 (∫ dx)',
                    'definite_integral': `定积分 (∫[${lowerLimit},${upperLimit}] dx)`,
                    'double_integral': `二重不定积分 (∬ d${variable}d${var2})`,
                    'double_definite_integral': `二重定积分 (∬ d${variable}d${var2Def})`,
                    'n_definite_integral': `${nIntegralOrder}重定积分`,
                    'second_derivative': '二阶导数 (d²/dx²)',
                    'nth_derivative': `n阶导数 (d^${nthOrder}/d${variable}^${nthOrder})`,
                    'simplify': '表达式化简',
                    'evaluate': '表达式求值'
                };
                
                let result;
                
                switch (operation) {
                    case 'derivative':
                        result = this.calculateDerivative(expression, variable);
                        break;
                    case 'integral':
                        result = this.calculateIntegral(expression, variable);
                        break;
                    case 'definite_integral':
                        result = this.calculateDefiniteIntegral(expression, variable, lowerLimit, upperLimit);
                        break;
                    case 'double_integral':
                        const var2 = App.elements.variable2Input.value.trim() || 'y';
                        result = this.calculateDoubleIntegral(expression, variable, var2);
                        break;
                    case 'double_definite_integral':
                        const var2Def = App.elements.variable2DefiniteInput.value.trim() || 'y';
                        const xLower = App.elements.xLowerInput.value.trim();
                        const xUpper = App.elements.xUpperInput.value.trim();
                        const yLower = App.elements.yLowerInput.value.trim();
                        const yUpper = App.elements.yUpperInput.value.trim();
                        result = this.calculateDoubleDefiniteIntegral(expression, variable, var2Def, xLower, xUpper, yLower, yUpper);
                        break;
                    case 'n_definite_integral':
                        // 自动检测表达式中的变量，而不是使用用户输入的变量列表
                        const detectedVars = this.detectVariables(expression);
                        
                        // 如果没有检测到变量，使用默认变量x
                        const nVariables = detectedVars.length > 0 ? detectedVars : ['x'];
                        
                        // 获取用户输入的积分区间
                        const nLimits = App.elements.nLimitsInput.value.trim().split(';').map(limit => {
                            const [lower, upper] = limit.split(',').map(v => v.trim());
                            return { lower, upper };
                        });
                        
                        // 如果用户输入的区间数量与检测到的变量数量不匹配，调整区间数量
                        if (nLimits.length < nVariables.length) {
                            // 如果区间数量不足，使用默认区间[0,1]补充
                            while (nLimits.length < nVariables.length) {
                                nLimits.push({ lower: '0', upper: '1' });
                            }
                        }
                        // 区间数量多于变量数量时，保持不变，正常计算即可
                        
                        const userSamples = parseInt(nSamples) || 10000000;
                        result = this.calculateNDefiniteIntegral(expression, nVariables, nLimits, userSamples);
                        break;
                    case 'second_derivative':
                        result = this.calculateNthDerivative(expression, variable, 2);
                        break;
                    case 'nth_derivative':
                        result = this.calculateNthDerivative(expression, variable, nthOrder);
                        break;
                    case 'simplify':
                        result = this.calculateSimplify(expression, variable);
                        break;
                    case 'evaluate':
                        result = this.evaluateExpression(expression);
                        break;
                    default:
                        throw new Error('不支持的计算类型');
                }
                
                result.operation = operation;
                result.variable = variable;
                result.name = operationNames[operation];
                result.originalExpression = expression;
                
                return result;
            },
            
            // 增强的求导函数，包含合并同类项逻辑和任意对数求导支持
            calculateDerivative(expr, varName) {
                const steps = [`原函数: ${this.formatExpressionForDisplay(expr)}`];
                try {
                    // 对于包含对数函数的表达式，直接使用特殊处理，不进行合并同类项
                    if (this.containsLogarithm(expr)) {
                        steps.push(`检测到对数函数，使用特殊求导规则`);
                        const logDerivative = this.calculateLogarithmDerivative(expr, varName);
                        if (logDerivative) {
                            steps.push(`对数求导结果: ${this.cleanMathJSText(logDerivative)}`);
                            const copyText = `d/d${varName}(${this.cleanMathJSText(expr)}) = ${this.cleanMathJSText(logDerivative)}`;
                            return { expression: this.cleanMathJSText(logDerivative), steps, copyText };
                        }
                    }
                    
                    // 增强: 先合并同类项，解决常数项过多导致求导卡死的问题
                    const mergedExpr = this.mergeLikeTerms(expr, varName);
                    if (mergedExpr !== expr) {
                        steps.push(`预处理 (合并同类项): ${this.cleanMathJSText(mergedExpr)}`);
                    }
                    
                    // math.derivative 内部会自动尝试 simplify，这里直接使用合并后的表达式
                    const result = math.derivative(mergedExpr, varName).toString();
                    
                    // 确保结果的常数部分也被简化
                    const finalResult = this.mergeLikeTerms(result, varName);

                    const copyText = `d/d${varName}(${this.cleanMathJSText(expr)}) = ${this.cleanMathJSText(finalResult)}`;
                    return { expression: this.cleanMathJSText(finalResult), steps, copyText };
                } catch (error) {
                    const copyText = `d/d${varName}(${this.cleanMathJSText(expr)}) = 无法计算该导数`;
                    return { expression: "无法计算该导数", steps: [`发生错误: ${error.message}`], copyText, error: error.message };
                }
            },
            
            // 增强的 n 阶求导函数，包含合并同类项逻辑和对数求导支持
            calculateNthDerivative(expr, varName, order) {
                const steps = [`原函数: ${this.formatExpressionForDisplay(expr)}`, `计算 ${order} 阶导数`];
                const orderNum = parseInt(order);
                if (isNaN(orderNum) || orderNum < 1) {
                    throw new Error('阶数必须是一个大于等于 1 的整数');
                }
                
                // 增强: 先合并同类项，解决常数项过多导致求导卡死的问题
                let currentExpr = this.mergeLikeTerms(expr, varName);
                if (currentExpr !== expr) {
                    steps.push(`预处理 (合并同类项): ${this.cleanMathJSText(currentExpr)}`);
                }
                
                for (let i = 1; i <= orderNum; i++) {
                    // 确保每一阶导数都是从简化后的表达式开始
                    currentExpr = this.mergeLikeTerms(currentExpr, varName);
                    
                    // 检查是否包含对数函数，进行特殊处理
                    if (this.containsLogarithm(currentExpr)) {
                        steps.push(`第 ${i} 阶导数: 检测到对数函数，使用特殊求导规则`);
                        const logDerivative = this.calculateLogarithmDerivative(currentExpr, varName);
                        if (logDerivative) {
                            currentExpr = logDerivative;
                        } else {
                            // 如果对数求导失败，使用默认方法
                            currentExpr = math.derivative(currentExpr, varName).toString();
                        }
                    } else {
                        currentExpr = math.derivative(currentExpr, varName).toString();
                    }
                    
                    steps.push(`第 ${i} 阶导数: ${this.cleanMathJSText(currentExpr)}`);
                }
                
                // 确保最终结果被简化
                const finalResult = this.mergeLikeTerms(currentExpr, varName);
                
                const copyText = `d^${order}/d${varName}^${order}(${this.cleanMathJSText(expr)}) = ${this.cleanMathJSText(finalResult)}`;
                return { expression: this.cleanMathJSText(finalResult), steps, copyText };
            },
            
            // 积分函数 (已修改：移除 math.simplify, 确保分数显示)
            calculateIntegral(expr, varName) {
                const steps = [`被积函数: ${this.formatExpressionForDisplay(expr)}`];
                try {
                    // 1. 优化：先合并同类项
                    const mergedExpr = this.mergeLikeTerms(expr, varName);
                    if (mergedExpr !== expr) {
                        steps.push(`步骤1: 合并同类项: ${this.cleanMathJSText(mergedExpr)}`);
                    }
                    
                    // 2. 展开多项式
                    const expanded = this.expandPolynomial(mergedExpr, varName);
                    if (expanded !== mergedExpr) {
                        steps.push(`步骤2: 展开多项式: ${this.cleanMathJSText(expanded)}`);
                    }
                    
                    // 3. 将表达式拆分为项并逐项积分
                    const node = math.parse(expanded);
                    const terms = [];
                    this.extractTerms(node, terms);
                    
                    let integratedTerms = [];
                    terms.forEach(term => {
                        const integral = this.integrateTerm(term.node, varName, term.sign);
                        integratedTerms.push(integral);
                    });
                    
                    // 4. 重新组合结果
                    let resultText = integratedTerms.join(' ').trim();
                    
                    // 清理开头的符号
                    resultText = resultText.replace(/^\+\s*/, '');
                    
                    // 清理多余的符号
                    resultText = resultText
                        .replace(/\+\s*\-/g, '- ')
                        .replace(/\-\s*\-/g, '+ ')
                        .replace(/\s+/g, ' ')
                        .replace(/\* /g, '*')
                        .replace(/ \*/g, '*');
                        
                    steps.push(`步骤3: 逐项积分并组合: ${this.cleanMathJSText(resultText)}`);
                    
                    if (!resultText) {
                        resultText = '无法计算该积分';
                    }
                    
                    // 保存原始math.js格式用于定积分计算
                    const rawCopyText = resultText;
                    const copyText = `${this.cleanMathJSText(resultText)}`;
                    return { expression: this.cleanMathJSText(resultText), steps, copyText, rawResult: rawCopyText };
                } catch (error) {
                    const copyText = `无法计算该积分`;
                    return { expression: "无法计算该积分", steps: [`发生错误: ${error.message}`], copyText, error: error.message };
                }
            },
            
            // 定积分计算函数 - 全新简化版本
            calculateDefiniteIntegral(expr, varName, lower, upper) {
                const steps = [];
                
                try {
                    // 步骤1: 显示原始积分
                    steps.push(`原始积分: ∫[${lower}, ${upper}] ${expr} d${varName}`);
                    
                    // 步骤2: 预处理
                    const processedExpr = this.preprocessExpression(expr);
                    const processedLower = this.preprocessExpression(lower);
                    const processedUpper = this.preprocessExpression(upper);
                    
                    // 步骤3: 计算上下限数值
                    const scope = { pi: math.pi, e: math.e };
                    const a = math.evaluate(processedLower, scope);
                    const b = math.evaluate(processedUpper, scope);
                    
                    if (!isFinite(a) || !isFinite(b)) {
                        throw new Error('上下限必须是有限数值');
                    }
                    
                    steps.push(`上下限数值: a=${a}, b=${b}`);
                    
                    // 步骤4: 数值积分 - 使用简单的矩形法
                    const n = 5000; // 分割数
                    const dx = (b - a) / n;
                    let sum = 0;
                    
                    for (let i = 0; i < n; i++) {
                        const x = a + (i + 0.5) * dx; // 中点
                        const evalScope = { ...scope, [varName]: x };
                        const y = math.evaluate(processedExpr, evalScope);
                        
                        if (!isFinite(y)) {
                            throw new Error(`函数在x=${x}处值为${y}`);
                        }
                        
                        sum += y;
                    }
                    
                    const result = sum * dx;
                    
                    steps.push(`使用中点矩形法(n=${n})`);
                    steps.push(`结果: ${result}`);
                    
                    // 格式化结果
                    let finalResult = result.toFixed(8).replace(/\.?0+$/, '');
                    
                    // 接近整数时显示为整数
                    if (Math.abs(result - Math.round(result)) < 1e-6) {
                        finalResult = Math.round(result).toString();
                    }
                    
                    return {
                        expression: finalResult,
                        copyText: finalResult,
                        steps: steps,
                        operation: 'definite_integral',
                        variable: varName,
                        originalExpression: expr,
                        lowerLimit: lower,
                        upperLimit: upper
                    };
                    
                } catch (error) {
                    return {
                        expression: '计算失败',
                        copyText: '计算失败',
                        steps: [`错误: ${error.message}`],
                        error: error.message,
                        operation: 'definite_integral',
                        variable: varName,
                        originalExpression: expr,
                        lowerLimit: lower,
                        upperLimit: upper
                    };
                }
            },
            
            // 二重不定积分计算函数
            calculateDoubleIntegral(expr, var1, var2) {
                const steps = [];
                
                try {
                    steps.push(`计算二重不定积分: ∬ ${expr} d${var1}d${var2}`);
                    
                    // 步骤1: 对第一个变量积分
                    steps.push(`步骤1: 先对${var1}积分`);
                    const firstIntegral = this.calculateIntegral(expr, var1);
                    
                    if (firstIntegral.error) {
                        throw new Error(`对${var1}积分失败: ${firstIntegral.error}`);
                    }
                    
                    // 获取第一次积分的结果(移除+C)
                    let firstResult = firstIntegral.copyText || firstIntegral.expression;
                    firstResult = firstResult.replace(/\s*\+\s*C\s*$/i, '');
                    
                    steps.push(`对${var1}积分结果: ${this.formatExpressionForDisplay(firstResult)}`);
                    
                    // 步骤2: 对第二个变量积分
                    steps.push(`步骤2: 再对${var2}积分`);
                    const secondIntegral = this.calculateIntegral(firstResult, var2);
                    
                    if (secondIntegral.error) {
                        throw new Error(`对${var2}积分失败: ${secondIntegral.error}`);
                    }
                    
                    // 获取最终结果
                    let finalResult = secondIntegral.expression;
                    let copyText = secondIntegral.copyText || finalResult;
                    
                    // 二重积分的积分常数为 C1*x + C2 或 C
                    finalResult = finalResult.replace(/\s*\+\s*C\s*$/i, ' + C');
                    copyText = copyText.replace(/\s*\+\s*C\s*$/i, ' + C');
                    
                    steps.push(`最终结果: ${this.formatExpressionForDisplay(finalResult)}`);
                    
                    return {
                        expression: finalResult,
                        copyText: copyText,
                        steps: steps,
                        operation: 'double_integral',
                        variable: var1,
                        variable2: var2,
                        originalExpression: expr
                    };
                    
                } catch (error) {
                    return {
                        expression: '计算失败',
                        copyText: '计算失败',
                        steps: [`错误: ${error.message}`],
                        error: error.message,
                        operation: 'double_integral',
                        variable: var1,
                        variable2: var2,
                        originalExpression: expr
                    };
                }
            },
            
            // 二重定积分计算函数
            calculateDoubleDefiniteIntegral(expr, var1, var2, x1, x2, y1, y2) {
                const steps = [];
                
                try {
                    steps.push(`计算二重定积分: ∬[${x1},${x2}][${y1},${y2}] ${expr} d${var1}d${var2}`);
                    
                    // 预处理
                    const processedExpr = this.preprocessExpression(expr);
                    const scope = { pi: math.pi, e: math.e };
                    
                    // 计算积分区间
                    const xLower = math.evaluate(this.preprocessExpression(x1), scope);
                    const xUpper = math.evaluate(this.preprocessExpression(x2), scope);
                    const yLower = math.evaluate(this.preprocessExpression(y1), scope);
                    const yUpper = math.evaluate(this.preprocessExpression(y2), scope);
                    
                    steps.push(`积分区间: ${var1}∈[${xLower}, ${xUpper}], ${var2}∈[${yLower}, ${yUpper}]`);
                    
                    // 使用二重数值积分
                    const nx = 100; // x方向分割数
                    const ny = 100; // y方向分割数
                    const dx = (xUpper - xLower) / nx;
                    const dy = (yUpper - yLower) / ny;
                    
                    let sum = 0;
                    
                    for (let i = 0; i < nx; i++) {
                        for (let j = 0; j < ny; j++) {
                            const x = xLower + (i + 0.5) * dx;
                            const y = yLower + (j + 0.5) * dy;
                            
                            const evalScope = { ...scope, [var1]: x, [var2]: y };
                            const fxy = math.evaluate(processedExpr, evalScope);
                            
                            if (!isFinite(fxy)) {
                                throw new Error(`函数在(${x}, ${y})处值为${fxy}`);
                            }
                            
                            sum += fxy;
                        }
                    }
                    
                    const result = sum * dx * dy;
                    
                    steps.push(`使用中点矩形法(nx=${nx}, ny=${ny})`);
                    steps.push(`结果: ${result}`);
                    
                    // 格式化结果
                    let finalResult = result.toFixed(8).replace(/\.?0+$/, '');
                    if (Math.abs(result - Math.round(result)) < 1e-6) {
                        finalResult = Math.round(result).toString();
                    }
                    
                    return {
                        expression: finalResult,
                        copyText: finalResult,
                        steps: steps,
                        operation: 'double_definite_integral',
                        variable: var1,
                        variable2: var2,
                        originalExpression: expr,
                        xLower: x1,
                        xUpper: x2,
                        yLower: y1,
                        yUpper: y2
                    };
                    
                } catch (error) {
                    return {
                        expression: '计算失败',
                        copyText: '计算失败',
                        steps: [`错误: ${error.message}`],
                        error: error.message,
                        operation: 'double_definite_integral',
                        variable: var1,
                        variable2: var2,
                        originalExpression: expr,
                        xLower: x1,
                        xUpper: x2,
                        yLower: y1,
                        yUpper: y2
                    };
                }
            },
            
            // 自动检测表达式中的变量
            detectVariables(expr) {
                try {
                    // 使用math.js解析表达式
                    const node = math.parse(expr);
                    const variables = new Set();
                    
                    // 递归遍历表达式树，收集所有变量
                    const traverse = (node) => {
                        if (node.type === 'SymbolNode' && node.name !== 'pi' && node.name !== 'e') {
                            variables.add(node.name);
                        }
                        if (node.args) {
                            node.args.forEach(traverse);
                        }
                        if (node.content) {
                            traverse(node.content);
                        }
                    };
                    
                    traverse(node);
                    
                    // 转换为数组并保持原始顺序（按出现顺序）
                    const variableList = Array.from(variables);
                    
                    return variableList;
                } catch (error) {
                    console.error('变量检测失败:', error);
                    return [];
                }
            },

            // n重定积分计算 - 低维同步版本，高维异步版本
            calculateNDefiniteIntegral(expr, variables, limits, userSamples = 10000000) {
                // 如果没有提供变量列表，尝试从表达式中自动检测
                let detectedVariables = variables;
                if (!detectedVariables || detectedVariables.length === 0) {
                    detectedVariables = this.detectVariables(expr);
                }
                
                const n = detectedVariables.length;
                
                // 参数验证
                if (n < 1) throw new Error('至少需要1个变量');
                if (limits.length !== n) throw new Error(`需要${n}个积分区间,但只提供了${limits.length}个`);
                
                // 预处理与初始化
                const processedExpr = this.preprocessExpression(expr);
                const scope = { pi: math.pi, e: math.e };
                
                // 计算数值积分区间
                const numericLimits = limits.map((lim, i) => ({
                    lower: math.evaluate(this.preprocessExpression(lim.lower), scope),
                    upper: math.evaluate(this.preprocessExpression(lim.upper), scope),
                    variable: variables[i]
                }));
                
                // 终极策略选择
                const strategy = n <= 2 ? 'romberg' : (n <= 5 ? 'clenshaw' : 'halton');
                
                // 创建步骤数组
                const steps = [];
                
                // 显示积分信息
                const limitsStr = limits.map((lim, i) => `[${lim.lower},${lim.upper}]`).join('');
                const varsStr = variables.join('d');
                steps.push(`计算${n}重定积分: ∫${limitsStr} ${expr} d${varsStr}`);
                
                if (detectedVariables.length === 0) {
                    steps.push(`未检测到变量，使用默认变量: x`);
                }
                
                steps.push(`积分区间: ${numericLimits.map(lim => `${lim.variable}∈[${lim.lower.toFixed(4)},${lim.upper.toFixed(4)}]`).join(', ')}`);
                
                // 5维及以下使用同步计算
                if (n <= 5) {
                    try {
                        // === 策略1: 高维改进Halton序列 (6维+) - 同步版本 ===
                        if (strategy === 'halton') {
                            steps.push(`策略: 改进Halton序列 (准蒙特卡洛+Faure置换, 收敛O(1/N))`);
                            
                            const samples = Math.max(1000, Math.min(100000000, userSamples));
                            const volume = numericLimits.reduce((prod, lim) => prod * (lim.upper - lim.lower), 1);
                            
                            steps.push(`采样数: ${samples.toLocaleString()}, 体积: ${volume.toFixed(6)}`);
                            
                            // 改进的Halton序列 (打乱以减少相关性)
                            const primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97];
                            
                            const halton = (index, dim) => {
                                const base = primes[dim % primes.length];
                                let result = 0;
                                let f = 1;
                                let i = index + 1; // 从1开始避免0点
                                
                                while (i > 0) {
                                    f = f / base;
                                    result += f * (i % base);
                                    i = Math.floor(i / base);
                                }
                                
                                // 添加Faure置换减少相关性
                                return (result + 0.5 * (dim * 0.618033988749895 % 1)) % 1;
                            };
                            
                            // 同步计算
                            let sum = 0;
                            for (let i = 0; i < samples; i++) {
                                const evalScope = { ...scope };
                                
                                numericLimits.forEach((lim, d) => {
                                    const u = halton(i, d);
                                    evalScope[lim.variable] = lim.lower + u * (lim.upper - lim.lower);
                                });
                                
                                sum += math.evaluate(processedExpr, evalScope);
                            }
                            
                            // 计算完成
                            const result = volume * sum / samples;
                            const finalResult = Math.abs(result - Math.round(result)) < 1e-9 ? 
                                Math.round(result).toString() : result.toFixed(14).replace(/\.?0+$/, '');
                            
                            steps.push(`结果: ${finalResult}`);
                            steps.push(`注: Halton+Faure置换减少相关性, 精度优于纯Halton`);
                            
                            return {
                                expression: finalResult, copyText: finalResult, steps,
                                operation: 'n_definite_integral', variables, limits,
                                originalExpression: expr, integralOrder: n
                            };
                        }
                        
                        // === 策略2: 中维Clenshaw-Curtis求积 (3-5维) - 同步版本 ===
                        if (strategy === 'clenshaw') {
                            const m = n <= 3 ? 16 : (n === 4 ? 12 : 10); // 每维节点数
                            steps.push(`策略: ${n}重Clenshaw-Curtis求积 (${m}点, 接近最优)`);
                            
                            // Chebyshev节点和权重 (Clenshaw-Curtis)
                            const getNodesWeights = (N) => {
                                const nodes = [], weights = [];
                                for (let j = 0; j <= N; j++) {
                                    nodes.push(Math.cos(Math.PI * j / N));
                                    
                                    let w = 0;
                                    for (let k = 0; k <= Math.floor(N/2); k++) {
                                        const c = 2 * k;
                                        if (c === 0 || c === N) {
                                            w += 0.5 / (1 - c * c) * Math.cos(c * Math.PI * j / N);
                                        } else if (1 - c * c !== 0) {
                                            w += 1 / (1 - c * c) * Math.cos(c * Math.PI * j / N);
                                        }
                                    }
                                    
                                    // 端点权重减半
                                    const endpointFactor = (j === 0 || j === N) ? 0.5 : 1;
                                    weights.push(2 * w / N * endpointFactor);
                                }
                                return { nodes, weights };
                            };
                            
                            const { nodes, weights } = getNodesWeights(m);
                            
                            // 同步递归积分计算
                            const integrate = (depth, currentScope) => {
                                if (depth === n) return math.evaluate(processedExpr, currentScope);
                                
                                const { lower, upper, variable } = numericLimits[depth];
                                const mid = (upper + lower) / 2;
                                const half = (upper - lower) / 2;
                                let sum = 0;
                                
                                for (let i = 0; i <= m; i++) {
                                    const x = mid + half * nodes[i];
                                    const newScope = { ...currentScope, [variable]: x };
                                    sum += weights[i] * integrate(depth + 1, newScope);
                                }
                                
                                return sum * half;
                            };
                            
                            const result = integrate(0, scope);
                            const finalResult = Math.abs(result - Math.round(result)) < 1e-9 ? 
                                Math.round(result).toString() : result.toFixed(14).replace(/\.?0+$/, '');
                            
                            steps.push(`计算点数: ${Math.pow(m+1, n).toLocaleString()}`);
                            steps.push(`结果: ${finalResult}`);
                            steps.push(`注: Clenshaw-Curtis精度接近Gauss, 但数值稳定性更好`);
                            
                            return {
                                expression: finalResult, copyText: finalResult, steps,
                                operation: 'n_definite_integral', variables, limits,
                                originalExpression: expr, integralOrder: n
                            };
                        }
                        
                        // === 策略3: 低维Romberg积分 (1-2维) - 同步版本 ===
                        steps.push(`策略: ${n}重Romberg积分 (Richardson外推, 精度O(h^2k))`);
                        
                        // Romberg积分 - 梯形法则 + Richardson外推
                        const romberg = (f, a, b, maxK, scope, varName, depth) => {
                            const R = Array(maxK + 1).fill(0).map(() => Array(maxK + 1).fill(0));
                            
                            // R[0][0]: 梯形公式
                            let h = b - a;
                            R[0][0] = 0.5 * h * (f(a, scope, varName, depth) + f(b, scope, varName, depth));
                            
                            // 逐步细分
                            for (let i = 1; i <= maxK; i++) {
                                h /= 2;
                                let sum = 0;
                                const points = Math.pow(2, i - 1);
                                
                                for (let j = 1; j <= points; j++) {
                                    const x = a + (2 * j - 1) * h;
                                    sum += f(x, scope, varName, depth);
                                }
                                
                                R[i][0] = 0.5 * R[i-1][0] + h * sum;
                                
                                // Richardson外推
                                for (let k = 1; k <= i; k++) {
                                    const factor = Math.pow(4, k);
                                    R[i][k] = (factor * R[i][k-1] - R[i-1][k-1]) / (factor - 1);
                                }
                                
                                // 检查收敛
                                if (i > 1 && Math.abs(R[i][i] - R[i-1][i-1]) < 1e-12) {
                                    return R[i][i];
                                }
                            }
                            
                            return R[maxK][maxK];
                        };
                        
                        // 多重积分递归
                        const integrate = (depth, currentScope) => {
                            if (depth === n) return math.evaluate(processedExpr, currentScope);
                            
                            const { lower, upper, variable } = numericLimits[depth];
                            const f = (x, s, v, d) => integrate(d + 1, { ...s, [v]: x });
                            
                            return romberg(f, lower, upper, 10, currentScope, variable, depth);
                        };
                        
                        // 对于低维，直接计算，因为速度较快
                        const result = integrate(0, scope);
                        const finalResult = Math.abs(result - Math.round(result)) < 1e-9 ? 
                            Math.round(result).toString() : result.toFixed(14).replace(/\.?0+$/, '');
                        
                        steps.push(`结果: ${finalResult}`);
                        steps.push(`注: Romberg积分精度可达1e-12, 是外推法的巅峰`);
                        
                        return {
                            expression: finalResult,
                            copyText: finalResult,
                            steps: steps,
                            operation: 'n_definite_integral',
                            variables: variables,
                            limits: limits,
                            originalExpression: expr,
                            integralOrder: n
                        };
                    } catch (error) {
                        return {
                            expression: '计算失败',
                            copyText: '计算失败',
                            steps: [`错误: ${error.message}`],
                            error: error.message,
                            operation: 'n_definite_integral',
                            variables: variables || [],
                            limits: limits || [],
                            originalExpression: expr
                        };
                    }
                }
                
                // 大于5维使用异步计算，返回一个Promise
                return new Promise((resolve, reject) => {
                    try {
                        // 创建计算任务，使用setTimeout分块执行，避免阻塞主线程
                        const executeCalculation = () => {
                            // === 策略1: 高维改进Halton序列 (6维+) - 异步版本 ===
                            if (strategy === 'halton') {
                                steps.push(`策略: 改进Halton序列 (准蒙特卡洛+Faure置换, 收敛O(1/N))`);
                                
                                const samples = Math.max(1000, Math.min(100000000, userSamples));
                                const volume = numericLimits.reduce((prod, lim) => prod * (lim.upper - lim.lower), 1);
                                
                                steps.push(`采样数: ${samples.toLocaleString()}, 体积: ${volume.toFixed(6)}`);
                                
                                // 改进的Halton序列 (打乱以减少相关性)
                                const primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97];
                                
                                const halton = (index, dim) => {
                                    const base = primes[dim % primes.length];
                                    let result = 0;
                                    let f = 1;
                                    let i = index + 1; // 从1开始避免0点
                                    
                                    while (i > 0) {
                                        f = f / base;
                                        result += f * (i % base);
                                        i = Math.floor(i / base);
                                    }
                                    
                                    // 添加Faure置换减少相关性
                                    return (result + 0.5 * (dim * 0.618033988749895 % 1)) % 1;
                                };
                                
                                // 异步分批计算
                                const batchSize = 10000; // 减小批次大小，提高响应性
                                let sum = 0;
                                let processedBatches = 0;
                                const totalBatches = Math.ceil(samples / batchSize);
                                
                                // 显示初始进度
                                this.showProgress(0, `开始计算 ${samples.toLocaleString()} 个采样点...`);
                                
                                const processBatch = () => {
                                    // 检查是否已取消计算
                                    if (this.cancelCalculation) {
                                        this.hideProgress();
                                        reject(new Error('计算已由用户取消'));
                                        return;
                                    }
                                    
                                    const startBatch = processedBatches * batchSize;
                                    const endBatch = Math.min(startBatch + batchSize, samples);
                                    
                                    let batchSum = 0;
                                    for (let i = startBatch; i < endBatch; i++) {
                                        // 在每个采样点处理前检查是否取消
                                        if (this.cancelCalculation) {
                                            this.hideProgress();
                                            reject(new Error('计算已由用户取消'));
                                            return;
                                        }
                                        
                                        const evalScope = { ...scope };
                                        
                                        numericLimits.forEach((lim, d) => {
                                            const u = halton(i, d);
                                            evalScope[lim.variable] = lim.lower + u * (lim.upper - lim.lower);
                                        });
                                        
                                        batchSum += math.evaluate(processedExpr, evalScope);
                                    }
                                    
                                    sum += batchSum;
                                    processedBatches++;
                                    
                                    // 更新进度
                                    const progress = (processedBatches / totalBatches) * 100;
                                    this.showProgress(progress, `已处理 ${processedBatches * batchSize.toLocaleString()} / ${samples.toLocaleString()} 采样点`);
                                    
                                    if (processedBatches < totalBatches) {
                                        // 使用setTimeout让出控制权，保持页面响应
                                        setTimeout(processBatch, 0);
                                    } else {
                                        // 计算完成
                                        const result = volume * sum / samples;
                                        const finalResult = Math.abs(result - Math.round(result)) < 1e-9 ? 
                                            Math.round(result).toString() : result.toFixed(14).replace(/\.?0+$/, '');
                                        
                                        steps.push(`结果: ${finalResult}`);
                                        steps.push(`注: Halton+Faure置换减少相关性, 精度优于纯Halton`);
                                        
                                        this.hideProgress();
                                        
                                        resolve({
                                            expression: finalResult, copyText: finalResult, steps,
                                            operation: 'n_definite_integral', variables, limits,
                                            originalExpression: expr, integralOrder: n
                                        });
                                    }
                                };                                
                                // 开始第一批处理
                                setTimeout(processBatch, 10);
                                return;
                            }
                        };
                        
                        // 开始计算（延迟一小段时间，确保UI更新）
                        setTimeout(executeCalculation, 10);
                        
                    } catch (error) {
                        this.hideProgress();
                        resolve({
                            expression: '计算失败',
                            copyText: '计算失败',
                            steps: [`错误: ${error.message}`],
                            error: error.message,
                            operation: 'n_definite_integral',
                            variables: variables || [],
                            limits: limits || [],
                            originalExpression: expr
                        });
                    }
                });
            },
            
            // 显示进度条
            showProgress(percentage, message) {
                const outputDiv = App.elements.outputDiv;
                if (!this.progressDiv) {
                    this.progressDiv = document.createElement('div');
                    this.progressDiv.className = 'progress-container';
                    this.progressDiv.innerHTML = `
                        <div class="progress-bar">
                            <div class="progress-fill"></div>
                        </div>
                        <div class="progress-message"></div>
                        <button class="progress-cancel">取消计算</button>
                    `;
                    
                    // 添加进度条样式
                    if (!document.getElementById('progress-styles')) {
                        const style = document.createElement('style');
                        style.id = 'progress-styles';
                        style.textContent = `
                            .progress-container {
                                background: white;
                                border-radius: 8px;
                                padding: 20px;
                                margin-bottom: 20px;
                                box-shadow: 0 3px 10px rgba(0,0,0,0.1);
                            }
                            .progress-bar {
                                width: 100%;
                                height: 20px;
                                background: #f0f0f0;
                                border-radius: 10px;
                                overflow: hidden;
                                margin-bottom: 10px;
                            }
                            .progress-fill {
                                height: 100%;
                                background: linear-gradient(90deg, #3498db, #2ecc71);
                                width: 0%;
                                transition: width 0.3s ease;
                            }
                            .progress-message {
                                text-align: center;
                                margin-bottom: 10px;
                                font-size: 14px;
                                color: #666;
                            }
                            .progress-cancel {
                                display: block;
                                margin: 0 auto;
                                padding: 8px 16px;
                                background: #e74c3c;
                                color: white;
                                border: none;
                                border-radius: 4px;
                                cursor: pointer;
                                font-size: 14px;
                            }
                            .progress-cancel:hover {
                                background: #c0392b;
                            }
                        `;
                        document.head.appendChild(style);
                    }
                    
                    // 添加取消按钮事件
                    const cancelBtn = this.progressDiv.querySelector('.progress-cancel');
                    cancelBtn.addEventListener('click', () => {
                        this.cancelCalculation = true;
                        // 不立即隐藏进度条，等待计算函数检测到取消标志
                        this.showProgress(0, '正在取消计算...');
                    });
                    
                    outputDiv.innerHTML = '';
                    outputDiv.appendChild(this.progressDiv);
                }
                
                this.progressDiv.querySelector('.progress-fill').style.width = `${percentage}%`;
                this.progressDiv.querySelector('.progress-message').textContent = message;
            },
            
            // 隐藏进度条
            hideProgress() {
                if (this.progressDiv) {
                    this.progressDiv.remove();
                    this.progressDiv = null;
                }
                this.cancelCalculation = false;
            },
            
            // 积分项处理函数 (已修改：增强分数/整数显示，增加 exp(x)ln(x) 规则)
            integrateTerm(term, varName, sign = 1) {
                const parsedTerm = math.parse(term.toString());
                let nodeToIntegrate = parsedTerm;
                let coefficientNode = new math.ConstantNode(sign);
                let variableFound = false;

                // 1. 尝试将 term 拆分为 Coefficient * FunctionOf(varName)
                if (parsedTerm.type === 'OperatorNode' && parsedTerm.op === '*') {
                    let varParts = [];
                    let constParts = [];
                    parsedTerm.args.forEach(arg => {
                        // Includes variable parts OR symbolic constants that are NOT pi or e
                        if (arg.toString().includes(varName) || (arg.type === 'SymbolNode' && arg.name !== 'pi' && arg.name !== 'e')) {
                            varParts.push(arg);
                            variableFound = true;
                        } else {
                            constParts.push(arg);
                        }
                    });
                    
                    if (varParts.length > 0) {
                        nodeToIntegrate = varParts.length === 1 ? varParts[0] : new math.OperatorNode('*', 'multiply', varParts);
                        variableFound = true;
                        coefficientNode = constParts.length > 1 ? new math.OperatorNode('*', 'multiply', constParts) : (constParts.length === 1 ? constParts[0] : new math.ConstantNode(1));
                    } else {
                        variableFound = false;
                        nodeToIntegrate = parsedTerm;
                        coefficientNode = new math.ConstantNode(1);
                    }
                } else if (parsedTerm.toString().includes(varName)) {
                    variableFound = true;
                } else if (parsedTerm.type === 'ConstantNode' || (parsedTerm.type === 'SymbolNode' && parsedTerm.name !== varName)) {
                    variableFound = false;
                }
                
                // 提取系数（包含初始 sign）
                const initialCoeff = math.evaluate(coefficientNode.toString()) * sign;
                
                // Rule 4: Special Case: ∫ e^x * ln(x) dx (非初等函数积分)
                if (nodeToIntegrate.type === 'OperatorNode' && nodeToIntegrate.op === '*' && nodeToIntegrate.args.length === 2) {
                    const args = nodeToIntegrate.args.map(a => a.toString());
                    // 预处理中 ln(x) 变成了 log(x)
                    const hasExpX = args.includes(`exp(${varName})`); 
                    const hasLogX = args.includes(`log(${varName})`); 

                    if (hasExpX && hasLogX) {
                        // Result: Coeff * ( exp(x) * log(x) - ∫ (exp(x)/x) dx )
                        
                        const absCoeffFormatted = this.formatCoefficient(Math.abs(initialCoeff));
                        const signStr = initialCoeff >= 0 ? '+' : '-';
                        
                        let result = `${signStr} ${absCoeffFormatted}*(exp(${varName})*log(${varName}) - integral_exp_over_x(${varName}))`;
                        
                        // Clean up: 1*(...) -> (...)
                        result = result.replace(/^(\+|-)\s*1\*(.*)$/, '$1 $2').replace(/\s+/g, ' ');
                        
                        return result;
                    }
                }

                // Rule 1: 常数积分
                if (!variableFound) {
                    let termPart = nodeToIntegrate.toString(); // e.g. '13288' or 'y'
                    
                    // **修复: 积分常数项系数为1时的显示问题**
                    let absCoeffFormatted;
                    if (Math.abs(initialCoeff - 1) < this.tolerance) {
                         absCoeffFormatted = ''; // 系数为 1，显示空
                    } else if (Math.abs(initialCoeff + 1) < this.tolerance) {
                         absCoeffFormatted = ''; // 系数为 -1，显示空 (符号在 signStr 中处理)
                    } else {
                         absCoeffFormatted = this.formatCoefficient(Math.abs(initialCoeff), true);
                    }
                    
                    const signStr = initialCoeff >= 0 ? '+' : '-';

                    // **修复: 如果 termPart 以数字结尾，保留完整的项**
                    // 例如 321 应该保留为 321x，而不是 32x
                    if (nodeToIntegrate.type === 'ConstantNode') {
                        // 对于纯数字常数，直接使用该数字
                        termPart = termPart;
                    } else if (termPart !== '1') {
                        // 符号常数 (e, pi, sqrt(3)) 或其他变量 (y)
                        termPart = `${termPart}*`;
                    }
                    
                    // 如果系数非空，则添加系数，否则只保留 termPart
                    let termContent = absCoeffFormatted === '' ? termPart : `${absCoeffFormatted}${termPart}`;
                    
                    let result = `${signStr} ${termContent}${varName}`;
                    result = result.replace(/1\*/g, '').replace(/\*1/g, '').replace(/\s+/g, ' '); // 清理 1*
                    
                    return result;
                }
                
                // Rule 2.1: 幂函数积分: ∫ u^n du = u^(n+1)/(n+1)
                if (nodeToIntegrate.type === 'SymbolNode' && nodeToIntegrate.name === varName) {
                    // x^1 积分
                    const n = 1;
                    const newExponent = n + 1;
                    const newCoeff = initialCoeff / newExponent;
                    
                    const signStr = newCoeff >= 0 ? '+' : '-';
                    const absFormattedCoeff = this.formatCoefficient(Math.abs(newCoeff));
                    
                    let finalTerm = `${absFormattedCoeff}*${varName}^${newExponent}`;
                    finalTerm = finalTerm.replace(/^1\*/, '').replace(/\*1/, '');
                    
                    return `${signStr} ${finalTerm}`;
                }
                
                if (nodeToIntegrate.type === 'OperatorNode' && nodeToIntegrate.op === '^' && nodeToIntegrate.args.length === 2) {
                    const base = nodeToIntegrate.args[0];
                    const exponent = nodeToIntegrate.args[1];
                    
                    if (base.type === 'SymbolNode' && base.name === varName && exponent.type === 'ConstantNode') {
                        const n = exponent.value;
                        if (n !== -1) {
                            const newExponent = n + 1;
                            const newCoeff = initialCoeff / newExponent;
                            
                            const signStr = newCoeff >= 0 ? '+' : '-';
                            const absFormattedCoeff = this.formatCoefficient(Math.abs(newCoeff));
                            
                            let finalTerm = `${absFormattedCoeff}*${varName}^${newExponent}`;
                            finalTerm = finalTerm.replace(/^1\*/, '').replace(/\*1/, '');
                            
                            return `${signStr} ${finalTerm}`;
                        }
                    }
                }
                
                // Rule 2.2: 1/u 形式积分 (ln): ∫ 1/u du = log|u| (增强的 ln 积分支持)
                if (nodeToIntegrate.type === 'OperatorNode' && nodeToIntegrate.op === '/' && nodeToIntegrate.args.length === 2) {
                    const numerator = nodeToIntegrate.args[0];
                    const denominator = nodeToIntegrate.args[1];
                    
                    if (denominator.toString().includes(varName) && (numerator.type === 'ConstantNode' || numerator.type === 'SymbolNode' && !numerator.toString().includes(varName))) {
                        const constPart = numerator.toString();
                        const finalCoeff = initialCoeff * math.evaluate(constPart);
                        
                        const signStr = finalCoeff >= 0 ? '+' : '-';
                        const absFormattedCoeff = this.formatCoefficient(Math.abs(finalCoeff));
                        
                        const denomString = denominator.toString().replace(/[\(\)]/g, '');
                        
                        let finalTerm = `${absFormattedCoeff}*log(abs(${denomString}))`;
                        finalTerm = finalTerm.replace(/^1\*/, '').replace(/\*1/, '');
                        
                        return `${signStr} ${finalTerm}`;
                    }
                }
                
                // Rule 2.3: 特殊函数积分
                if (nodeToIntegrate.type === 'FunctionNode' && nodeToIntegrate.args[0].type === 'SymbolNode' && nodeToIntegrate.args[0].name === varName) {
                    const funcName = nodeToIntegrate.name;
                    let integral = null;
                    let multiplier = 1;
                    switch(funcName) {
                        case 'sin': integral = `cos(${varName})`; multiplier = -1; break;
                        case 'cos': integral = `sin(${varName})`; break;
                        case 'exp': integral = `exp(${varName})`; break;
                        case 'log': // log(x) 积分是 x*ln(x) - x
                            integral = `${varName}*log(${varName}) - ${varName}`; 
                            break;
                    }
                    
                    if (integral) {
                        const finalCoeff = initialCoeff * multiplier;
                        const signStr = finalCoeff >= 0 ? '+' : '-';
                        const absFormattedCoeff = this.formatCoefficient(Math.abs(finalCoeff));
                        
                        let finalTerm = `${absFormattedCoeff}*(${integral})`;
                        finalTerm = finalTerm.replace(/^1\*/, '').replace(/\*1/, '');
                        
                        return `${signStr} ${finalTerm}`;
                    }
                }
                
                // Rule 3: 默认情况下，返回原始项 (如果无法积分)
                const signStr = initialCoeff >= 0 ? '+' : '-';
                const absCoeffFormatted = this.formatCoefficient(Math.abs(initialCoeff));
                
                let finalTerm = `${absCoeffFormatted}*${nodeToIntegrate.toString()}`;
                finalTerm = finalTerm.replace(/^1\*/, '').replace(/\*1/, '');
                
                return `${signStr} ${finalTerm}`;
            },
            
            // 表达式化简 (新增无穷大项分离逻辑)
            calculateSimplify(expr, varName) {
                // 调试信息
                console.log('=== calculateSimplify 函数调试 ===');
                console.log('输入表达式:', expr);
                
                // 使用预处理表达式用于显示（包含X乘法处理）
                const displayExpr = this.preprocessExpressionForDisplay(expr);
                const steps = [`原表达式: ${this.formatExpressionForDisplay(displayExpr)}`];
                
                // 1. 检查是否为纯常数表达式 (e, pi, sqrt(3) 都是常数)
                // 纯常数表达式：不包含变量且不包含虚数
                const isPureConstantExpression = this.isConstantExpression(expr) && !expr.includes(varName) && !this.containsImaginary(expr);
                console.log('isPureConstantExpression:', isPureConstantExpression);

                // 2. 分离无穷大项
                const allTerms = [];
                try {
                    this.extractTerms(math.parse(expr), allTerms);
                } catch (e) {
                    throw new Error(`无法解析表达式进行化简: ${e.message}`);
                }
                const { finiteTerms, infiniteTerms } = this.getInfiniteTerms(expr, varName);
                
                let simplified = '0';
                let finiteExpr = '';

                if (finiteTerms.length > 0) {
                    if (isPureConstantExpression && infiniteTerms.length === 0) {
                        
                        // **FIX 1: 纯常数表达式，步骤1保留符号形式**
                        // 使用 mergeLikeTerms 确保数字常数 (如 5+2) 被合并，但 e, pi, sqrt(3) 保持符号形式
                        finiteExpr = this.mergeLikeTerms(expr, varName);
                        simplified = finiteExpr; 
                        
                        steps.push(`步骤1: 分离无穷大项后的有限部分 (符号保留): ${this.cleanMathJSText(finiteExpr)}`);

                        // 步骤 2, 3, 4: 跳过复杂的符号化简，以保留 e/pi/sqrt 等形式
                        steps.push(`步骤2: 合并同类项: 跳过 (已在步骤1中合并数字常量)`);
                        steps.push(`步骤3: 符号运算简化: 跳过`);
                        steps.push(`步骤4: 展开多项式: 跳过`);

                        // **FIX 2: 最终数值合并**
                        // 使用math.js计算表达式，支持虚数和π符号
                        const scope = { pi: math.pi, e: math.e, i: math.i };
                        
                        // 调试信息
                        console.log('=== 纯常数表达式数值合并调试 ===');
                        console.log('finiteExpr:', finiteExpr);
                        
                        // 检查表达式是否包含虚数单位i
                        const containsImaginaryUnit = /(^|\W|[-+*\/])(\d*\.*\d*)\s*i\s*($|\W|[-+*\/])(?![a-zA-Z])/.test(finiteExpr) ||
                                                 /(sin|cos|tan|cot|sec|csc|asin|acos|atan|log|ln|lg|sqrt|exp)\s*\(\s*[^)]*i[^)]*\)/.test(finiteExpr);
                        
                        console.log('containsImaginaryUnit:', containsImaginaryUnit);
                        
                        // 如果表达式包含虚数单位i，不进行计算，保持符号形式
                        if (containsImaginaryUnit) {
                            console.log('表达式包含虚数单位，保持符号形式');
                            simplified = finiteExpr;
                        } else {
                            console.log('表达式不包含虚数单位，检查是否有无穷大项');
                            // 检查是否有无穷大项
                            const { infiniteTerms } = this.getInfiniteTerms(finiteExpr, varName);
                            
                            if (infiniteTerms.length > 0) {
                                console.log('表达式包含无穷大项，使用智能求值');
                                simplified = this.intelligentEvaluate(finiteExpr, scope);
                            } else {
                                console.log('表达式不包含无穷大项，进行数值计算');
                                const result = math.evaluate(finiteExpr, scope);
                                console.log('math.evaluate 结果:', result);
                                
                                // 检查结果是否是复数
                                if (typeof result === 'object' && result !== null && 're' in result && 'im' in result) {
                                    // 复数结果，使用formatComplexNumber格式化
                                    simplified = this.formatComplexNumber(result);
                                } else if (result.toString().includes('i')) {
                                    // 字符串形式的复数
                                    simplified = result.toString();
                                } else {
                                    // 实数结果，格式化为数值
                                    simplified = result.toFixed(6).replace(/\.?0+$/, '');
                                }
                            }
                        }
                        
                        steps.push(`步骤5: 最终数值合并: ${this.cleanMathJSText(simplified)}`);

                    } else {
                        // 包含变量或无穷大项，使用标准流程
                        finiteExpr = this.reconstructExpression(finiteTerms);
                        simplified = finiteExpr; 
                    
                        steps.push(`步骤1: 分离无穷大项后的有限部分: ${this.cleanMathJSText(finiteExpr)}`);
    
                        // 2.1. 简化有理函数
                        simplified = this.simplifyRationalFunction(simplified, varName);
                        
                        // 2.2. 合并同类项
                        const merged = this.mergeLikeTerms(simplified, varName);
                        if (merged !== simplified) {
                            steps.push(`步骤2: 合并同类项: ${this.cleanMathJSText(merged)}`);
                        } else if (simplified !== finiteExpr) {
                             steps.push(`步骤2: 合并同类项: ${this.cleanMathJSText(merged)}`);
                        } else {
                            steps.push(`步骤2: 合并同类项: ${this.cleanMathJSText(merged)}`);
                        }
                        simplified = merged;
                        
                        // 2.3. 尝试 math.js 自动简化
                        const originalSimplified = simplified;
                        // 如果有无穷大项，不调用 math.simplify，避免将表达式转换为 "Infinity"
                        if (infiniteTerms.length > 0) {
                            steps.push(`步骤3: 符号运算简化: 跳过 (存在无穷大项)`);
                        } else {
                            try {
                                const mathSimplified = math.simplify(simplified).toString();
                                if (mathSimplified !== originalSimplified) {
                                     steps.push(`步骤3: 符号运算简化: ${this.cleanMathJSText(mathSimplified)}`);
                                }
                                simplified = mathSimplified;
                            } catch (e) {
                                steps.push(`步骤3: 符号运算简化: 无法进行更深层简化。`);
                            }
                        }
                        
                        // 2.6. 新增：智能求值，分别处理包含虚数的项和纯常数项
                        if (infiniteTerms.length > 0 && this.isConstantExpression(simplified)) {
                            // 定义求值作用域
                            const scope = { pi: math.pi, e: math.e, i: math.i };
                            // 使用智能求值函数
                            simplified = this.intelligentEvaluate(simplified, scope);
                            steps.push(`步骤4: 有限项数值求值: ${this.cleanMathJSText(simplified)}`);
                        }
                        
                        // 2.4. 尝试展开
                        const expanded = this.expandPolynomial(simplified, varName);
                        if (expanded !== simplified) {
                            steps.push(`步骤4: 展开多项式: ${this.cleanMathJSText(expanded)}`);
                        } else {
                             steps.push(`步骤4: 展开多项式: 跳过`);
                        }
                        simplified = expanded;
                        
                        // 2.5. 最终合并同类项
                        const finalMerged = this.mergeLikeTerms(simplified, varName);
                        if (finalMerged !== simplified) {
                            steps.push(`步骤5: 最终合并同类项: ${this.cleanMathJSText(finalMerged)}`);
                        } else {
                             steps.push(`步骤5: 最终合并同类项: ${this.cleanMathJSText(finalMerged)}`);
                        }
                        simplified = finalMerged;
                    }
                } else {
                    steps.push('步骤1: 有限部分结果为零。');
                    simplified = '0';
                }
                
                // 3. 添加无穷大项到结果
                const finalResult = this.appendInfiniteTerms(simplified, infiniteTerms);
                
                const copyText = `${finalResult.copyText}`;
                return { expression: finalResult.expression, steps, copyText };
            },
            
            // 表达式求值 (新增无穷大项分离逻辑)
            evaluateExpression(expr) {
                const variable = App.elements.variableInput.value.trim() || 'x';
                const steps = [`表达式: ${this.formatExpressionForDisplay(expr)}`];
                const scope = {};
                const inputs = App.elements.variableInputs.querySelectorAll('input');
                inputs.forEach(input => {
                    const varName = input.id.replace('var-', '');
                    scope[varName] = parseFloat(input.value) || 0;
                });
                
                // 确保 scope 包含常数
                scope.pi = math.pi;
                scope.e = math.e;
                scope.i = math.i; // 新增：支持虚数单位

                const scopeDisplay = Object.entries(scope).map(([key, value]) => `${key} = ${value}`).join(', ');
                steps.push(`步骤1: 变量赋值: { ${scopeDisplay} }`);

                // 1. 分离无穷大项
                const allTerms = [];
                try {
                    this.extractTerms(math.parse(expr), allTerms);
                } catch (e) {
                    throw new Error(`无法解析表达式进行求值: ${e.message}`);
                }
                const { finiteTerms, infiniteTerms } = this.getInfiniteTerms(expr, variable);
                
                const finiteExpr = this.reconstructExpression(finiteTerms);
                
                let result;
                if (finiteExpr === '0') {
                    result = '0'; // Only infinite terms
                } else {
                    try {
                        // 2. 评估有限部分
                        const compiled = math.compile(finiteExpr);
                        result = compiled.evaluate(scope);
                    } catch (error) {
                        throw new Error(`步骤2: 有限部分求值失败: ${error.message}`);
                    }
                }

                steps.push(`步骤2: 有限部分结果: ${result.toString()}`);

                // 3. 添加无穷大项到结果
                const finalResult = this.appendInfiniteTerms(result.toString(), infiniteTerms);
                
                const copyText = `${finalResult.copyText}`;
                return { expression: finalResult.expression, steps, copyText };
            },
            
            // 提取加减项 (不变)
            extractTerms(node, terms, sign = 1) {
                if (node.type === 'OperatorNode') {
                    if (node.op === '+') {
                        node.args.forEach(arg => this.extractTerms(arg, terms, sign));
                    } else if (node.op === '-') {
                        if (node.args.length === 1) { // 负号作为一元运算符 (e.g. -x)
                            this.extractTerms(node.args[0], terms, -sign);
                        } else { // 减法作为二元运算符 (e.g. x - y)
                            this.extractTerms(node.args[0], terms, sign);
                            this.extractTerms(node.args[1], terms, -sign);
                        }
                    } else {
                        terms.push({ node, sign });
                    }
                } else if (node.type === 'ParenthesisNode') {
                    this.extractTerms(node.content, terms, sign);
                } else {
                    terms.push({ node, sign });
                }
            },
            
            // 合并项 (已修改：防止 e, pi 等常数被错误地视为变量)
            mergeTerms(terms, varName) {
                const merged = new Map();
                const tolerance = this.tolerance;
                
                terms.forEach(term => {
                    let coefficient = term.sign;
                    let variablePart = '';
                    let isConstant = false;
                    let mergeKey = '';
                    
                    if (term.node.type === 'ConstantNode') {
                        // 纯数字常数
                        coefficient *= term.node.value;
                        isConstant = true;
                        mergeKey = '_NUMERICAL_CONSTANT_'; // 特殊键用于合并所有纯数字
                        variablePart = mergeKey;
                    } else if (term.node.type === 'SymbolNode') {
                        if (term.node.name === varName) {
                            // 变量
                            variablePart = varName;
                            mergeKey = varName;
                        } else if (['pi', 'e'].includes(term.node.name)) {
                            // 数学常数 (符号常数)，不进行数值合并，保持符号唯一
                            isConstant = true;
                            variablePart = term.node.name;
                            mergeKey = term.node.name;
                        } else if (term.node.name === 'i') {
                            // 虚数单位特殊处理：i 视为变量部分，系数合并
                            variablePart = 'i';
                            mergeKey = 'i';
                        } else {
                            // 其他符号常数 (例如 y, a)
                            isConstant = true;
                            variablePart = term.node.name;
                            mergeKey = term.node.name;
                        }
                    } else if (term.node.type === 'OperatorNode' && term.node.op === '*') {
                        // 尝试分离系数和变量部分
                        let varParts = [];
                        let constParts = [];
                        term.node.args.forEach(arg => {
                            // 检查是否包含变量名或无法计算的符号
                            if (arg.toString().includes(varName) || 
                                (arg.type === 'SymbolNode' && !['pi', 'e'].includes(arg.name) && arg.name !== varName) ||
                                (arg.type === 'FunctionNode' && arg.toString().includes(varName))
                            ) {
                                varParts.push(arg);
                            } else {
                                constParts.push(arg);
                            }
                        });
                        
                        // 组装系数 (数值常数和 e, pi)
                        try {
                            const coeffNode = constParts.length === 1 ? constParts[0] : new math.OperatorNode('*', 'multiply', constParts);
                            if (constParts.length > 0) {
                                // 评估常数部分，不包含虚数单位 i
                                coefficient *= math.evaluate(coeffNode.toString(), { pi: math.pi, e: math.e });
                            }
                        } catch (e) {
                            // 如果常数部分复杂到无法求值，将它们都视为变量部分
                            varParts = term.node.args;
                            coefficient = term.sign;
                            constParts = [];
                        }
                        
                        // 组装变量部分
                        variablePart = varParts.length === 1 ? varParts[0].toString() : (varParts.length > 1) ? varParts.map(n => n.toString()).join('*') : '';
                        
                        if (varParts.length === 0) {
                            isConstant = true;
                            mergeKey = '_NUMERICAL_CONSTANT_';
                            variablePart = mergeKey;
                        } else {
                            // 变量项的合并键是变量部分的标准化字符串
                            mergeKey = variablePart;
                        }
                        
                    } else if (term.node.type === 'FunctionNode' && !term.node.toString().includes(varName)) {
                         // 纯常数函数项 (如 sqrt(3), log(2)). 
                         // 必须在这里避免数值化，并保持符号形式作为变量部分。
                        isConstant = true;
                        variablePart = term.node.toString();
                        mergeKey = variablePart; 
                    }
                    else {
                        // 其他复杂结构，视为变量部分，系数为 1
                        variablePart = term.node.toString();
                        mergeKey = variablePart;
                    }
                    
                    // 标准化变量部分和合并键
                    if (!isConstant) {
                        try {
                            const parsedVar = math.parse(variablePart);
                            mergeKey = parsedVar.toString();
                        } catch (e) {
                            // 无法解析，保留原始字符串
                        }
                    }
                    
                    if (merged.has(mergeKey)) {
                        merged.get(mergeKey).coefficient += coefficient;
                    } else {
                        // 存储 originalTerm 以便在 reconstructExpression 中重建符号形式
                        merged.set(mergeKey, { variablePart: mergeKey, coefficient, originalTerm: term.node.toString() });
                    }
                });
                
                // 过滤系数接近零的项，并格式化输出
                const resultTerms = [];
                merged.forEach(term => {
                    if (Math.abs(term.coefficient) > tolerance) {
                        // 格式化常数项 (如果键不是纯数字常量，则尝试保留符号)
                        if (term.variablePart === '_NUMERICAL_CONSTANT_') {
                            resultTerms.push({ coefficient: term.coefficient, variablePart: '' });
                        } else {
                            // 对于符号常数 (e, pi, i, sqrt(3), y) 或变量项 (x, x^2)
                            // 重新设置 variablePart 为其符号形式，以便 reconstructExpression 使用
                            resultTerms.push({ coefficient: term.coefficient, variablePart: term.variablePart });
                        }
                    }
                });
                
                // 将纯数值常数项（variablePart=''）移到最前面
                resultTerms.sort((a, b) => {
                    if (a.variablePart === '' && b.variablePart !== '') return -1;
                    if (a.variablePart !== '' && b.variablePart === '') return 1;
                    return 0;
                });
                
                // 重新构建表达式 (返回给 mergeLikeTerms)
                return resultTerms;
            },
            
            // 简化有理函数（例如 (x^2+1)/(x+1) -> x-1 + 2/(x+1)） (不变)
            simplifyRationalFunction(expr, varName) {
                let result = expr;
                // 1. 增强: 对 (x^2 + 1)/(x + 1) 的特殊处理
                // (x^2 + 1)/(x + 1) = x - 1 + 2/(x + 1)
                // 匹配 (x^2 + 1) / (x + 1) 或其带有空格的变体
                const rationalPattern = new RegExp(`\\( *${varName} *\\^ *2 *\\+ *1 *\\) *\\/ *\\( *${varName} *\\+ *1 *\\)`, 'g');
                if (rationalPattern.test(expr)) {
                    // 替换为代数分解形式，使用括号确保优先级
                    result = result.replace(rationalPattern, `(${varName} - 1 + 2 / (${varName} + 1))`);
                }
                return result;
            },
            
            // 仅进行常数合并的同类项合并 (用于求导优化、化简步骤)
            mergeLikeTerms(expr, varName) {
                try {
                    const node = math.parse(expr);
                    const terms = [];
                    this.extractTerms(node, terms);
                    
                    // 重新构建表达式 (使用修复后的 reconstructExpression)
                    return this.reconstructExpression(terms);

                } catch (error) {
                    // 解析失败，返回原始表达式
                    return expr;
                }
            },
            
            // 展开多项式 (不变)
            expandPolynomial(expr, varName) {
                try {
                    // 1. 尝试使用 math.js 的 simplify 配合 rule 展开
                    const node = math.parse(expr);
                    
                    // 2. 递归展开 (a+b)^n 形式
                    const expandedNode = this.expandNode(node, varName);
                    
                    // 3. 最终简化
                    return math.simplify(expandedNode).toString();
                } catch (error) {
                    return expr;
                }
            },
            
            expandNode(node, varName) {
                if (node.type === 'OperatorNode' && node.op === '^') {
                    const base = node.args[0];
                    const exponent = node.args[1];
                    
                    if (exponent.type === 'ConstantNode' && Number.isInteger(exponent.value) && exponent.value >= 2) {
                        let baseContent = base;
                        if (base.type === 'ParenthesisNode') {
                            baseContent = base.content;
                        }
                        
                        if (baseContent.type === 'OperatorNode' && baseContent.op === '+') {
                            // 仅支持两个参数 (a+b)^n
                            if (baseContent.args.length === 2) {
                                return this.expandBinomial(baseContent.args[0], baseContent.args[1], exponent.value);
                            }
                        }
                    }
                }
                
                // 递归处理子节点
                if (node.args) {
                    const expandedArgs = node.args.map(arg => this.expandNode(arg, varName));
                    return new math.OperatorNode(node.op, node.fn, expandedArgs, node.implicit);
                }
                return node;
            },
            
            expandBinomial(a, b, n) {
                let result = null;
                for (let k = 0; k <= n; k++) {
                    const coefficient = this.binomialCoefficient(n, k);
                    
                    // a^k
                    const termA = k === 0 ? new math.ConstantNode(1) : k === 1 ? a : new math.OperatorNode('^', 'pow', [a, new math.ConstantNode(k)]);
                    
                    // b^(n-k)
                    const termB = (n - k) === 0 ? new math.ConstantNode(1) : (n - k) === 1 ? b : new math.OperatorNode('^', 'pow', [b, new math.ConstantNode(n - k)]);
                    
                    let termParts = [termA, termB].filter(part => part.toString() !== '1');
                    
                    if (coefficient !== 1) {
                        termParts.unshift(new math.ConstantNode(coefficient));
                    }
                    
                    let term;
                    if (termParts.length === 0) {
                        term = new math.ConstantNode(1);
                    } else if (termParts.length === 1) {
                        term = termParts[0];
                    } else {
                        // 创建乘积节点
                        term = new math.OperatorNode('*', 'multiply', termParts);
                    }
                    
                    if (result === null) {
                        result = term;
                    } else {
                        result = new math.OperatorNode('+', 'add', [result, term]);
                    }
                }
                
                // 确保结果被 math.js 简化
                return math.simplify(result);
            },
            
            binomialCoefficient(n, k) {
                if (k < 0 || k > n) {
                    return 0;
                }
                if (k === 0 || k === n) {
                    return 1;
                }
                if (k > n / 2) {
                    k = n - k;
                }
                let res = 1;
                for (let i = 1; i <= k; i++) {
                    res = res * (n - i + 1) / i;
                }
                return res;
            },
            
            // 格式化输出表达式 (用于最终结果和所有步骤)
            formatExpressionForDisplay(text) {
                // 调试信息
                console.log('=== formatExpressionForDisplay 函数调试 ===');
                console.log('输入文本:', text);
                
                let formattedText = text;

                // 0. 特殊处理对数导数格式，如 1/xln2【最终计算值/x】
                formattedText = formattedText.replace(/(\d+)\/(\w+)ln(\d+(?:\.\d+)?)【([^】]+)】/g, (match, numerator, variable, base, calc) => {
                    return `${numerator}/${variable}ln${base}【${calc}】`;
                });
                formattedText = formattedText.replace(/(\d+)\/(\w+)ln\(([^)]+)\)【([^】]+)】/g, (match, numerator, variable, base, calc) => {
                    return `${numerator}/${variable}ln(${base})【${calc}】`;
                });

                // 1. 保存函数参数中的内容，防止乘号被误删
                const functionContents = [];
                formattedText = formattedText.replace(/(\w+)\(([^)]+)\)/g, (match, func, content) => {
                    const index = functionContents.length;
                    functionContents.push(content);
                    console.log(`保存函数内容: ${func}(${content}) -> ${func}(__FUNC_CONTENT_${index}__)`);
                    return `${func}(__FUNC_CONTENT_${index}__)`;
                });
                
                console.log('步骤1后:', formattedText);
                
                // 2. exp(x) 转换为 e^(x) - 修复：使用占位符避免在恢复函数内容前被错误替换
                formattedText = formattedText.replace(/exp\(__FUNC_CONTENT_(\d+)__\)/g, '__EXP_PLACEHOLDER_$1__');
                formattedText = formattedText.replace(/(\d*\.?\d*)\s*\*\s*exp\(__FUNC_CONTENT_(\d+)__\)/g, '$1*__EXP_PLACEHOLDER_$2__');
                
                // 3. **关键修正: 任意底对数 log(v, b) 转换为 log_b(v)**
                console.log('步骤3前:', formattedText);
                
                // 替换 log(v, b) 格式（注意：$1是真数，$2是底数）
                const beforeLogVb = formattedText;
                formattedText = formattedText.replace(/log\(__FUNC_CONTENT_(\d+)__,\s*__FUNC_CONTENT_(\d+)__\)/g, 'log<sub>$2</sub>($1)');
                console.log('log(v,b)替换:', beforeLogVb, '->', formattedText);
                
                // 替换 logbase(b, v) 占位符格式（来自 cleanMathJSText）（注意：$1是底数，$2是真数）
                const beforeLogbase = formattedText;
                formattedText = formattedText.replace(/logbase\(__FUNC_CONTENT_(\d+)__,\s*__FUNC_CONTENT_(\d+)__\)/g, 'log<sub>$1</sub>($2)');
                console.log('logbase替换:', beforeLogbase, '->', formattedText);
                
                console.log('步骤3后 (log(v,b)转换):', formattedText);
                
                // 4. log10(v) 转换为 lg(v)
                formattedText = formattedText.replace(/log10\(__FUNC_CONTENT_(\d+)__\)/g, 'lg($1)');
                
                console.log('步骤4后 (log10转换):', formattedText);
                
                // 5. log(v) 转换为 ln(v)
                // 修复：只转换单参数的log，避免影响双参数的log函数和log(底数)(真数)格式
                const logsToConvert = [];
                formattedText = formattedText.replace(/log\(__FUNC_CONTENT_(\d+)__\)(?!<sub>)(?!\s*\()/g, (match, contentIndex) => {
                    // 检查函数内容是否包含逗号，如果包含逗号则是双参数log，不转换
                    const content = functionContents[parseInt(contentIndex)];
                    if (content && content.includes(',')) {
                        console.log(`跳过双参数log: log(${content})`);
                        return match; // 不转换双参数log
                    }
                    
                    // 检查这个log后面是否跟着另一个括号，如果是log(底数)(真数)格式，不转换
                    const nextCharIndex = formattedText.indexOf(match) + match.length;
                    if (nextCharIndex < formattedText.length && formattedText[nextCharIndex] === '(') {
                        console.log(`跳过log(底数)(真数)格式: ${match}(...)`);
                        return match; // 不转换log(底数)(真数)格式
                    }
                    
                    const index = logsToConvert.length;
                    logsToConvert.push(contentIndex);
                    console.log(`标记需要转换的log: ${match} -> __LOG_TO_CONVERT_${index}__`);
                    return `__LOG_TO_CONVERT_${index}__`;
                });
                
                console.log('步骤5.1后 (标记需要转换的log):', formattedText);
                
                // 然后转换标记的log为ln
                logsToConvert.forEach((contentIndex, index) => {
                    formattedText = formattedText.replace(`__LOG_TO_CONVERT_${index}__`, `ln(__FUNC_CONTENT_${contentIndex}__)`);
                    console.log(`转换log为ln: __LOG_TO_CONVERT_${index}__ -> ln(__FUNC_CONTENT_${contentIndex}__)`);
                });
                
                console.log('步骤5.2后 (log转换ln):', formattedText);
                
                // 6. 修复：保留数字之间的乘法符号，移除其他情况下的乘号符号
                // 保留数字之间的乘法：3*2 -> 3*2
                // 移除函数和变量之间的乘法：sin(x)*y -> sin(x)y
                // 移除常数和变量之间的乘法：3*x -> 3x
                // 注意：这里不再移除所有乘号，而是只移除特定情况下的乘号
                formattedText = formattedText.replace(/([a-zA-Z\)\)])\*([a-zA-Z\(])/g, '$1$2'); // 函数/变量与函数/变量之间的乘号
                formattedText = formattedText.replace(/(\d)\*([a-zA-Z\(])/g, '$1$2'); // 数字与函数/变量之间的乘号
                formattedText = formattedText.replace(/([a-zA-Z\)\)])\*(\d)/g, '$1$2'); // 函数/变量与数字之间的乘号
                formattedText = formattedText.replace(/([a-zA-Z])\*(\d)/g, '$1$2'); // 单个变量与数字之间的乘号
                
                // 7. sqrt(v) 转换为 √v
                formattedText = formattedText.replace(/sqrt\(__FUNC_CONTENT_(\d+)__\)/g, '√($1)');
                
                // 8. pi 转换为 π
                formattedText = formattedText.replace(/pi/g, 'π');
                
                // 9. 新增: 非初等函数积分符号 ∫(e^x/x)dx
                formattedText = formattedText.replace(/integral_exp_over_x\(__FUNC_CONTENT_(\d+)__\)/g, '∫(e^($1)/$1)d$1'); 
                
                // 10. 恢复函数内容
                console.log('步骤10前 (恢复函数内容):', formattedText);
                formattedText = formattedText.replace(/__FUNC_CONTENT_(\d+)__/g, (match, index) => {
                    const content = functionContents[parseInt(index)];
                    console.log(`恢复函数内容: ${match} -> ${content}`);
                    return content;
                });
                
                // 10.5. 处理exp占位符，转换为e^()格式
                formattedText = formattedText.replace(/__EXP_PLACEHOLDER_(\d+)__/g, (match, index) => {
                    const content = functionContents[parseInt(index)];
                    console.log(`转换exp占位符: ${match} -> e^(${content})`);
                    // 如果内容为空或只是x，直接显示为e^x
                    if (content === 'x' || content.trim() === '') {
                        return `<span class="exponential">e^x</span>`;
                    }
                    return `<span class="exponential">e^(${content})</span>`;
                });
                
                // 11. 去除多余的空格，但保留乘号前后的空格
                formattedText = formattedText.replace(/\s+/g, ' '); // 将多个连续空格替换为单个空格
                formattedText = formattedText.replace(/\s*\(\s*/g, '('); // 去除括号前后的空格
                formattedText = formattedText.replace(/\s*\)\s*/g, ')'); // 去除右括号前后的空格
                formattedText = formattedText.replace(/\s*\+\s*/g, '+'); // 去除加号前后的空格
                formattedText = formattedText.replace(/\s*-\s*/g, '-'); // 去除减号前后的空格
                // 修复：不再移除乘号前后的空格，保留乘号
                // formattedText = formattedText.replace(/\s*\*\s*/g, ''); // 去除乘号前后的空格
                formattedText = formattedText.replace(/\s*\/\s*/g, '/'); // 去除除号前后的空格
                formattedText = formattedText.replace(/\s*\^\s*/g, '^'); // 去除幂号前后的空格
                formattedText = formattedText.replace(/\s*=\s*/g, '='); // 去除等号前后的空格
                formattedText = formattedText.replace(/^\s+|\s+$/g, ''); // 去除首尾空格
                
                console.log('最终格式化结果:', formattedText);
                return formattedText;
            },
            
            // 新增：格式化原始表达式，保留π和角度符号
            formatOriginalExpression(text) {
                let formattedText = text;
                
                // 清理HTML标签，防止在原始表达式中显示
                formattedText = formattedText.replace(/<[^>]*>/g, '');
                
                // 保留π符号
                formattedText = formattedText.replace(/pi/g, 'π');
                
                // 保留角度符号
                formattedText = formattedText.replace(/(\d+)°/g, '$1°');
                
                // 保留三角函数中的各种π表达式
                // 保留单个π
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(pi/g, '$1(π');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(π/g, '$1(π');
                
                // 保留数字*π形式 (如 2π, 3π)
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)\*pi/g, '$1($2π');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)\*π/g, '$1($2π');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)pi/g, '$1($2π');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)π/g, '$1($2π');
                
                // 保留π/数字形式 (如 π/2, π/3)
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(pi\/(\d+)/g, '$1(π/$2)');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(π\/(\d+)/g, '$1(π/$2)');
                
                // 保留数字*π/数字形式 (如 2π/3, 3π/2)
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)\*pi\/(\d+)/g, '$1($2π/$3)');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)\*π\/(\d+)/g, '$1($2π/$3)');
                
                // 保留直接跟在函数后的π形式 (如 sin2π, cos3π)
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)(\d+)pi/g, '$1$2π');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)(\d+)π/g, '$1$2π');
                
                // 新增：保留三角函数中的虚数单位i
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(\s*i\s*\)/g, '$1(i)');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)i\b/g, '$1(i)');
                
                // 格式化其他函数
                formattedText = formattedText.replace(/sqrt\(([^)]+)\)/g, '√($1)');
                formattedText = formattedText.replace(/log10\(([^)]+)\)/g, 'lg($1)');
                
                // 修复：确保只替换完整的log函数，避免截断参数
                // 但是不替换 log(底数)(真数) 格式，这种格式已经是最终显示格式
                formattedText = formattedText.replace(/\blog\(([^)]+)\)(?!\s*\()(?!\s*\()/g, 'ln($1)');
                
                // 修复：保留数字之间的乘法符号，移除其他情况下的乘号符号
                // 保留数字之间的乘法：3*2 -> 3*2
                // 移除函数和变量之间的乘法：sin(x)*y -> sin(x)y
                // 移除常数和变量之间的乘法：3*x -> 3x
                // 注意：这里不再移除所有乘号，而是只移除特定情况下的乘号
                formattedText = formattedText.replace(/([a-zA-Z\)\)])\*([a-zA-Z\(])/g, '$1$2'); // 函数/变量与函数/变量之间的乘号
                formattedText = formattedText.replace(/(\d)\*([a-zA-Z\(])/g, '$1$2'); // 数字与函数/变量之间的乘号
                formattedText = formattedText.replace(/([a-zA-Z\)\)])\*(\d)/g, '$1$2'); // 函数/变量与数字之间的乘号
                formattedText = formattedText.replace(/([a-zA-Z])\*(\d)/g, '$1$2'); // 单个变量与数字之间的乘号
                
                // 去除多余的空格
                formattedText = formattedText.replace(/\s+/g, ' '); // 将多个连续空格替换为单个空格
                formattedText = formattedText.replace(/\s*\(\s*/g, '('); // 去除括号前后的空格
                formattedText = formattedText.replace(/\s*\)\s*/g, ')'); // 去除右括号前后的空格
                formattedText = formattedText.replace(/\s*\+\s*/g, '+'); // 去除加号前后的空格
                formattedText = formattedText.replace(/\s*-\s*/g, '-'); // 去除减号前后的空格
                formattedText = formattedText.replace(/\s*\/\s*/g, '/'); // 去除除号前后的空格
                formattedText = formattedText.replace(/\s*\^\s*/g, '^'); // 去除幂号前后的空格
                formattedText = formattedText.replace(/\s*=\s*/g, '='); // 去除等号前后的空格
                formattedText = formattedText.replace(/^\s+|\s+$/g, ''); // 去除首尾空格
                
                return formattedText;
            },
            
            // 检测表达式是否包含对数函数
            containsLogarithm(expr) {
                // 检查各种对数格式：log(x), log(v, b), logN(v), log(底数)(真数)
                const logPatterns = [
                    /log\([^)]+\)/,           // log(x) 或 log(v, b)
                    /log\d+\([^)]+\)/,        // logN(v) 格式
                    /log\s*\([^)]+\)\s*\([^)]+\)/,  // log(底数)(真数) 格式（预处理前）
                    /log\([^,]+,\s*[^)]+\)/,  // log(v, b) 格式（预处理后）
                    /logbase\([^)]+\)/        // logbase 格式（在显示中出现）
                ];
                
                return logPatterns.some(pattern => pattern.test(expr));
            },
            
            // 计算对数函数的导数，保持ln格式
            calculateLogarithmDerivative(expr, varName) {
                console.log('计算对数导数，原始表达式:', expr);
                
                // 直接处理原始表达式，不进行预处理
                // 首先处理乘除法，再处理加减法
                
                // 处理乘法：a * b -> a' * b + a * b'
                const processMultiplication = (term) => {
                    const parts = term.split('*').map(part => part.trim());
                    if (parts.length === 2) {
                        const [a, b] = parts;
                        const aDeriv = this.calculateLogarithmDerivative(a, varName);
                        const bDeriv = this.calculateLogarithmDerivative(b, varName);
                        
                        if (aDeriv && bDeriv) {
                            return `(${aDeriv})*${b}+${a}*(${bDeriv})`;
                        } else if (aDeriv) {
                            return `(${aDeriv})*${b}`;
                        } else if (bDeriv) {
                            return `${a}*(${bDeriv})`;
                        }
                    } else if (parts.length > 2) {
                        // 处理多个因子的乘法，如 log3(x) * log5(x) * log33(x)
                        // 直接使用化简函数，确保结果为ln格式
                        const simplified = this.simplifyLogMultiplication(parts, varName);
                        if (simplified) {
                            return simplified;
                        }
                        
                        // 如果化简失败，尝试使用对数求导法则
                        // 将每个对数转换为ln形式
                        const lnTerms = [];
                        const lnDerivatives = [];
                        let isValid = true;
                        
                        for (const part of parts) {
                            const lnTerm = this.convertLogToLn(part);
                            if (lnTerm) {
                                lnTerms.push(lnTerm.term);
                                lnDerivatives.push(lnTerm.derivative);
                            } else {
                                isValid = false;
                                break;
                            }
                        }
                        
                        if (isValid && lnDerivatives.length > 0) {
                            // 构建结果：f*g*h*(f'/f + g'/g + h'/h)
                            const product = lnTerms.join('*');
                            const sumOfDerivatives = lnDerivatives.join(' + ');
                            
                            return `${product}*(${sumOfDerivatives})`;
                        }
                    }
                    return null;
                };
                
                // 处理除法：a / b -> (a' * b - a * b') / b^2
                const processDivision = (term) => {
                    const parts = term.split('/').map(part => part.trim());
                    if (parts.length === 2) {
                        const [a, b] = parts;
                        const aDeriv = this.calculateLogarithmDerivative(a, varName);
                        const bDeriv = this.calculateLogarithmDerivative(b, varName);
                        
                        if (aDeriv && bDeriv) {
                            return `((${aDeriv})*${b}-${a}*(${bDeriv}))/(${b})^2`;
                        } else if (aDeriv) {
                            return `(${aDeriv})*${b}/(${b})^2`;
                        } else if (bDeriv) {
                            return `-${a}*(${bDeriv})/(${b})^2`;
                        }
                    }
                    return null;
                };
                
                // 处理对数除法：log_a(x) / log_b(x)
                const processLogDivision = (term) => {
                    const parts = term.split('/').map(part => part.trim());
                    if (parts.length === 2) {
                        const [a, b] = parts;
                        
                        // 检查是否都是对数函数
                        const aIsLog = this.isLogarithmTerm(a, varName);
                        const bIsLog = this.isLogarithmTerm(b, varName);
                        
                        if (aIsLog && bIsLog) {
                            // 使用换底公式：log_a(x) / log_b(x) = ln(x)/ln(a) / (ln(x)/ln(b)) = ln(b)/ln(a)
                            // 这是一个常数，导数为0
                            
                            // 提取底数
                            const aBase = this.extractLogBase(a);
                            const bBase = this.extractLogBase(b);
                            
                            if (aBase && bBase) {
                                // 返回0，因为这是常数
                                // 使用换底公式：log_a(x) / log_b(x) = ln(x)/ln(a) / (ln(x)/ln(b)) = ln(b)/ln(a)
                                return '0【使用换底公式：log_a(x)/log_b(x) = ln(b)/ln(a)，结果为常数，导数为0】';
                            }
                        }
                    }
                    return null;
                };
                
                // 分割表达式为各项（先处理乘除法，再处理加减法）
                let derivativeResult = null;
                
                // 检查是否有乘除法混合表达式（如 log3(x) * log5(x) / log7(x) * log9(x)）
                if ((expr.includes('*') || expr.includes('/')) && !expr.includes('+') && !expr.includes('-')) {
                    // 处理混合乘除法表达式
                    derivativeResult = this.processMixedMultiplicationDivision(expr, varName, processMultiplication, processDivision, processLogDivision);
                }
                // 检查是否有乘法
                else if (expr.includes('*') && !expr.includes('+') && !expr.includes('-')) {
                    derivativeResult = processMultiplication(expr);
                }
                // 检查是否有除法
                else if (expr.includes('/') && !expr.includes('+') && !expr.includes('-')) {
                    // 先尝试处理对数除法
                    derivativeResult = processLogDivision(expr);
                    // 如果不是对数除法，使用普通除法处理
                    if (!derivativeResult) {
                        derivativeResult = processDivision(expr);
                    }
                }
                // 处理加减法
                else {
                    const terms = expr.split(/(?=[+-])/).map(term => term.trim());
                    const derivativeTerms = [];
                    
                    terms.forEach(term => {
                        let sign = 1;
                        let cleanTerm = term;
                        
                        // 处理符号
                        if (term.startsWith('-')) {
                            sign = -1;
                            cleanTerm = term.substring(1).trim();
                        } else if (term.startsWith('+')) {
                            cleanTerm = term.substring(1).trim();
                        }
                        
                        // 先检查是否有乘除法
                        let derivative = null;
                        
                        if (cleanTerm.includes('*')) {
                            derivative = processMultiplication(cleanTerm);
                        } else if (cleanTerm.includes('/')) {
                            // 先尝试处理对数除法
                            derivative = processLogDivision(cleanTerm);
                            // 如果不是对数除法，使用普通除法处理
                            if (!derivativeResult) {
                                derivative = processDivision(cleanTerm);
                            }
                        }
                        
                        // 如果不是乘除法或者乘除法处理失败，处理单个对数项
                        if (!derivative) {
                            // 处理各种对数格式
                            
                            // 处理 logN(v) 格式
                            const logNMatch = cleanTerm.match(/^log(\d+)\(([^)]+)\)$/);
                            if (logNMatch) {
                                const base = logNMatch[1];
                                const value = logNMatch[2];
                                if (value === varName) {
                                    // 不计算数值，保持ln格式
                                    // 判断是否为整数底数
                                    const baseNum = parseFloat(base);
                                    if (baseNum % 1 === 0) {
                                        derivative = `1/${varName}ln${base}`;
                                    } else {
                                        derivative = `1/${varName}ln(${base})`;
                                    }
                                }
                            }
                            
                            // 处理 log(底数)(真数) 格式
                            const logParenthesesMatch = cleanTerm.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                            if (logParenthesesMatch) {
                                const base = logParenthesesMatch[1];
                                const value = logParenthesesMatch[2];
                                if (value === varName) {
                                    // 不计算数值，保持ln格式
                                    derivative = `1/${varName}ln(${base})`;
                                }
                            }
                            
                            // 处理 log(v, b) 格式（预处理后）
                            const anyBaseLogMatch = cleanTerm.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                            if (anyBaseLogMatch) {
                                const value = anyBaseLogMatch[1];
                                const base = anyBaseLogMatch[2];
                                if (value === varName) {
                                    // 不计算数值，保持ln格式
                                    // 判断是否为整数底数
                                    const baseNum = parseFloat(base);
                                    if (baseNum % 1 === 0) {
                                        derivative = `1/${varName}ln${base}`;
                                    } else {
                                        derivative = `1/${varName}ln(${base})`;
                                    }
                                }
                            }
                        }
                        
                        if (derivative) {
                            derivativeTerms.push(sign === -1 ? `-${derivative}` : derivative);
                        }
                    });
                    
                    if (derivativeTerms.length === 0) {
                        console.log('没有可用的导数项');
                        return null;
                    }
                    
                    // 构建结果字符串
                    derivativeResult = derivativeTerms.join(' + ').replace(/\+ \-/g, '- ');
                }
                
                console.log('对数导数结果:', derivativeResult);
                return derivativeResult;
            },
            
            // 处理原始对数表达式，当预处理失败时使用
            processOriginalLogExpression(expr, varName) {
                console.log('处理原始对数表达式:', expr);
                
                // 分割表达式为各项
                const terms = expr.split(/(?=[+-])/).map(term => term.trim());
                const derivativeTerms = [];
                
                terms.forEach(term => {
                    let sign = 1;
                    let cleanTerm = term;
                    
                    // 处理符号
                    if (term.startsWith('-')) {
                        sign = -1;
                        cleanTerm = term.substring(1).trim();
                    } else if (term.startsWith('+')) {
                        cleanTerm = term.substring(1).trim();
                    }
                    
                    // 处理各种对数格式
                    let derivative = null;
                    
                    // 处理 logN(v) 格式
                    const logNMatch = cleanTerm.match(/^log(\d+)\(([^)]+)\)$/);
                    if (logNMatch) {
                        const base = logNMatch[1];
                        const value = logNMatch[2];
                        if (value === varName) {
                            // 直接返回ln格式，不计算数值
                            derivative = `1/${varName}ln${base}【最终计算值/${varName}】`;
                        }
                    }
                    
                    // 处理 log(底数)(真数) 格式
                    const logParenthesesMatch = cleanTerm.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                    if (logParenthesesMatch) {
                        const base = logParenthesesMatch[1];
                        const value = logParenthesesMatch[2];
                        if (value === varName) {
                            // 直接返回ln格式，不计算数值
                            derivative = `1/${varName}ln(${base})【最终计算值/${varName}】`;
                        }
                    }
                    
                    if (derivative) {
                        derivativeTerms.push(sign === -1 ? `-${derivative}` : derivative);
                    }
                });
                
                if (derivativeTerms.length === 0) {
                    return null;
                }
                
                return derivativeTerms.join(' + ').replace(/\+ \-/g, '- ');
            },
            
            // 将任意底对数转换为ln形式
            convertLogToLn(logTerm, varName) {
                // 处理 logN(v) 格式
                const logNMatch = logTerm.match(/^log(\d+)\(([^)]+)\)$/);
                if (logNMatch) {
                    const base = logNMatch[1];
                    const value = logNMatch[2];
                    if (value === varName) {
                        return {
                            term: `ln(${value})/ln(${base})`,
                            derivative: `1/(${value}*ln(${base}))`
                        };
                    }
                }
                
                // 处理 log(底数)(真数) 格式
                const logParenthesesMatch = logTerm.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                if (logParenthesesMatch) {
                    const base = logParenthesesMatch[1];
                    const value = logParenthesesMatch[2];
                    if (value === varName) {
                        return {
                            term: `ln(${value})/ln(${base})`,
                            derivative: `1/(${value}*ln(${base}))`
                        };
                    }
                }
                
                // 处理 log(v, b) 格式（预处理后）
                const anyBaseLogMatch = logTerm.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                if (anyBaseLogMatch) {
                    const value = anyBaseLogMatch[1];
                    const base = anyBaseLogMatch[2];
                    if (value === varName) {
                        return {
                            term: `ln(${value})/ln(${base})`,
                            derivative: `1/(${value}*ln(${base}))`
                        };
                    }
                }
                
                return null;
            },
            
            // 化简对数乘法的导数
            simplifyLogMultiplication(logTerms, varName) {
                // 提取所有对数的底数
                const bases = [];
                let isValid = true;
                
                for (const term of logTerms) {
                    const logNMatch = term.match(/^log(\d+)\(([^)]+)\)$/);
                    const logParenthesesMatch = term.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                    const anyBaseLogMatch = term.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                    
                    let base = null;
                    let value = null;
                    
                    if (logNMatch) {
                        base = logNMatch[1];
                        value = logNMatch[2];
                    } else if (logParenthesesMatch) {
                        base = logParenthesesMatch[1];
                        value = logParenthesesMatch[2];
                    } else if (anyBaseLogMatch) {
                        value = anyBaseLogMatch[1];
                        base = anyBaseLogMatch[2];
                    }
                    
                    if (base && value === varName) {
                        bases.push(base);
                    } else {
                        isValid = false;
                        break;
                    }
                }
                
                if (!isValid || bases.length === 0) {
                    return null;
                }
                
                // 统计每个底数出现的次数
                const baseCounts = {};
                for (const base of bases) {
                    baseCounts[base] = (baseCounts[base] || 0) + 1;
                }
                
                // 构建化简后的表达式，合并相同项
                // 例如：log3(x)*log5(x)*log33(x)*log23(x)*log3(x)*log5(x)
                // -> 6*(ln(x))^5/(x*ln(3)^2*ln(5)^2*ln(33)*ln(23))
                const numerator = bases.length; // n*(ln(x))^(n-1)
                const lnPower = bases.length > 1 ? `*(ln(${varName}))^${bases.length-1}` : '';
                
                // 构建分母，相同底数用幂次表示
                const denominatorTerms = [];
                for (const [base, count] of Object.entries(baseCounts)) {
                    if (count === 1) {
                        denominatorTerms.push(`ln(${base})`);
                    } else {
                        denominatorTerms.push(`ln(${base})^${count}`);
                    }
                }
                const denominator = `${varName}*${denominatorTerms.join('*')}`;
                
                // 完全使用ln格式，不进行任何数值计算
                return `${numerator}${lnPower}/(${denominator})`;
            },
            
            // 检查是否是对数项
            isLogarithmTerm(term, varName) {
                // 处理 logN(v) 格式
                const logNMatch = term.match(/^log(\d+)\(([^)]+)\)$/);
                if (logNMatch) {
                    const value = logNMatch[2];
                    return value === varName;
                }
                
                // 处理 log(底数)(真数) 格式
                const logParenthesesMatch = term.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                if (logParenthesesMatch) {
                    const value = logParenthesesMatch[2];
                    return value === varName;
                }
                
                // 处理 log(v, b) 格式（预处理后）
                const anyBaseLogMatch = term.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                if (anyBaseLogMatch) {
                    const value = anyBaseLogMatch[1];
                    return value === varName;
                }
                
                return false;
            },
            
            // 处理混合乘除法表达式（如 log3(x) * log5(x) / log7(x) * log9(x)）
            processMixedMultiplicationDivision(expr, varName, processMultiplication, processDivision, processLogDivision) {
                // 将表达式按乘除法分割，保持运算符顺序
                const parts = [];
                const operators = [];
                let currentPart = '';
                
                for (let i = 0; i < expr.length; i++) {
                    const char = expr[i];
                    if (char === '*' || char === '/') {
                        if (currentPart.trim()) {
                            parts.push(currentPart.trim());
                            operators.push(char);
                            currentPart = '';
                        }
                    } else {
                        currentPart += char;
                    }
                }
                
                if (currentPart.trim()) {
                    parts.push(currentPart.trim());
                }
                
                // 如果只有一个部分，直接处理
                if (parts.length === 1) {
                    return processMultiplication(expr);
                }
                
                // 检查是否所有部分都是对数函数
                const allLogs = parts.every(part => this.isLogarithmTerm(part, varName));
                
                if (allLogs) {
                    // 所有部分都是对数函数，使用换底公式化简
                    // 将每个对数转换为 ln(x)/ln(base) 形式
                    const lnTerms = [];
                    const bases = [];
                    
                    for (const part of parts) {
                        const base = this.extractLogBase(part);
                        if (base) {
                            lnTerms.push(`ln(${varName})/ln(${base})`);
                            bases.push(base);
                        }
                    }
                    
                    if (lnTerms.length === parts.length) {
                        // 构建化简后的表达式
                        let simplifiedExpr = lnTerms[0];
                        for (let i = 0; i < operators.length; i++) {
                            simplifiedExpr += ` ${operators[i]} ${lnTerms[i+1]}`;
                        }
                        
                        // 计算化简后的表达式
                        // ln(x)/ln(a) * ln(x)/ln(b) / ln(x)/ln(c) * ln(x)/ln(d)
                        // = (ln(x))^n / (分母项)
                        // 这是一个常数乘以 (ln(x))^n，导数为常数*n*(ln(x))^(n-1)/x
                        
                        // 计算ln(x)的净幂次（分子中的ln(x)数量 - 分母中的ln(x)数量）
                        let lnPower = 0;
                        let numeratorBases = [];  // 在分子中的底数
                        let denominatorBases = [];  // 在分母中的底数
                        
                        // 第一个项总是在分子中
                        lnPower++;
                        numeratorBases.push(bases[0]);
                        
                        // 处理后续项
                        for (let i = 0; i < operators.length; i++) {
                            const op = operators[i];
                            const base = bases[i+1];
                            
                            if (op === '*') {
                                // 乘法：项在分子中
                                lnPower++;
                                numeratorBases.push(base);
                            } else if (op === '/') {
                                // 除法：项在分母中
                                lnPower--;
                                denominatorBases.push(base);
                            }
                        }
                        
                        // 如果幂次为0，则表达式为常数，导数为0
                        if (lnPower === 0) {
                            // 构建常数项：分子底数积 / 分母底数积
                            const numeratorProduct = numeratorBases.map(b => `ln(${b})`).join('*');
                            const denominatorProduct = denominatorBases.map(b => `ln(${b})`).join('*');
                            return '0【使用换底公式化简后为常数，导数为0】';
                        }
                        
                        // 构建分母（所有底数的对数）
                        const allBases = [...numeratorBases, ...denominatorBases];
                        const denominatorTerms = allBases.map(b => `ln(${b})`);
                        
                        // 构建结果：根据换底公式：log_a(x) * log_b(x) / log_c(x) = ln(c)/(x*ln(a)*ln(b))
                        // 分子应该是分母底数的对数，分母是变量x和分子底数的对数
                        
                        // 分子：所有分母底数的对数
                        const numeratorProduct = denominatorBases.map(b => `ln(${b})`).join('*');
                        
                        // 分母：变量x和所有分子底数的对数
                        const denominatorParts = [varName];
                        numeratorBases.forEach(b => denominatorParts.push(`ln(${b})`));
                        const denominatorStr = denominatorParts.join('*');
                        
                        // 构建最终结果，使用单个分数形式
                        if (lnPower === 1) {
                            if (numeratorProduct && denominatorParts.length > 0) {
                                return `${numeratorProduct}/${denominatorStr}`;
                            } else if (numeratorProduct) {
                                return `${numeratorProduct}/${varName}`;
                            } else {
                                return `1/${denominatorStr}`;
                            }
                        } else {
                            if (numeratorProduct && denominatorParts.length > 0) {
                                return `${lnPower}*${numeratorProduct}*(ln(${varName}))^${lnPower-1}/${denominatorStr}`;
                            } else if (numeratorProduct) {
                                return `${lnPower}*${numeratorProduct}*(ln(${varName}))^${lnPower-1}/${varName}`;
                            } else {
                                return `${lnPower}*(ln(${varName}))^${lnPower-1}/${denominatorStr}`;
                            }
                        }
                    }
                }
                
                // 如果不是所有部分都是对数函数，使用通用方法
                // 从左到右处理表达式
                let result = parts[0];
                let resultDeriv = this.calculateLogarithmDerivative(parts[0], varName);
                
                for (let i = 0; i < operators.length; i++) {
                    const nextPart = parts[i+1];
                    const nextDeriv = this.calculateLogarithmDerivative(nextPart, varName);
                    const operator = operators[i];
                    
                    if (operator === '*') {
                        // (f*g)' = f'*g + f*g'
                        if (resultDeriv && nextDeriv) {
                            resultDeriv = `(${resultDeriv})*${nextPart}+${result}*(${nextDeriv})`;
                        } else if (resultDeriv) {
                            resultDeriv = `(${resultDeriv})*${nextPart}`;
                        } else if (nextDeriv) {
                            resultDeriv = `${result}*(${nextDeriv})`;
                        }
                        result = `${result}*${nextPart}`;
                    } else if (operator === '/') {
                        // (f/g)' = (f'*g - f*g')/g^2
                        if (resultDeriv && nextDeriv) {
                            resultDeriv = `((${resultDeriv})*${nextPart}-${result}*(${nextDeriv}))/(${nextPart})^2`;
                        } else if (resultDeriv) {
                            resultDeriv = `(${resultDeriv})*${nextPart}/(${nextPart})^2`;
                        } else if (nextDeriv) {
                            resultDeriv = `-${result}*(${nextDeriv})/(${nextPart})^2`;
                        }
                        result = `${result}/${nextPart}`;
                    }
                }
                
                return resultDeriv;
            },
            
            // 提取对数的底数
            extractLogBase(logTerm) {
                // 处理 logN(v) 格式
                const logNMatch = logTerm.match(/^log(\d+)\(([^)]+)\)$/);
                if (logNMatch) {
                    return logNMatch[1];
                }
                
                // 处理 log(底数)(真数) 格式
                const logParenthesesMatch = logTerm.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                if (logParenthesesMatch) {
                    return logParenthesesMatch[1];
                }
                
                // 处理 log(v, b) 格式（预处理后）
                const anyBaseLogMatch = logTerm.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                if (anyBaseLogMatch) {
                    return anyBaseLogMatch[2];
                }
                
                return null;
            },
            
            // 对单个对数项求导
            deriveLogarithmTerm(termStr, varName) {
                // 处理 log(x) 自然对数
                const naturalLogMatch = termStr.match(/^log\(([^)]+)\)$/);
                if (naturalLogMatch) {
                    const arg = naturalLogMatch[1];
                    if (arg === varName) {
                        return `1/${varName}ln`;
                    }
                    // 如果是复合函数，使用链式法则
                    if (arg.includes(varName)) {
                        try {
                            const innerDerivative = math.derivative(arg, varName).toString();
                            return `${innerDerivative}/${arg}ln`;
                        } catch (e) {
                            return null; // 无法求导，返回null
                        }
                    }
                    return null; // 不包含变量，导数为0
                }
                
                // 处理 log(v, b) 任意底对数（预处理后的格式）
                const anyBaseLogMatch = termStr.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                if (anyBaseLogMatch) {
                    const value = anyBaseLogMatch[1];
                    const base = anyBaseLogMatch[2];
                    
                    if (value === varName) {
                        // 判断是否为整数底数
                        const baseNum = parseFloat(base);
                        if (baseNum % 1 === 0) {
                            return `1/${varName}ln${base}`;
                        } else {
                            return `1/${varName}ln(${base})`;
                        }
                    }
                    // 如果是复合函数，使用链式法则
                    if (value.includes(varName)) {
                        try {
                            const innerDerivative = math.derivative(value, varName).toString();
                            const baseNum = parseFloat(base);
                            if (baseNum % 1 === 0) {
                                return `${innerDerivative}/${value}ln${base}`;
                            } else {
                                return `${innerDerivative}/${value}ln(${base})`;
                            }
                        } catch (e) {
                            return null; // 无法求导，返回null
                        }
                    }
                    return null; // 不包含变量，导数为0
                }
                
                // 处理 logN(v) 格式（预处理前可能存在）
                const logNMatch = termStr.match(/^log(\d+)\(([^)]+)\)$/);
                if (logNMatch) {
                    const base = logNMatch[1];
                    const value = logNMatch[2];
                    
                    if (value === varName) {
                        return `1/${varName}ln${base}`;
                    }
                    // 如果是复合函数，使用链式法则
                    if (value.includes(varName)) {
                        try {
                            const innerDerivative = math.derivative(value, varName).toString();
                            return `${innerDerivative}/${value}ln${base}`;
                        } catch (e) {
                            return null; // 无法求导，返回null
                        }
                    }
                    return null; // 不包含变量，导数为0
                }
                
                // 处理 log(底数)(真数) 格式（预处理前可能存在）
                const logParenthesesMatch = termStr.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                if (logParenthesesMatch) {
                    const base = logParenthesesMatch[1];
                    const value = logParenthesesMatch[2];
                    
                    if (value === varName) {
                        return `1/${varName}ln(${base})`;
                    }
                    // 如果是复合函数，使用链式法则
                    if (value.includes(varName)) {
                        try {
                            const innerDerivative = math.derivative(value, varName).toString();
                            return `${innerDerivative}/${value}ln(${base})`;
                        } catch (e) {
                            return null; // 无法求导，返回null
                        }
                    }
                    return null; // 不包含变量，导数为0
                }
                
                // 处理系数乘以对数的情况，如 3*log(x)
                const coeffLogMatch = termStr.match(/^(\d+(?:\.\d+)?)\s*\*\s*(log.*)$/);
                if (coeffLogMatch) {
                    const coefficient = coeffLogMatch[1];
                    const logTerm = coeffLogMatch[2];
                    const logDerivative = this.deriveLogarithmTerm(logTerm, varName);
                    if (logDerivative) {
                        return `${coefficient}*${logDerivative}`;
                    }
                }
                
                return null;
            },
            
            // 剥离 HTML 标签，用于复制文本
            // 智能求值函数，分别处理包含虚数的项和纯常数项
            intelligentEvaluate(expr, scope) {
                console.log('=== intelligentEvaluate 函数调试 ===');
                console.log('输入表达式:', expr);
                
                // 将表达式分解为各项
                const terms = [];
                try {
                    const node = math.parse(expr);
                    this.extractTerms(node, terms);
                } catch (e) {
                    console.log('无法分解表达式，尝试直接求值');
                    try {
                        const result = math.evaluate(expr, scope);
                        if (isFinite(result)) {
                            return result.toFixed(6).replace(/\.?0+$/, '');
                        } else {
                            return expr; // 无穷大或无法求值，保持原样
                        }
                    } catch (e2) {
                        console.log('直接求值失败，保持原样');
                        return expr;
                    }
                }
                
                // 分别处理每一项
                const evaluatedTerms = terms.map(term => {
                    const termStr = term.node.toString();
                    console.log('处理项:', termStr);
                    
                    // 检查是否是无穷大项
                    const { infiniteTerms } = this.getInfiniteTerms(termStr, 'x');
                    if (infiniteTerms.length > 0) {
                        console.log('项是无穷大项，保持不变:', termStr);
                        return termStr;
                    }
                    
                    // 如果项包含虚数，检查是否需要将log转换为ln
                    if (this.containsImaginary(termStr)) {
                        console.log('项包含虚数，检查是否需要转换:', termStr);
                        // 如果是log(...)形式且包含虚数，转换为ln(...)
                        if (termStr.startsWith('log(') && termStr.includes('i')) {
                            const content = termStr.slice(4, -1); // 提取括号内的内容
                            console.log(`将log(${content})转换为ln(${content})`);
                            return `ln(${content})`;
                        }
                        console.log('项包含虚数，保持不变:', termStr);
                        return termStr;
                    }
                    
                    // 否则求值
                    try {
                        console.log('尝试求值项:', termStr);
                        const result = math.evaluate(termStr, scope);
                        console.log('math.evaluate 原始结果:', result);
                        console.log('math.evaluate 结果类型:', typeof result);
                        if (typeof result === 'function') {
                            console.log('结果是函数，保持原样:', termStr);
                            return termStr;
                        } else if (isFinite(result)) {
                            const formattedResult = result.toFixed(6).replace(/\.?0+$/, '');
                            console.log('项求值结果:', termStr, '->', formattedResult);
                            return formattedResult;
                        } else {
                            console.log('项求值结果为无穷大，保持原样:', termStr);
                            return termStr;
                        }
                    } catch (e) {
                        console.log('项求值失败，保持原样:', termStr);
                        console.log('错误信息:', e.message);
                        return termStr;
                    }
                });
                
                // 重新组合表达式
                const result = evaluatedTerms.join(' + ').replace(/\+ \-/g, '- ');
                console.log('最终结果:', result);
                return result;
            },
            
            stripHtmlTags(html) {
                const temp = document.createElement('div');
                temp.innerHTML = html;
                let text = temp.textContent || temp.innerText || '';
                
                // 额外清理 logb(v) 格式
                text = text.replace(/log\s*<sub>\s*([^<]+)\s*<\/sub>\s*\(([^)]+)\)/gi, 'log($2,$1)');
                // 清理 e^() 格式 - 修复：保留所有e^格式，不转换为exp
                text = text.replace(/e\^\(([^)]+)\)/g, (match, content) => {
                    // 保留所有e^格式，包括e^x和e^(x+1)等
                    return `e^(${content})`;
                });
                
                return text;
            },
            
            addCopyFunctionality() {
                document.querySelectorAll('.copy-icon').forEach(icon => {
                    icon.addEventListener('click', async (e) => {
                        const text = e.currentTarget.getAttribute('data-text');
                        try {
                            await navigator.clipboard.writeText(text);
                            this.showSuccessMessage('已复制到剪贴板！');
                        } catch (err) {
                            const textArea = document.createElement('textarea');
                            textArea.value = text;
                            document.body.appendChild(textArea);
                            textArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textArea);
                            this.showSuccessMessage('已复制到剪贴板！');
                        }
                    });
                });
            },
            
            showSuccessMessage(message) {
                const messageEl = document.createElement('div');
                messageEl.className = 'success-message';
                messageEl.innerHTML = `<i class="fas fa-check"></i> ${message}`;
                document.body.appendChild(messageEl);
                
                setTimeout(() => {
                    document.body.removeChild(messageEl);
                }, 2000);
            }
                
        },

            // 搜索功能
            search: {
                perform(query, category = 'all') {
                    const results = [];
                    const lowerQuery = query.toLowerCase();
                    
                    if (category === 'all' || category === 'functions') {
                        App.searchData.functions.forEach(item => {
                            if (item.name.toLowerCase().includes(lowerQuery) || 
                                item.description.toLowerCase().includes(lowerQuery)) {
                                results.push(item);
                            }
                        });
                    }
                    
                    if (category === 'all' || category === 'constants') {
                        App.searchData.constants.forEach(item => {
                            if (item.name.toLowerCase().includes(lowerQuery) || 
                                item.description.toLowerCase().includes(lowerQuery)) {
                                results.push(item);
                            }
                        });
                    }
                    
                    if (category === 'all' || category === 'examples') {
                        App.searchData.examples.forEach(item => {
                            if (item.name.toLowerCase().includes(lowerQuery) || 
                                item.description.toLowerCase().includes(lowerQuery)) {
                                results.push(item);
                            }
                        });
                    }
                    
                    return results;
                },
                
                display(results) {
                    const resultsContainer = App.elements.searchResults;
                    
                    if (results.length === 0) {
                        resultsContainer.innerHTML = '<p class="no-results">未找到相关结果</p>';
                        return;
                    }
                    
                    let html = '';
                    results.forEach(result => {
                        html += `
                            <div class="search-result-item" data-example="${result.example}">
                                <div class="search-result-title">${result.name}</div>
                                <div class="search-result-description">${result.description}</div>
                                <div class="search-result-example">示例: ${result.example}</div>
                            </div>
                        `;
                    });
                    
                    resultsContainer.innerHTML = html;
                    
                    // 添加点击事件
                    resultsContainer.querySelectorAll('.search-result-item').forEach(item => {
                        item.addEventListener('click', function() {
                            const example = this.getAttribute('data-example');
                            App.elements.expression.value = example;
                            App.elements.searchPanel.classList.remove('active');
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        });
                    });
                },
                
                addToHistory(query) {
                    if (!query.trim()) return;
                    
                    // 移除重复项
                    App.searchHistory = App.searchHistory.filter(item => item !== query);
                    // 添加到开头
                    App.searchHistory.unshift(query);
                    // 限制历史记录数量
                    App.searchHistory = App.searchHistory.slice(0, 10);
                    // 保存到本地存储
                    localStorage.setItem('searchHistory', JSON.stringify(App.searchHistory));
                    // 更新下拉列表
                    this.updateHistory();
                },
                
                updateHistory() {
                    const historySelect = App.elements.searchHistory;
                    historySelect.innerHTML = '<option value="">-- 选择历史搜索 --</option>';
                    
                    App.searchHistory.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item;
                        option.textContent = item;
                        historySelect.appendChild(option);
                    });
                },
                
                clear() {
                    App.elements.searchInput.value = '';
                    App.elements.searchResults.innerHTML = '<p class="no-results">暂无搜索结果</p>';
                    App.elements.searchCategory.value = 'all';
                    App.audio.play(...App.elements.soundType.value.split(':'));
                    App.vibration.trigger(App.elements.vibrateMode.value);
                }
            },

            // AIOS聊天功能 - 优化版本
            chat: {
                isGenerating: false,
                abortController: null,
                currentStreamRequest: null, // 添加当前请求引用
                isEditing: false, // 是否处于编辑模式
                editingMessageId: null, // 正在编辑的消息ID
                
                // 节流与防抖相关变量
                updateQueue: [],
                isProcessingQueue: false,
                lastUpdateTime: 0,
                updateThrottleDelay: 50, // 50ms节流延迟
                updateDebounceDelay: 100, // 100ms防抖延迟
                debounceTimer: null,
                
                // 聊天历史记录
                conversationHistory: [],
                maxHistoryLength: 20, // 最大保存20轮对话
                systemPrompt: "你是一个智能助手，能够帮助用户解答各种问题，包括数学计算、编程、日常生活等。请用简洁、准确、友好的方式回答用户的问题。",
                
                // 智能滚动相关属性
                autoScrollEnabled: true,
                userScrolled: false,
                lastScrollTop: 0,
                scrollThreshold: 50, // 用户滚动多少像素后认为是有意滚动
                scrollCheckInterval: null,
                
                async sendMessage() {
                    const message = App.elements.chatInput.value.trim();
                    if (!message) return;

                    console.log('sendMessage被调用，当前isGenerating状态:', this.isGenerating);

                    // 如果正在生成，则停止生成
                    if (this.isGenerating) {
                        console.log('检测到正在生成，执行停止操作');
                        this.stopGeneration();
                        return;
                    }

                    // 检查是否处于编辑模式
                    if (this.isEditing) {
                        // 找到正在编辑的消息
                        const editingMessage = document.querySelector(`[data-message-id="${this.editingMessageId}"]`);
                        if (editingMessage) {
                            // 更新编辑的消息内容
                            const userContent = editingMessage.querySelector('.user-content p');
                            if (userContent) {
                                // 处理消息内容，确保正确换行，但保留Markdown格式
                                const processedContent = message
                                    .replace(/&/g, '&amp;')
                                    .replace(/</g, '&lt;')
                                    .replace(/>/g, '&gt;');
                                
                                // 处理换行和空格，但保留Markdown格式
                                const formattedContent = processedContent
                                    .replace(/\n/g, '<br>')
                                    .replace(/  /g, '&nbsp;&nbsp;');
                                
                                // 检查消息是否过长，添加折叠功能
                                const isLongMessage = message.length > 200;
                                const messageClass = isLongMessage ? 'collapsed-message' : '';
                                
                                // 更新消息内容
                                const userContentDiv = editingMessage.querySelector('.user-content');
                                userContentDiv.className = `user-content ${messageClass}`;
                                userContentDiv.innerHTML = isLongMessage ? 
                                    `<div class="expand-controls"><span class="message-actions" title="复制">📋复制</span><span class="message-action-icon expand-toggle" title="展开">v</span> <span class="expand-indicator">点击 v 展开完整内容</span></div>
                                     <p>${formattedContent}</p>` :
                                    `<p>${formattedContent}<span class="message-actions" title="复制">📋复制</span> <span class="message-actions" title="编辑" style="margin-left: 15px;">✏️编辑</span></p>`;
                                
                                // 恢复消息样式
                                editingMessage.style.border = '';
                                editingMessage.style.borderRadius = '';
                                editingMessage.style.padding = '';
                                editingMessage.style.backgroundColor = '';
                                
                                // 重新添加复制和编辑功能
                                this.addCopyFunctionality(editingMessage);
                                
                                // 如果是长消息，添加展开/折叠功能
                                if (isLongMessage) {
                                    this.addToggleFunctionality(editingMessage);
                                }
                                
                                // 删除编辑消息之后的所有消息
                                this.removeMessagesAfter(editingMessage);
                                
                                // 不再调用updateHistoryAfterEdit，避免更新数组中的第一个用户消息
                                // 直接确保编辑后的用户消息在历史记录末尾
                                this.ensureUserMessageAtEnd(message);
                            }
                        }
                        
                        // 退出编辑模式
                        this.isEditing = false;
                        this.editingMessageId = null;
                        
                        // 清空输入框
                        App.elements.chatInput.value = '';
                        
                        // 恢复输入框占位符
                        App.elements.chatInput.placeholder = '输入您的问题... (Ctrl+Enter发送，支持数学公式)';
                        
                        // 开始生成AI回复
                        this.startGeneration();
                        
                        // 构建包含历史上下文的消息（不重复添加用户消息）
                        const contextualMessages = this.buildContextualMessageWithoutUser(message);
                        
                        // 尝试使用API回答
                        try {
                            // 调用流式API，传递完整的对话历史
                            await this.callStreamAPI(contextualMessages);
                        } catch (error) {
                            console.log('捕获到错误:', error);
                            
                            // 检查是否是因为取消导致的错误
                            if (error.name === 'AbortError' || this.abortController?.signal.aborted) {
                                console.log('API调用被用户取消');
                                return;
                            }
                            
                            // 停止生成
                            this.stopGeneration();
                            
                            // 显示错误信息
                            this.addMessage(`API调用失败: ${error.message}\n\n提示：请点击AIOS面板右侧的"API"按钮配置正确的API密钥以启用智能AI对话。`, 'ai');
                        }
                        
                        return;
                    }

                    // 添加用户消息到界面
                    this.addMessage(message, 'user');
                    App.elements.chatInput.value = '';
                    
                    // 重置滚动状态，确保新消息后自动滚动
                    this.resetScrollState();

                    // 检查是否是数学相关问题，如果是，添加当前表达式上下文
                    let enhancedMessage = message;
                    const currentExpression = App.elements.expressionInput.value.trim();
                    const currentOperation = App.elements.operationSelect.value;
                    
                    if (currentExpression && this.isMathRelatedQuestion(message)) {
                        enhancedMessage = `${message}\n\n当前计算器中的表达式: ${currentExpression}\n计算类型: ${this.getOperationName(currentOperation)}`;
                    }

                    // 将用户消息添加到历史记录（使用增强后的消息）
                    this.addToHistory('user', enhancedMessage);

                    // 开始生成，更新按钮状态
                    this.startGeneration();

                    // 构建包含历史上下文的消息（不重复添加用户消息）
                    const contextualMessages = this.buildContextualMessageWithoutUser(enhancedMessage);

                    // 尝试使用API回答
                    try {
                        // 调用流式API，传递完整的对话历史
                        await this.callStreamAPI(contextualMessages);
                    } catch (error) {
                        console.log('捕获到错误:', error);
                        
                        // 检查是否是因为取消导致的错误
                        if (error.name === 'AbortError' || this.abortController?.signal.aborted) {
                            console.log('API调用被用户取消');
                            // 不显示错误消息，因为用户主动取消
                            // 保持已生成的消息不变
                            return;
                        }
                        
                        // 停止生成但不移除已显示的消息
                        this.stopGeneration();
                        
                        // 显示错误信息，但不移除已生成的消息
                        this.addMessage(`API调用失败: ${error.message}\n\n提示：请点击AIOS面板右侧的"API"按钮配置正确的API密钥以启用智能AI对话。`, 'ai');
                    }
                },

                // 节流函数 - 限制函数执行频率
                throttle(func, delay) {
                    let lastCall = 0;
                    return function(...args) {
                        const now = Date.now();
                        if (now - lastCall >= delay) {
                            lastCall = now;
                            return func.apply(this, args);
                        }
                    };
                },
                
                // 防抖函数 - 延迟执行函数，如果在延迟时间内再次调用则重置计时器
                debounce(func, delay) {
                    let timeoutId;
                    return function(...args) {
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => func.apply(this, args), delay);
                    };
                },
                
                // 添加消息到历史记录
                addToHistory(role, content) {
                    this.conversationHistory.push({
                        role: role,
                        content: content
                    });
                    
                    // 限制历史记录长度
                    if (this.conversationHistory.length > this.maxHistoryLength * 2) {
                        // 保留最近的对话（每轮对话包含用户和AI两条消息）
                        this.conversationHistory = this.conversationHistory.slice(-this.maxHistoryLength * 2);
                    }
                },
                
                // 构建包含历史上下文的消息
                buildContextualMessage(userMessage) {
                    let messages = [];
                    
                    // 添加系统提示
                    if (this.conversationHistory.length === 0) {
                        messages.push({
                            role: 'system',
                            content: this.systemPrompt
                        });
                    }
                    
                    // 添加历史对话
                    messages = messages.concat(this.conversationHistory);
                    
                    // 添加当前用户消息
                    messages.push({
                        role: 'user',
                        content: userMessage
                    });
                    
                    return messages;
                },
                
                // 构建包含历史上下文的消息（不重复添加用户消息）
                buildContextualMessageWithoutUser(userMessage) {
                    let messages = [];
                    
                    // 添加系统提示
                    if (this.conversationHistory.length === 0) {
                        messages.push({
                            role: 'system',
                            content: this.systemPrompt
                        });
                    }
                    
                    // 添加历史对话（已经包含了用户消息）
                    messages = messages.concat(this.conversationHistory);
                    
                    return messages;
                },
                
                // 清空聊天历史
                clearHistory() {
                    this.conversationHistory = [];
                    // 清空界面上的消息，保留欢迎消息
                    const messages = App.elements.chatMessages.querySelectorAll('.ai-message, .user-message');
                    messages.forEach(msg => msg.remove());
                    
                    // 重新添加欢迎消息
                    this.addMessage('您好！我是AIOS智能助手，有什么可以帮助您的吗？', 'ai');
                },
                
                // 获取格式化的历史记录（用于调试）
                getFormattedHistory() {
                    return this.conversationHistory.map(msg => `[${msg.role}]: ${msg.content}`).join('\n');
                },
                
                // 优化的UI更新队列处理
                processUpdateQueue: function() {
                    if (this.isProcessingQueue || this.updateQueue.length === 0) {
                        return;
                    }
                    
                    // 检查是否已停止生成
                    if (!this.isGenerating || (this.abortController && this.abortController.signal.aborted)) {
                        console.log('检测到停止信号，清空更新队列');
                        this.updateQueue = [];
                        this.isProcessingQueue = false;
                        return;
                    }
                    
                    this.isProcessingQueue = true;
                    
                    // 使用requestAnimationFrame确保在下一帧渲染
                    requestAnimationFrame(() => {
                        // 再次检查是否已停止生成
                        if (!this.isGenerating || (this.abortController && this.abortController.signal.aborted)) {
                            console.log('在帧回调中检测到停止信号，清空更新队列');
                            this.updateQueue = [];
                            this.isProcessingQueue = false;
                            return;
                        }
                        
                        // 只处理最新的更新，忽略队列中的旧更新
                        const latestUpdate = this.updateQueue.pop();
                        this.updateQueue = []; // 清空队列，只保留最新内容
                        
                        if (latestUpdate) {
                            const { aiMessageElement, messageContentElement, fullContent } = latestUpdate;
                            
                            // 处理特殊字符，确保HTML安全，但保留Markdown格式
                            const safeContent = fullContent
                                .replace(/&/g, '&amp;')
                                .replace(/</g, '&lt;')
                                .replace(/>/g, '&gt;');
                            
                            // 处理换行和空格，但保留Markdown格式
                            const formattedContent = safeContent
                                .replace(/\n/g, '<br>')
                                .replace(/  /g, '&nbsp;&nbsp;');
                            
                            // 更新UI
                            messageContentElement.innerHTML = formattedContent + '<span class="message-actions" title="复制">📋复制</span>';
                            
                            // 滚动到底部
                            //App.elements.chatMessages.scrollTop = App.elements.chatMessages.scrollHeight;
                            
                            // 更新消息的原始内容属性
                            aiMessageElement.setAttribute('data-original-content', fullContent);
                            
                            // 重新添加复制功能
                            this.addCopyFunctionality(aiMessageElement);
                        }
                        
                        this.isProcessingQueue = false;
                        
                        // 如果还有待处理的更新，继续处理
                        if (this.updateQueue.length > 0 && this.isGenerating) {
                            this.processUpdateQueue();
                        }
                    });
                },
                
                // 队列化UI更新
                queueUIUpdate: function(aiMessageElement, messageContentElement, fullContent) {
                    // 如果队列中已有该元素的更新，替换它
                    const existingIndex = this.updateQueue.findIndex(
                        item => item.aiMessageElement === aiMessageElement
                    );
                    
                    if (existingIndex !== -1) {
                        this.updateQueue[existingIndex] = { aiMessageElement, messageContentElement, fullContent };
                    } else {
                        this.updateQueue.push({ aiMessageElement, messageContentElement, fullContent });
                    }
                    
                    // 使用防抖处理队列
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = setTimeout(() => {
                        this.processUpdateQueue();
                    }, this.updateDebounceDelay);
                },
                
                // 智能滚动功能初始化
                initSmartScroll() {
                    const chatMessages = App.elements.chatMessages;
                    
                    // 监听滚动事件
                    chatMessages.addEventListener('scroll', () => {
                        const currentScrollTop = chatMessages.scrollTop;
                        const scrollHeight = chatMessages.scrollHeight;
                        const clientHeight = chatMessages.clientHeight;
                        const distanceFromBottom = scrollHeight - currentScrollTop - clientHeight;
                        
                        // 检查用户是否向上滚动（有意查看历史消息）
                        // 降低阈值，使滚动更容易触发
                        if (currentScrollTop < this.lastScrollTop - 0) {
                            this.userScrolled = true;
                            this.autoScrollEnabled = false;
                        }
                        // 检查用户是否滚动到底部附近
                        else if (distanceFromBottom < 100) {
                            this.userScrolled = false;
                            this.autoScrollEnabled = true;
                        }
                        
                        this.lastScrollTop = currentScrollTop;
                    });
                    
                    // 监听鼠标按下事件，检测用户开始滚动
                    chatMessages.addEventListener('mousedown', () => {
                        // 用户开始交互时，暂时禁用自动滚动
                        this.wasAutoScrollEnabled = this.autoScrollEnabled;
                        this.autoScrollEnabled = false;
                    });
                    
                    // 监听鼠标释放事件
                    chatMessages.addEventListener('mouseup', () => {
                        // 用户释放鼠标后，根据位置决定是否恢复自动滚动
                        const currentScrollTop = chatMessages.scrollTop;
                        const scrollHeight = chatMessages.scrollHeight;
                        const clientHeight = chatMessages.clientHeight;
                        const distanceFromBottom = scrollHeight - currentScrollTop - clientHeight;
                        
                        // 如果在底部附近，恢复自动滚动
                        if (distanceFromBottom < 100) {
                            this.autoScrollEnabled = true;
                        }
                    });
                    
                    // 监听触摸事件（移动设备）
                    chatMessages.addEventListener('touchstart', () => {
                        this.wasAutoScrollEnabled = this.autoScrollEnabled;
                        this.autoScrollEnabled = false;
                    });
                    
                    chatMessages.addEventListener('touchend', () => {
                        const currentScrollTop = chatMessages.scrollTop;
                        const scrollHeight = chatMessages.scrollHeight;
                        const clientHeight = chatMessages.clientHeight;
                        const distanceFromBottom = scrollHeight - currentScrollTop - clientHeight;
                        
                        if (distanceFromBottom < 100) {
                            this.autoScrollEnabled = true;
                        }
                    });
                    
                    // 定期检查是否需要自动滚动（仅在AI生成时）
                    this.startScrollCheck();
                },
                
                // 开始滚动检查
                startScrollCheck() {
                    if (this.scrollCheckInterval) {
                        clearInterval(this.scrollCheckInterval);
                        this.scrollCheckInterval = null;
                    }
                    
                    // 确保自动滚动启用
                    this.autoScrollEnabled = true;
                    
                    this.scrollCheckInterval = setInterval(() => {
                        if (this.isGenerating && this.autoScrollEnabled) {
                            this.smartScrollToBottom();
                        }
                    }, 200); // 降低检查频率，减少性能开销
                    
                    console.log('滚动检查已启动，autoScrollEnabled:', this.autoScrollEnabled);
                },
                
                // 停止滚动检查
                stopScrollCheck() {
                    if (this.scrollCheckInterval) {
                        clearInterval(this.scrollCheckInterval);
                        this.scrollCheckInterval = null;
                    }
                },
                
                // 智能滚动到底部
                smartScrollToBottom() {
                    const chatMessages = App.elements.chatMessages;
                    
                    // 只有在自动滚动启用时才滚动
                    if (this.autoScrollEnabled) {
                        // 检查当前是否已经在底部附近
                        const currentScrollTop = chatMessages.scrollTop;
                        const scrollHeight = chatMessages.scrollHeight;
                        const clientHeight = chatMessages.clientHeight;
                        const distanceFromBottom = scrollHeight - currentScrollTop - clientHeight;
                        
                        // 强制滚动到底部，不管距离多少
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        
                        // 如果不在底部附近，使用平滑滚动
                        if (distanceFromBottom > 50) {
                            setTimeout(() => {
                                if (this.autoScrollEnabled && this.isGenerating) {
                                    chatMessages.scrollTo({
                                        top: chatMessages.scrollHeight,
                                        behavior: 'smooth'
                                    });
                                }
                            }, 50);
                        }
                    }
                },
                
                // 重置滚动状态（用户发送新消息时调用）
                resetScrollState() {
                    this.autoScrollEnabled = true;
                    this.userScrolled = false;
                    this.lastScrollTop = App.elements.chatMessages.scrollTop;
                    // 立即滚动到底部，确保用户看到新消息
                    App.elements.chatMessages.scrollTop = App.elements.chatMessages.scrollHeight;
                    
                    // 确保滚动检查正在运行
                    if (this.isGenerating && !this.scrollCheckInterval) {
                        this.startScrollCheck();
                    }
                },
                
                // 添加键盘快捷键支持
                setupKeyboardShortcuts() {
                    document.addEventListener('keydown', (e) => {
                        // ESC键停止生成或取消编辑
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            if (this.isGenerating) {
                                this.stopGeneration();
                            } else if (this.isEditing) {
                                this.cancelEdit();
                            }
                        }
                        
                        // Ctrl+Enter发送
                        if (e.key === 'Enter' && e.ctrlKey && document.activeElement === App.elements.chatInput) {
                            e.preventDefault();
                            this.sendMessage();
                        }
                    });
                },
                
                // 修改发送按钮的事件处理
                setupSendButton() {
                    App.elements.sendBtn.addEventListener('click', () => {
                        // 如果按钮是停止模式，则停止生成
                        if (App.elements.sendBtn.classList.contains('stop-mode')) {
                            this.stopGeneration();
                        } else {
                            this.sendMessage();
                        }
                    });
                    
                    // 初始化智能滚动功能
                    this.initSmartScroll();
                },
                
                // 检查是否是数学相关问题
                isMathRelatedQuestion(message) {
                    const mathKeywords = [
                        '计算', '求导', '积分', '化简', '求值', '解方程', '函数', '公式', 
                        '定理', '证明', '图形', '图像', '变换', '因式分解', '展开', '合并',
                        '微分', '极限', '级数', '矩阵', '向量', '几何', '代数', '三角',
                        '对数', '指数', '平方根', '立方根', '导数', '不定积分', '定积分',
                        '微分方程', '概率', '统计', '数列', '集合', '不等式', '参数方程'
                    ];
                    
                    const lowerMessage = message.toLowerCase();
                    return mathKeywords.some(keyword => lowerMessage.includes(keyword));
                },

                // 获取计算类型的中文名称
                getOperationName(operation) {
                    const operationNames = {
                        'derivative': '求导 (d/dx)',
                        'integral': '积分 (∫ dx)',
                        'second_derivative': '二阶导数 (d²/dx²)',
                        'nth_derivative': 'n阶导数',
                        'simplify': '表达式化简',
                        'evaluate': '表达式求值'
                    };
                    return operationNames[operation] || operation;
                },
                
                startGeneration() {
                    console.log('开始生成，设置isGenerating为true');
                    this.isGenerating = true;
                    
                    // 重置滚动状态，启用自动滚动
                    this.resetScrollState();
                    
                    // 更改按钮图标为停止图标，增强视觉效果
                    App.elements.sendBtn.innerHTML = '⏹';
                    App.elements.sendBtn.classList.add('stop-mode');
                    App.elements.sendBtn.title = '点击停止生成';
                    
                    // 创建新的AbortController用于取消请求
                    this.abortController = new AbortController();
                    console.log('AbortController已创建');
                    
                    // 显示AI思考中的加载动画
                    this.showThinkingIndicator();
                    
                    // 添加停止按钮的视觉反馈
                    this.addStopButtonVisualFeedback();
                },
                
                stopGeneration() {
                    console.log('停止生成功能被调用，当前isGenerating状态:', this.isGenerating);
                    
                    // 立即设置状态为非生成中
                    this.isGenerating = false;
                    
                    // 停止滚动检查
                    this.stopScrollCheck();
                    
                    // 恢复按钮图标和样式
                    App.elements.sendBtn.innerHTML = '➤';
                    App.elements.sendBtn.classList.remove('stop-mode');
                    App.elements.sendBtn.title = '发送消息 (Ctrl+Enter)';
                    
                    // 取消进行中的请求
                    if (this.abortController) {
                        console.log('正在取消API请求...');
                        try {
                            // 添加额外的停止逻辑
                            this.abortController.abort('用户主动停止');
                            console.log('API请求已成功取消');
                        } catch (error) {
                            console.error('取消请求时出错:', error);
                        }
                        this.abortController = null;
                        
                        // 显示停止提示，但不移除已生成的消息
                        this.showStopMessage();
                    } else {
                        console.log('没有进行中的请求需要取消');
                    }
                    
                    // 取消当前流式请求
                    if (this.currentStreamRequest) {
                        try {
                            this.currentStreamRequest.cancel();
                            console.log('当前流式请求已取消');
                        } catch (error) {
                            console.error('取消流式请求时出错:', error);
                        }
                        this.currentStreamRequest = null;
                    }
                    
                    // 清除防抖计时器
                    if (this.debounceTimer) {
                        clearTimeout(this.debounceTimer);
                        this.debounceTimer = null;
                        console.log('防抖计时器已清除');
                    }
                    
                    // 清空更新队列，但不移除已显示的消息
                    this.updateQueue = [];
                    this.isProcessingQueue = false;
                    console.log('更新队列已清空');
                    
                    // 隐藏加载动画
                    this.hideThinkingIndicator();
                    
                    // 移除停止按钮的视觉反馈
                    this.removeStopButtonVisualFeedback();
                    
                    console.log('停止生成功能完成');
                },
                
                // 取消编辑功能
                cancelEdit() {
                    if (!this.isEditing) return;
                    
                    console.log('取消编辑模式');
                    
                    // 找到正在编辑的消息
                    const editingMessage = document.querySelector(`[data-message-id="${this.editingMessageId}"]`);
                    if (editingMessage) {
                        // 恢复消息样式
                        editingMessage.style.border = '';
                        editingMessage.style.borderRadius = '';
                        editingMessage.style.padding = '';
                        editingMessage.style.backgroundColor = '';
                    }
                    
                    // 退出编辑模式
                    this.isEditing = false;
                    this.editingMessageId = null;
                    
                    // 清空输入框
                    App.elements.chatInput.value = '';
                    
                    // 调整输入框高度
                    App.elements.chatInput.style.height = 'auto';
                    
                    // 恢复输入框占位符
                    App.elements.chatInput.placeholder = '输入您的问题... (Ctrl+Enter发送，支持数学公式)';
                    
                    // 显示取消编辑的提示
                    App.calculator.showSuccessMessage('已取消编辑');
                },
                
                // 添加停止按钮的视觉反馈
                addStopButtonVisualFeedback() {
                    // 添加脉冲动画效果
                    App.elements.sendBtn.style.animation = 'stopPulse 1s infinite';
                    
                    // 如果没有这个动画，添加到样式表中
                    if (!document.querySelector('#stopButtonAnimation')) {
                        const style = document.createElement('style');
                        style.id = 'stopButtonAnimation';
                        style.textContent = `
                            @keyframes stopPulse {
                                0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
                                70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
                                100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                },
                
                // 移除停止按钮的视觉反馈
                removeStopButtonVisualFeedback() {
                    App.elements.sendBtn.style.animation = '';
                },
                
                // 显示停止提示消息
                showStopMessage() {
                    // 隐藏加载动画
                    this.hideThinkingIndicator();
                    
                    // 停止生成时不显示任何消息
                },
                
                async callStreamAPI(messages) {
                    // 创建AI消息容器，用于流式显示
                    const aiMessageId = this.addMessage('', 'ai', true);
                    const aiMessageElement = document.querySelector(`[data-message-id="${aiMessageId}"]`);
                    // 修复选择器，现在正常内容在.main-content p中
                    const messageContentElement = aiMessageElement?.querySelector('.main-content p');
                    
                    // 存储完整的AI回复，用于添加到历史记录
                    let fullAIResponse = '';
                    
                    // 创建响应式文本节点
                    const contentTextNode = document.createTextNode('');
                    const reasoningTextNode = document.createTextNode('');
                    
                    // 初始化内容节点
                    if (messageContentElement) {
                        messageContentElement.innerHTML = ''; // 清空现有内容
                        messageContentElement.appendChild(contentTextNode);
                    }
                    
                    // 初始化reasoning文本节点 - 需要等待reasoning-container创建后再添加
                    // 这里先不添加，在updateReasoningContent中处理
                    
                    let fullContent = '';
                    let reasoningContent = ''; // 思考过程内容
                    let buffer = ''; // 用于缓冲不完整的文本
                    let reasoningBuffer = ''; // 思考过程缓冲区
                    let chunkCount = 0; // 添加块计数器
                    let lastChunkTime = 0; // 用于节流控制
                    
                    // 创建直接更新UI的函数（不使用节流，避免重复）
                    const directUpdateUI = (chunkContent, contentType) => {
                        if (this.isGenerating && !this.abortController?.signal.aborted && chunkContent) {
                            if (contentType === 'reasoning') {
                                // 直接使用updateReasoningContent方法添加思考过程
                                this.updateReasoningContent(aiMessageElement, chunkContent);
                            } else {
                                // 使用文本节点直接追加内容，避免HTML转义问题
                                if (contentTextNode) {
                                    contentTextNode.textContent += chunkContent;
                                }
                            }
                            
                            // 确保自动滚动
                            this.smartScrollToBottom();
                        }
                    };
                    
                    // 定义处理每个数据块的回调函数
                    const handleChunk = (chunkContent, contentType) => {
                        chunkCount++;
                        const now = Date.now();
                        console.log(`handleChunk被调用 #${chunkCount}，类型: ${contentType}，内容长度:`, chunkContent.length);
                        
                        // 检查是否已停止生成
                        if (!this.isGenerating || this.abortController?.signal.aborted) {
                            console.log('检测到停止信号，停止处理后续数据块');
                            return;
                        }
                        
                        if (contentType === 'reasoning') {
                            // 处理思考过程
                            reasoningContent += chunkContent;
                            reasoningBuffer += chunkContent;
                            
                            // 尝试处理缓冲区中的内容，确保不截断中文字符
                            let processedContent = reasoningBuffer;
                            try {
                                // 简化处理：直接使用所有内容，不检查不完整字符
                                // 这样可以避免emoji等特殊字符被误判
                                processedContent = reasoningBuffer;
                                reasoningBuffer = ''; // 清空缓冲区
                            } catch (e) {
                                // 如果处理出错，使用原始内容
                                processedContent = reasoningBuffer;
                                reasoningBuffer = '';
                            }
                            
                            // 直接追加文本
                            if (chunkContent && chunkContent.trim() && this.isGenerating && !this.abortController?.signal.aborted) {
                                directUpdateUI(chunkContent, 'reasoning');
                            }
                        } else {
                            // 处理正常内容
                            fullContent += chunkContent;
                            fullAIResponse += chunkContent; // 同时更新完整回复
                            buffer += chunkContent;
                            
                            // 尝试处理缓冲区中的内容，确保不截断中文字符
                            let processedContent = buffer;
                            try {
                                // 简化处理：直接使用所有内容，不检查不完整字符
                                // 这样可以避免emoji等特殊字符被误判
                                processedContent = buffer;
                                buffer = ''; // 清空缓冲区
                            } catch (e) {
                                // 如果处理出错，使用原始内容
                                processedContent = buffer;
                                buffer = '';
                            }
                            
                            // 直接追加文本
                            if (chunkContent && chunkContent.trim() && this.isGenerating && !this.abortController?.signal.aborted) {
                                directUpdateUI(chunkContent, 'content');
                            }
                        }
                    };
                    
                    try {
                        // 调用API配置中的流式方法
                        await App.apiConfig.callStreamAPI(messages, handleChunk, this.abortController);
                        
                        // 处理缓冲区剩余的内容
                        if (buffer && buffer.trim() && messageContentElement && this.isGenerating && !this.abortController?.signal.aborted) {
                            // 直接更新，不需要节流
                            this.queueUIUpdate(aiMessageElement, messageContentElement, fullContent);
                        }
                        
                        // 处理思考过程缓冲区剩余的内容
                        if (reasoningBuffer && reasoningBuffer.trim() && this.isGenerating && !this.abortController?.signal.aborted) {
                            // 直接更新思考过程
                            this.updateReasoningContent(aiMessageElement, reasoningBuffer);
                        }
                        
                        // 正常结束，停止生成
                        if (this.isGenerating && !this.abortController?.signal.aborted) {
                            // 添加复制按钮到主内容区域
                            const mainContent = aiMessageElement.querySelector('.main-content p');
                            if (mainContent && !mainContent.querySelector('.message-actions')) {
                                const copySpan = document.createElement('span');
                                copySpan.className = 'message-actions';
                                copySpan.setAttribute('title', '复制');
                                copySpan.textContent = '📋复制';
                                mainContent.appendChild(copySpan);
                                
                                // 添加重新生成按钮
                                const regenerateSpan = document.createElement('span');
                                regenerateSpan.className = 'message-actions';
                                regenerateSpan.setAttribute('title', '重新生成');
                                regenerateSpan.textContent = '🔄重新生成';
                                regenerateSpan.style.marginLeft = '15px';
                                mainContent.appendChild(regenerateSpan);
                            }
                            
                            // 为思考过程添加复制按钮
                            const reasoningContent = aiMessageElement.querySelector('.reasoning-content');
                            if (reasoningContent && reasoningContent.style.display !== 'none') {
                                const reasoningHeader = reasoningContent.parentElement.querySelector('.reasoning-header');
                                if (reasoningHeader && !reasoningHeader.querySelector('.reasoning-copy')) {
                                    const copySpan = document.createElement('span');
                                    copySpan.className = 'reasoning-copy';
                                    copySpan.setAttribute('title', '复制思考过程');
                                    copySpan.textContent = '📋';
                                    copySpan.style.cursor = 'pointer';
                                    copySpan.style.marginLeft = '10px';
                                    reasoningHeader.appendChild(copySpan);
                                    
                                    // 添加思考过程复制功能
                                    copySpan.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        const reasoningText = reasoningContent.querySelector('p').textContent;
                                        this.copyToClipboard(reasoningText.trim(), '思考过程');
                                    });
                                }
                            }
                            
                            // 更新消息的原始内容属性
                            const combinedContent = reasoningContent ? `思考过程：\n${reasoningContent.querySelector('p').textContent}\n\n回答：\n${fullContent}` : fullContent;
                            aiMessageElement.setAttribute('data-original-content', combinedContent);
                            
                            // 添加复制功能
                            this.addCopyFunctionality(aiMessageElement);
                            
                            // 将AI回复添加到历史记录
                            if (fullAIResponse.trim()) {
                                this.addToHistory('assistant', fullAIResponse);
                            }
                            this.stopGeneration();
                        }
                    } catch (error) {
                        console.log('捕获到错误:', error);
                        
                        // 检查是否是因为取消导致的错误
                        if (error.name === 'AbortError' || this.abortController?.signal.aborted) {
                            console.log('API调用被用户取消');
                            // 不显示错误消息，因为用户主动取消
                            // 保持已生成的消息不变
                            // 将临时消息标记为永久消息，防止被清除
                            if (aiMessageElement) {
                                aiMessageElement.classList.remove('temporary-message');
                                aiMessageElement.removeAttribute('data-temporary');
                                // 更新原始内容属性（包含思考过程和正常内容）
                                const combinedContent = reasoningContent ? `思考过程：\n${reasoningContent}\n\n回答：\n${fullContent}` : fullContent;
                                aiMessageElement.setAttribute('data-original-content', combinedContent);
                            }
                            
                            // 如果有部分回复，添加到历史记录
                            if (fullAIResponse.trim()) {
                                this.addToHistory('assistant', fullAIResponse);
                            }
                            
                            // 添加复制按钮到主内容区域
                            const mainContent = aiMessageElement.querySelector('.main-content p');
                            if (mainContent && !mainContent.querySelector('.message-actions')) {
                                const copySpan = document.createElement('span');
                                copySpan.className = 'message-actions';
                                copySpan.setAttribute('title', '复制');
                                copySpan.textContent = '📋复制';
                                mainContent.appendChild(copySpan);
                                
                                // 添加重新生成按钮
                                const regenerateSpan = document.createElement('span');
                                regenerateSpan.className = 'message-actions';
                                regenerateSpan.setAttribute('title', '重新生成');
                                regenerateSpan.textContent = '🔄重新生成';
                                regenerateSpan.style.marginLeft = '15px';
                                mainContent.appendChild(regenerateSpan);
                            }
                            
                            // 为思考过程添加复制按钮
                            const reasoningContent = aiMessageElement.querySelector('.reasoning-content');
                            if (reasoningContent && reasoningContent.style.display !== 'none') {
                                const reasoningHeader = reasoningContent.parentElement.querySelector('.reasoning-header');
                                if (reasoningHeader && !reasoningHeader.querySelector('.reasoning-copy')) {
                                    const copySpan = document.createElement('span');
                                    copySpan.className = 'reasoning-copy';
                                    copySpan.setAttribute('title', '复制思考过程');
                                    copySpan.textContent = '📋';
                                    copySpan.style.cursor = 'pointer';
                                    copySpan.style.marginLeft = '10px';
                                    reasoningHeader.appendChild(copySpan);
                                    
                                    // 添加思考过程复制功能
                                    copySpan.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        const reasoningText = reasoningContent.querySelector('p').textContent;
                                        this.copyToClipboard(reasoningText.trim(), '思考过程');
                                    });
                                }
                            }
                            
                            // 更新消息的原始内容属性
                            const reasoningText = reasoningContent ? reasoningContent.querySelector('p').textContent : '';
                            const combinedContent = reasoningText ? `思考过程：\n${reasoningText}\n\n回答：\n${fullContent}` : fullContent;
                            aiMessageElement.setAttribute('data-original-content', combinedContent);
                            
                            // 添加复制功能
                            this.addCopyFunctionality(aiMessageElement);
                            return;
                        }
                        
                        // 停止生成但不移除已显示的消息
                        this.stopGeneration();
                        
                        // 将临时消息标记为永久消息，防止被清除
                        if (aiMessageElement) {
                            aiMessageElement.classList.remove('temporary-message');
                            aiMessageElement.removeAttribute('data-temporary');
                            // 更新原始内容属性（包含思考过程和正常内容）
                            const combinedContent = reasoningContent ? `思考过程：\n${reasoningContent}\n\n回答：\n${fullContent}` : fullContent;
                            aiMessageElement.setAttribute('data-original-content', combinedContent);
                        }
                        
                        // 如果有部分回复且不是被用户取消的，添加到历史记录
                        if (fullAIResponse.trim() && !this.abortController?.signal.aborted) {
                            this.addToHistory('assistant', fullAIResponse);
                        }
                        
                        // 添加复制按钮到主内容区域
                        const mainContent = aiMessageElement.querySelector('.main-content p');
                        if (mainContent && !mainContent.querySelector('.message-actions')) {
                            const copySpan = document.createElement('span');
                            copySpan.className = 'message-actions';
                            copySpan.setAttribute('title', '复制');
                            copySpan.textContent = '📋复制';
                            mainContent.appendChild(copySpan);
                            
                            // 添加重新生成按钮
                            const regenerateSpan = document.createElement('span');
                            regenerateSpan.className = 'message-actions';
                            regenerateSpan.setAttribute('title', '重新生成');
                            regenerateSpan.textContent = '🔄重新生成';
                            regenerateSpan.style.marginLeft = '15px';
                            mainContent.appendChild(regenerateSpan);
                        }
                        
                        // 为思考过程添加复制按钮
                        const reasoningContent = aiMessageElement.querySelector('.reasoning-content');
                        if (reasoningContent && reasoningContent.style.display !== 'none') {
                            const reasoningHeader = reasoningContent.parentElement.querySelector('.reasoning-header');
                            if (reasoningHeader && !reasoningHeader.querySelector('.reasoning-copy')) {
                                const copySpan = document.createElement('span');
                                copySpan.className = 'reasoning-copy';
                                copySpan.setAttribute('title', '复制思考过程');
                                copySpan.textContent = '📋';
                                copySpan.style.cursor = 'pointer';
                                copySpan.style.marginLeft = '10px';
                                reasoningHeader.appendChild(copySpan);
                                
                                // 添加思考过程复制功能
                                copySpan.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    const reasoningText = reasoningContent.querySelector('p').textContent;
                                    this.copyToClipboard(reasoningText.trim(), '思考过程');
                                });
                            }
                        }
                        
                        // 更新消息的原始内容属性
                        const reasoningText = reasoningContent ? reasoningContent.querySelector('p').textContent : '';
                        const combinedContent = reasoningText ? `思考过程：\n${reasoningText}\n\n回答：\n${fullContent}` : fullContent;
                        aiMessageElement.setAttribute('data-original-content', combinedContent);
                        
                        // 添加复制功能
                        this.addCopyFunctionality(aiMessageElement);
                        
                        // 显示错误信息，但不移除已生成的消息
                        this.addMessage(`API调用失败: ${error.message}\n\n提示：请检查API配置或网络连接。`, 'ai');
                    }
                },

                // 显示AI思考中的加载动画
                showThinkingIndicator() {
                    // 检查是否已存在思考指示器
                    if (document.querySelector('.thinking-indicator')) {
                        return;
                    }

                    const thinkingDiv = document.createElement('div');
                    thinkingDiv.className = 'thinking-indicator';
                    thinkingDiv.innerHTML = `
                        <span class="ai-avatar">🤖</span>
                        <span>AI正在思考</span>
                        <div class="thinking-dots">
                            <div class="thinking-dot"></div>
                            <div class="thinking-dot"></div>
                            <div class="thinking-dot"></div>
                        </div>
                    `;
                    
                    App.elements.chatMessages.appendChild(thinkingDiv);
                    App.elements.chatMessages.scrollTop = App.elements.chatMessages.scrollHeight;
                },

                // 隐藏AI思考中的加载动画
                hideThinkingIndicator() {
                    const thinkingIndicator = document.querySelector('.thinking-indicator');
                    if (thinkingIndicator) {
                        thinkingIndicator.remove();
                    }
                },

                addMessage(content, sender, isTemporary = false) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = sender === 'user' ? 'user-message' : 'ai-message';
                    
                    // 生成唯一消息ID
                    const messageId = Date.now().toString() + Math.random().toString(36).substring(2);
                    messageDiv.setAttribute('data-message-id', messageId);
                    
                    // 如果是临时消息，添加特殊标记
                    if (isTemporary) {
                        messageDiv.classList.add('temporary-message');
                        messageDiv.setAttribute('data-temporary', 'true');
                    }
                    
                    // 添加停止时的保护标记
                    if (this.isGenerating) {
                        messageDiv.setAttribute('data-protected', 'true');
                    }
                    
                    // 存储原始内容，用于复制
                    messageDiv.setAttribute('data-original-content', content);
                    
                    // 检查消息是否过长，仅对用户消息添加折叠功能
                    const isLongMessage = sender === 'user' && content.length > 200;
                    const messageClass = isLongMessage ? 'collapsed-message' : '';
                    
                    // 处理长文本，确保正确换行，保留Markdown格式
                    const processedContent = content
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                    
                    // 处理换行和空格，但保留Markdown格式
                    const formattedContent = processedContent
                        .replace(/\n/g, '<br>')
                        .replace(/  /g, '&nbsp;&nbsp;');
                    
                    if (sender === 'user') {
                        // 将折叠功能移到消息文字的正上方，头像移到最右边
                        messageDiv.innerHTML = `
                            <div class="user-content ${messageClass}">
                                ${isLongMessage ? '<div class="expand-controls"><span class="message-actions" title="复制">📋复制</span><span class="message-action-icon expand-toggle" title="展开">v</span> <span class="expand-indicator">点击 v 展开完整内容</span></div>' : ''}
                                <p>${formattedContent}${!isLongMessage ? '<span class="message-actions" title="复制">📋复制</span> <span class="message-actions" title="编辑" style="margin-left: 15px;">✏️编辑</span>' : ''}</p>
                            </div>
                            <span class="user-avatar">👤</span>
                        `;
                    } else {
                        // AI消息结构，包含思考过程和正常内容的容器
                        messageDiv.innerHTML = `
                            <span class="ai-avatar">🤖</span>
                            <div class="message-content">
                                <!-- 正常内容容器 -->
                                <div class="main-content">
                                    <p>${formattedContent}</p>
                                </div>
                            </div>
                        `;
                    }
                    
                    App.elements.chatMessages.appendChild(messageDiv);
                    // 使用智能滚动而不是强制滚动
                    this.smartScrollToBottom();
                    
                    // 添加复制功能
                    this.addCopyFunctionality(messageDiv);
                    
                    // 添加展开/折叠功能（仅用户消息）
                    if (isLongMessage) {
                        this.addToggleFunctionality(messageDiv);
                    }
                    
                    // 返回消息ID，用于可能的后续操作（如删除临时消息）
                    return messageId;
                },
                
                // 更新思考过程内容
                updateReasoningContent(aiMessageElement, content) {
                    if (!aiMessageElement) return;
                    
                    // 查找或创建思考过程容器
                    let reasoningContainer = aiMessageElement.querySelector('.reasoning-container');
                    let reasoningContentElement = reasoningContainer?.querySelector('.reasoning-content p');
                    
                    // 如果思考过程容器不存在，创建它
                    if (!reasoningContainer) {
                        const messageContent = aiMessageElement.querySelector('.message-content');
                        if (messageContent) {
                            // 创建思考过程容器
                            reasoningContainer = document.createElement('div');
                            reasoningContainer.className = 'reasoning-container';
                            reasoningContainer.style.display = 'block'; // 确保容器可见
                            reasoningContainer.innerHTML = `
                                <div class="reasoning-header">
                                    <span class="reasoning-toggle">^</span>
                                    <span class="reasoning-title">思考过程</span>
                                </div>
                                <div class="reasoning-content" style="display: block;">
                                    <p></p>
                                </div>
                            `;
                            
                            // 将思考过程容器插入到正常内容之前
                            const mainContent = messageContent.querySelector('.main-content');
                            if (mainContent) {
                                messageContent.insertBefore(reasoningContainer, mainContent);
                            } else {
                                // 如果没有主内容容器，直接添加
                                messageContent.appendChild(reasoningContainer);
                            }
                            
                            reasoningContentElement = reasoningContainer.querySelector('.reasoning-content p');
                            
                            // 添加折叠/展开功能
                            this.addReasoningToggleFunctionality(reasoningContainer);
                        }
                    }
                    
                    // 更新思考过程内容
                    if (reasoningContentElement && content && content.trim()) {
                        // 使用文本节点追加内容，与正常内容处理方式保持一致
                        if (!reasoningContentElement.textContent) {
                            reasoningContentElement.textContent = content;
                        } else {
                            reasoningContentElement.textContent += content;
                        }
                        
                        // 显示思考过程容器和内容
                        reasoningContainer.style.display = 'block';
                        const reasoningContent = reasoningContainer.querySelector('.reasoning-content');
                        if (reasoningContent) {
                            reasoningContent.style.display = 'block';
                        }
                        
                        // 确保思考过程有复制按钮
                        const reasoningHeader = reasoningContainer.querySelector('.reasoning-header');
                        if (reasoningHeader && !reasoningHeader.querySelector('.reasoning-copy')) {
                            const copySpan = document.createElement('span');
                            copySpan.className = 'reasoning-copy';
                            copySpan.setAttribute('title', '复制思考过程');
                            copySpan.textContent = '📋';
                            copySpan.style.cursor = 'pointer';
                            copySpan.style.marginLeft = '10px';
                            reasoningHeader.appendChild(copySpan);
                            
                            // 添加思考过程复制功能
                            copySpan.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const reasoningText = reasoningContentElement.textContent;
                                this.copyToClipboard(reasoningText.trim(), '思考过程');
                            });
                        }
                        
                        // 滚动到底部
                        //App.elements.chatMessages.scrollTop = App.elements.chatMessages.scrollHeight;
                    }
                },
                
                // 添加思考过程折叠/展开功能
                addReasoningToggleFunctionality(reasoningContainer) {
                    const toggle = reasoningContainer.querySelector('.reasoning-toggle');
                    const content = reasoningContainer.querySelector('.reasoning-content');
                    const header = reasoningContainer.querySelector('.reasoning-header');
                    
                    if (toggle && content && header) {
                        // 添加回展按钮
                        if (!header.querySelector('.reasoning-track')) {
                            const trackSpan = document.createElement('span');
                            trackSpan.className = 'reasoning-track';
                            trackSpan.setAttribute('title', '回展位置');
                            trackSpan.textContent = '↩';
                            trackSpan.style.cursor = 'pointer';
                            trackSpan.style.marginLeft = '10px';
                            trackSpan.style.fontSize = '14px';
                            header.appendChild(trackSpan);
                            
                            // 添加回展功能 - 记录整个AI消息元素的位置
                            trackSpan.addEventListener('click', (e) => {
                                e.stopPropagation();
                                // 记录整个AI消息元素的位置（而不是仅仅思考过程容器）
                                const aiMessageElement = reasoningContainer.closest('.ai-message');
                                if (aiMessageElement) {
                                    App.chatTracking.trackExpandedMessage(aiMessageElement);
                                }
                                
                                // 滚动到思考过程位置
                                const messageRect = reasoningContainer.getBoundingClientRect();
                                const chatMessages = App.elements.chatMessages;
                                const chatRect = chatMessages.getBoundingClientRect();
                                
                                // 计算思考过程相对于聊天容器的位置
                                const relativeTop = messageRect.top - chatRect.top + chatMessages.scrollTop;
                                
                                // 平滑滚动到思考过程位置
                                chatMessages.scrollTo({
                                    top: relativeTop - 50, // 稍微向上偏移，确保思考过程完全可见
                                    behavior: 'smooth'
                                });
                                
                                // 添加视觉反馈
                                App.chatTracking.addVisualFeedback(reasoningContainer);
                            });
                        }
                        
                        // 为整个header添加点击展开/关闭功能，并记录位置
                        header.addEventListener('click', (e) => {
                            // 如果点击的是回展按钮或复制按钮，不触发展开/关闭
                            if (e.target.classList.contains('reasoning-track') || e.target.classList.contains('reasoning-copy')) {
                                return;
                            }
                            
                            e.stopPropagation();
                            
                            // 记录整个AI消息元素的位置，无论展开还是折叠
                            const aiMessageElement = reasoningContainer.closest('.ai-message');
                            if (aiMessageElement) {
                                App.chatTracking.trackExpandedMessage(aiMessageElement);
                            }
                            
                            if (content.style.display === 'none') {
                                // 展开思考过程
                                content.style.display = 'block';
                                toggle.textContent = '^';
                                toggle.setAttribute('title', '回展位置');
                            } else {
                                // 折叠思考过程
                                content.style.display = 'none';
                                toggle.textContent = '>';
                                toggle.setAttribute('title', '展开思考过程');
                            }
                        });
                        
                        // 修改toggle按钮点击功能，使其也能记录位置
                        toggle.addEventListener('click', (e) => {
                            e.stopPropagation();
                            
                            // 记录整个AI消息元素的位置
                            const aiMessageElement = reasoningContainer.closest('.ai-message');
                            if (aiMessageElement) {
                                App.chatTracking.trackExpandedMessage(aiMessageElement);
                            }
                            
                            if (content.style.display === 'none') {
                                // 展开思考过程
                                content.style.display = 'block';
                                toggle.textContent = '^';
                                toggle.setAttribute('title', '回展位置');
                            } else {
                                // 折叠思考过程
                                content.style.display = 'none';
                                toggle.textContent = '>';
                                toggle.setAttribute('title', '展开思考过程');
                            }
                        });
                    }
                },
                
                removeMessage(messageId) {
                    // 通过查找包含指定ID的消息来删除
                    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                    if (messageElement) {
                        messageElement.remove();
                    }
                },
                
                copyToClipboard(text, type = '内容') {
                    try {
                        navigator.clipboard.writeText(text).then(() => {
                            App.calculator.showSuccessMessage(`已复制${type}到剪贴板！`);
                        }).catch(err => {
                            // 降级方案
                            const textArea = document.createElement('textarea');
                            textArea.value = text;
                            document.body.appendChild(textArea);
                            textArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textArea);
                            App.calculator.showSuccessMessage(`已复制${type}到剪贴板！`);
                        });
                    } catch (err) {
                        console.error('复制失败:', err);
                        App.calculator.showSuccessMessage('复制失败，请手动复制');
                    }
                },

                addCopyFunctionality(messageDiv) {
                    // 复制功能
                    const copyAction = messageDiv.querySelector('.message-actions[title="复制"]');
                    if (copyAction) {
                        copyAction.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            // 获取主内容区域，不包含思考过程
                            const mainContent = messageDiv.querySelector('.main-content p');
                            if (mainContent) {
                                // 获取主内容的文本，去除HTML标签和复制按钮
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = mainContent.innerHTML;
                                // 移除复制按钮
                                const copyButtons = tempDiv.querySelectorAll('.message-actions');
                                copyButtons.forEach(btn => btn.remove());
                                // 获取纯文本内容
                                const messageText = tempDiv.textContent || tempDiv.innerText || '';
                                
                                this.copyToClipboard(messageText.trim(), '回复内容');
                            }
                        });
                    }
                    
                    // 编辑功能 - 仅用户消息
                    const editAction = messageDiv.querySelector('.message-actions[title="编辑"]');
                    if (editAction) {
                        editAction.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            
                            // 获取用户消息内容
                            const userContent = messageDiv.querySelector('.user-content p');
                            if (userContent) {
                                // 获取纯文本内容，去除HTML标签和按钮
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = userContent.innerHTML;
                                // 移除所有按钮
                                const buttons = tempDiv.querySelectorAll('.message-actions, .message-action-icon, .expand-indicator');
                                buttons.forEach(btn => btn.remove());
                                // 获取纯文本内容
                                const messageText = tempDiv.textContent || tempDiv.innerText || '';
                                
                                // 将内容放入输入框
                                App.elements.chatInput.value = messageText.trim();
                                App.elements.chatInput.focus();
                                
                                // 触发input事件以调整高度
                                App.elements.chatInput.dispatchEvent(new Event('input'));
                                
                                // 设置编辑模式，但不立即删除后续消息
                                this.isEditing = true;
                                this.editingMessageId = messageDiv.getAttribute('data-message-id');
                                
                                // 添加视觉提示，标记正在编辑的消息
                                messageDiv.style.border = '2px dashed rgba(241, 196, 15, 0.8)';
                                messageDiv.style.borderRadius = '8px';
                                messageDiv.style.padding = '5px';
                                messageDiv.style.backgroundColor = 'rgba(241, 196, 15, 0.1)';
                                
                                // 显示取消编辑的提示
                                App.calculator.showSuccessMessage('正在编辑消息，按 ESC 或点击外部区域取消编辑');
                                
                                // 更新输入框占位符
                                App.elements.chatInput.placeholder = '编辑中... 按 ESC 取消编辑';
                            }
                        });
                    }
                    
                    // 重新生成功能 - 仅AI消息
                    const regenerateAction = messageDiv.querySelector('.message-actions[title="重新生成"]');
                    if (regenerateAction) {
                        regenerateAction.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            
                            // 找到对应的用户消息
                            const userMessage = this.findPreviousUserMessage(messageDiv);
                            if (userMessage) {
                                // 获取用户消息内容
                                const userContent = userMessage.querySelector('.user-content p');
                                if (userContent) {
                                    const tempDiv = document.createElement('div');
                                    tempDiv.innerHTML = userContent.innerHTML;
                                    // 移除所有按钮
                                    const buttons = tempDiv.querySelectorAll('.message-actions, .message-action-icon, .expand-indicator');
                                    buttons.forEach(btn => btn.remove());
                                    // 获取纯文本内容
                                    const messageText = tempDiv.textContent || tempDiv.innerText || '';
                                    
                                    // 删除当前AI消息及其之后的所有消息（与编辑功能保持一致）
                                    this.removeMessagesAfter(userMessage);
                                    
                                    // 重新生成AI回复
                                    this.regenerateAIResponse(messageText.trim());
                                }
                            }
                        });
                    }
                },
                
                addToggleFunctionality(messageDiv) {
                    const toggleIcon = messageDiv.querySelector('.expand-toggle');
                    const userContent = messageDiv.querySelector('.user-content');
                    const expandIndicator = messageDiv.querySelector('.expand-indicator');
                    
                    if (toggleIcon && userContent) {
                        toggleIcon.addEventListener('click', (e) => {
                            e.stopPropagation();
                            
                            // 跟踪当前消息元素
                            App.chatTracking.trackExpandedMessage(messageDiv);
                            
                            if (userContent.classList.contains('collapsed-message')) {
                                // 展开消息
                                userContent.classList.remove('collapsed-message');
                                toggleIcon.textContent = 'v';
                                toggleIcon.setAttribute('title', '折叠');
                                if (expandIndicator) {
                                    expandIndicator.textContent = '点击 v 折叠内容';
                                }
                            } else {
                                // 折叠消息
                                userContent.classList.add('collapsed-message');
                                toggleIcon.textContent = 'v';
                                toggleIcon.setAttribute('title', '展开');
                                if (expandIndicator) {
                                    expandIndicator.textContent = '点击 v 展开完整内容';
                                }
                            }
                        });
                        
                        if (expandIndicator) {
                            expandIndicator.addEventListener('click', (e) => {
                                e.stopPropagation();
                                toggleIcon.click();
                            });
                        }
                    }
                },

                // 删除指定消息之后的所有消息
                removeMessagesAfter(messageDiv) {
                    // 找到当前消息之后的所有消息
                    let nextElement = messageDiv.nextElementSibling;
                    const messagesToRemove = [];
                    
                    // 收集需要删除的消息
                    while (nextElement) {
                        if (nextElement.classList.contains('ai-message') || nextElement.classList.contains('user-message')) {
                            messagesToRemove.push(nextElement);
                            nextElement = nextElement.nextElementSibling;
                        } else {
                            break;
                        }
                    }
                    
                    // 删除收集到的消息
                    messagesToRemove.forEach(msg => msg.remove());
                    
                    // 从历史记录中移除相关消息
                    if (messagesToRemove.length > 0) {
                        // 移除最后几条历史记录
                        this.conversationHistory = this.conversationHistory.slice(0, -messagesToRemove.length);
                    }
                },
                
                // 编辑后更新历史记录
                updateHistoryAfterEdit(messageId, newContent) {
                    // 获取编辑的消息元素
                    const editingMessageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                    if (!editingMessageElement) return;
                    
                    // 找到这个消息元素在聊天界面中的位置
                    let position = 0;
                    let currentElement = App.elements.chatMessages.firstElementChild;
                    
                    while (currentElement) {
                        if (currentElement === editingMessageElement) {
                            break;
                        }
                        if (currentElement.classList.contains('user-message') || currentElement.classList.contains('ai-message')) {
                            position++;
                        }
                        currentElement = currentElement.nextElementSibling;
                    }
                    
                    // 计算在历史记录数组中的对应位置
                    let historyIndex = 0;
                    let userMessageCount = 0;
                    
                    // 遍历历史记录，找到第N个用户消息的位置
                    for (let i = 0; i < this.conversationHistory.length; i++) {
                        if (this.conversationHistory[i].role === 'user') {
                            if (userMessageCount === Math.floor(position / 2)) {
                                historyIndex = i;
                                break;
                            }
                            userMessageCount++;
                        }
                    }
                    
                    // 更新对应位置的历史记录
                    if (historyIndex < this.conversationHistory.length && 
                        this.conversationHistory[historyIndex].role === 'user') {
                        this.conversationHistory[historyIndex].content = newContent;
                    }
                },
                
                // 确保用户消息在历史记录末尾
                ensureUserMessageAtEnd(message) {
                    // 检查是否是数学相关问题，如果是，添加当前表达式上下文
                    let enhancedMessage = message;
                    const currentExpression = App.elements.expressionInput.value.trim();
                    const currentOperation = App.elements.operationSelect.value;
                    
                    if (currentExpression && this.isMathRelatedQuestion(message)) {
                        enhancedMessage = `${message}\n\n当前计算器中的表达式: ${currentExpression}\n计算类型: ${this.getOperationName(currentOperation)}`;
                    }
                    
                    // 检查历史记录的最后一条是否是用户消息且内容匹配
                    const lastHistoryEntry = this.conversationHistory[this.conversationHistory.length - 1];
                    if (!lastHistoryEntry || lastHistoryEntry.role !== 'user' || lastHistoryEntry.content !== enhancedMessage) {
                        // 如果不匹配，将用户消息添加到历史记录末尾
                        this.addToHistory('user', enhancedMessage);
                    }
                },
                
                // 编辑用户消息功能（保留以备后用）
                editUserMessage(userMessageDiv) {
                    // 找到当前用户消息之后的所有消息
                    let nextElement = userMessageDiv.nextElementSibling;
                    const messagesToRemove = [];
                    
                    // 收集需要删除的消息
                    while (nextElement) {
                        if (nextElement.classList.contains('ai-message') || nextElement.classList.contains('user-message')) {
                            messagesToRemove.push(nextElement);
                            nextElement = nextElement.nextElementSibling;
                        } else {
                            break;
                        }
                    }
                    
                    // 删除收集到的消息
                    messagesToRemove.forEach(msg => msg.remove());
                    
                    // 从历史记录中移除相关消息
                    if (messagesToRemove.length > 0) {
                        // 移除最后几条历史记录
                        this.conversationHistory = this.conversationHistory.slice(0, -messagesToRemove.length);
                    }
                },
                
                // 查找消息在历史记录中的索引
                findMessageIndexInHistory(messageDiv, role) {
                    // 获取消息元素在聊天界面中的位置
                    let position = 0;
                    let currentElement = App.elements.chatMessages.firstElementChild;
                    
                    while (currentElement) {
                        if (currentElement === messageDiv) {
                            break;
                        }
                        if (currentElement.classList.contains('user-message') || currentElement.classList.contains('ai-message')) {
                            position++;
                        }
                        currentElement = currentElement.nextElementSibling;
                    }
                    
                    // 计算在历史记录数组中的对应位置
                    let historyIndex = 0;
                    let roleMessageCount = 0;
                    
                    // 遍历历史记录，找到第N个指定角色的消息的位置
                    for (let i = 0; i < this.conversationHistory.length; i++) {
                        if (this.conversationHistory[i].role === role) {
                            if (roleMessageCount === Math.floor(position / 2)) {
                                historyIndex = i;
                                break;
                            }
                            roleMessageCount++;
                        }
                    }
                    
                    return historyIndex;
                },

                // 重新生成AI回复功能
                async regenerateAIResponse(userMessage) {
                    // 检查用户消息是否已在历史记录中，如果没有则添加
                    const lastHistoryEntry = this.conversationHistory[this.conversationHistory.length - 1];
                    if (!lastHistoryEntry || lastHistoryEntry.role !== 'user' || lastHistoryEntry.content !== userMessage) {
                        // 检查是否是数学相关问题，如果是，添加当前表达式上下文
                        let enhancedMessage = userMessage;
                        const currentExpression = App.elements.expressionInput.value.trim();
                        const currentOperation = App.elements.operationSelect.value;
                        
                        if (currentExpression && this.isMathRelatedQuestion(userMessage)) {
                            enhancedMessage = `${userMessage}\n\n当前计算器中的表达式: ${currentExpression}\n计算类型: ${this.getOperationName(currentOperation)}`;
                        }
                        
                        // 将用户消息添加到历史记录
                        this.addToHistory('user', enhancedMessage);
                    }
                    
                    // 开始生成
                    this.startGeneration();
                    
                    // 构建包含历史上下文的消息（不重复添加用户消息）
                    const contextualMessages = this.buildContextualMessageWithoutUser(userMessage);
                    
                    try {
                        // 调用流式API
                        await this.callStreamAPI(contextualMessages);
                    } catch (error) {
                        console.log('重新生成时捕获到错误:', error);
                        
                        // 检查是否是因为取消导致的错误
                        if (error.name === 'AbortError' || this.abortController?.signal.aborted) {
                            console.log('API调用被用户取消');
                            return;
                        }
                        
                        // 停止生成
                        this.stopGeneration();
                        
                        // 显示错误信息
                        this.addMessage(`API调用失败: ${error.message}\n\n提示：请检查API配置或网络连接。`, 'ai');
                    }
                },
                
                // 查找前一个用户消息
                findPreviousUserMessage(aiMessageDiv) {
                    let prevElement = aiMessageDiv.previousElementSibling;
                    
                    // 向前查找用户消息
                    while (prevElement) {
                        if (prevElement.classList.contains('user-message')) {
                            return prevElement;
                        }
                        prevElement = prevElement.previousElementSibling;
                    }
                    
                    return null;
                },

                generateAIResponse(userMessage) {
                    const responses = [
                        "我理解您的问题。让我帮您分析一下...",
                        "这是一个很好的问题！根据我的分析...",
                        "我来为您提供一些有用的信息...",
                        "让我思考一下如何最好地帮助您...",
                        "基于您的需求，我建议..."
                    ];
                    return responses[Math.floor(Math.random() * responses.length)];
                }
            },

            // 事件处理
            events: {
                setup() {
                    // 初始化显示
                    App.elements.volumeValue.textContent = `${App.elements.volumeControl.value}%`;
                    App.elements.vibrationValue.textContent = App.elements.vibrationStrength.value;

                    // 音量控制
                    App.elements.volumeControl.addEventListener('input', () => {
                        App.elements.volumeValue.textContent = `${App.elements.volumeControl.value}%`;
                        if (App.audio.gainNode) {
                            App.audio.gainNode.value = App.elements.volumeControl.value / 100 * 0.2;
                        }
                    });

                    // 震动强度控制
                    App.elements.vibrationStrength.addEventListener('input', () => {
                        App.elements.vibrationValue.textContent = App.elements.vibrationStrength.value;
                    });

                    // 设置按钮
                    App.elements.settingsButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        App.vibration.trigger(App.elements.vibrateMode.value);
                        App.elements.settingsPanel.classList.toggle('active');
                    });

                    // 搜索按钮
                    App.elements.searchButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        App.vibration.trigger(App.elements.vibrateMode.value);
                        App.elements.searchPanel.classList.toggle('active');
                        App.search.updateHistory();
                    });

                    // AIOS按钮
                    App.elements.aiosButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        App.vibration.trigger(App.elements.vibrateMode.value);
                        const isActive = App.elements.aiosPanel.classList.toggle('active');
                        
                        // 显示或隐藏关闭按钮
                        if (isActive) {
                            App.elements.closeAiosLeftBtn.style.display = 'flex';
                            App.elements.closeAiosRightBtn.style.display = 'flex';
                        } else {
                            App.elements.closeAiosLeftBtn.style.display = 'none';
                            App.elements.closeAiosRightBtn.style.display = 'none';
                        }
                    });

                    // AIOS聊天功能已在setupSendButton中处理
                    
                    // 添加键盘快捷键支持
                    App.elements.chatInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && e.ctrlKey) {
                            e.preventDefault();
                            App.chat.sendMessage();
                        } else if (e.key === 'Escape') {
                            // ESC键停止生成或取消编辑
                            e.preventDefault();
                            if (App.chat.isGenerating) {
                                App.chat.stopGeneration();
                            } else if (App.chat.isEditing) {
                                App.chat.cancelEdit();
                            }
                        } else if (e.key === 'Enter' && e.shiftKey) {
                            // Shift+Enter发送消息
                            e.preventDefault();
                            App.chat.sendMessage();
                        } else if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey) {
                            // 普通回车换行，不发送
                            return;
                        }
                    });
                    
                    // 自动调整输入框高度
                    App.elements.chatInput.addEventListener('input', function() {
                        this.style.height = 'auto';
                        this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                    });
                    
                    // 点击外部区域取消编辑
                    document.addEventListener('click', (e) => {
                        // 如果处于编辑模式
                        if (App.chat.isEditing) {
                            // 检查点击是否在聊天输入框或正在编辑的消息内
                            const isClickInInput = App.elements.chatInput.contains(e.target);
                            const isClickInEditingMessage = App.chat.editingMessageId && 
                                document.querySelector(`[data-message-id="${App.chat.editingMessageId}"]`)?.contains(e.target);
                            
                            // 如果点击不在输入框或编辑的消息内，则取消编辑
                            if (!isClickInInput && !isClickInEditingMessage) {
                                App.chat.cancelEdit();
                            }
                        }
                    });

                    // 数学快捷输入按钮事件
                    document.querySelectorAll('.math-shortcut').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const formula = this.getAttribute('data-formula');
                            const chatInput = App.elements.chatInput;
                            const start = chatInput.selectionStart;
                            const end = chatInput.selectionEnd;
                            const text = chatInput.value;
                            
                            // 在光标位置插入公式
                            chatInput.value = text.substring(0, start) + formula + text.substring(end);
                            chatInput.selectionStart = chatInput.selectionEnd = start + formula.length;
                            chatInput.focus();
                            
                            // 触发input事件以调整高度
                            chatInput.dispatchEvent(new Event('input'));
                            
                            App.audio.play(...App.elements.soundType.value.split(':'));
                        });
                    });


                    // API配置保存
                    App.elements.apiSaveBtn.addEventListener('click', async () => {
                        // 获取模型值，如果是自定义则使用输入框的值
                        let modelValue = App.elements.apiModel.value.trim();
                        if (modelValue === 'custom') {
                            modelValue = App.elements.customModel.value.trim();
                        }
                        
                        const config = {
                            url: App.elements.apiUrl.value.trim(),
                            key: App.elements.apiKey.value.trim(),
                            model: modelValue,
                            temperature: parseFloat(App.elements.apiTemperature.value),
                            maxTokens: parseInt(App.elements.apiMaxTokens.value)
                        };
                        
                        // 验证配置
                        if (!config.url || !config.key || !config.model) {
                            App.calculator.showSuccessMessage('请填写完整的API配置信息！');
                            return;
                        }
                        
                        // 显示保存中状态
                        App.elements.apiSaveBtn.textContent = '保存中...';
                        App.elements.apiSaveBtn.disabled = true;
                        
                        try {
                            // 测试API连接
                            const testResult = await App.apiConfig.testConnection(config);
                            
                            if (App.apiConfig.saveConfig(config)) {
                                App.calculator.showSuccessMessage('API配置已保存并连接成功！');
                                // 更新连接状态指示器
                                App.updateConnectionStatus(true);
                            } else {
                                App.calculator.showSuccessMessage('保存配置失败，请重试！');
                                App.updateConnectionStatus(false);
                            }
                        } catch (error) {
                            App.calculator.showSuccessMessage(`API连接测试失败: ${error.message}`);
                            App.updateConnectionStatus(false);
                        } finally {
                            // 恢复按钮状态
                            App.elements.apiSaveBtn.textContent = '保存配置';
                            App.elements.apiSaveBtn.disabled = false;
                        }
                        
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // 测试API连接按钮
                    App.elements.apiTestBtn.addEventListener('click', async () => {
                        // 获取模型值，如果是自定义则使用输入框的值
                        let modelValue = App.elements.apiModel.value.trim();
                        if (modelValue === 'custom') {
                            modelValue = App.elements.customModel.value.trim();
                        }
                        
                        const config = {
                            url: App.elements.apiUrl.value.trim(),
                            key: App.elements.apiKey.value.trim(),
                            model: modelValue,
                            temperature: parseFloat(App.elements.apiTemperature.value),
                            maxTokens: parseInt(App.elements.apiMaxTokens.value)
                        };
                        
                        // 验证配置
                        if (!config.url || !config.key || !config.model) {
                            App.calculator.showSuccessMessage('请填写完整的API配置信息！');
                            return;
                        }
                        
                        // 显示测试中状态
                        App.elements.apiTestBtn.textContent = '测试中...';
                        App.elements.apiTestBtn.disabled = true;
                        
                        try {
                            // 测试API连接
                            const testResult = await App.apiConfig.testConnection(config);
                            App.calculator.showSuccessMessage('API连接测试成功！');
                            App.updateConnectionStatus(true);
                        } catch (error) {
                            App.calculator.showSuccessMessage(`API连接测试失败: ${error.message}`);
                            App.updateConnectionStatus(false);
                        } finally {
                            // 恢复按钮状态
                            App.elements.apiTestBtn.textContent = '测试连接';
                            App.elements.apiTestBtn.disabled = false;
                        }
                        
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // API配置重置 - 修改为关闭API面板
                    App.elements.apiResetBtn.addEventListener('click', () => {
                        App.elements.apiPanel.classList.remove('active');
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // AIOS标签页切换
                    document.querySelectorAll('.aios-tab-btn').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const tabName = this.getAttribute('data-tab');
                            
                            // 切换按钮状态
                            document.querySelectorAll('.aios-tab-btn').forEach(b => b.classList.remove('active'));
                            this.classList.add('active');
                            
                            // 切换内容显示
                            document.querySelectorAll('.aios-tab-content').forEach(content => content.classList.remove('active'));
                            const targetTab = document.getElementById(`${tabName}-tab`);
                            if (targetTab) {
                                targetTab.classList.add('active');
                            }
                            
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        });
                    });

                    // AI工具点击事件
                    document.querySelectorAll('.ai-tool-item').forEach(item => {
                        item.addEventListener('click', function() {
                            const toolName = this.querySelector('.tool-name');
                            if (toolName) {
                                const toolNameText = toolName.textContent;
                                App.chat.addMessage(`我想要使用${toolNameText}功能`, 'user');
                                
                                // 根据不同工具提供特定功能
                                setTimeout(() => {
                                    let response = '';
                                    switch(toolNameText) {
                                        case '图像生成':
                                            response = '图像生成功能已启动！请描述您想要生成的图像，例如：\n• "生成一个数学函数的图像"\n• "创建一个几何图形"\n• "绘制一个数据可视化图表"';
                                            break;
                                        case '文本创作':
                                            response = '文本创作功能已启动！请告诉我您想要创作的文本类型，例如：\n• "数学公式解释"\n• "计算步骤说明"\n• "数学概念介绍"';
                                            break;
                                        case '音乐创作':
                                            response = '音乐创作功能已启动！请描述您想要创作的音乐，例如：\n• "生成一段数学节奏音乐"\n• "创建函数相关的旋律"\n• "制作几何图案音乐"';
                                            break;
                                        case '视频编辑':
                                            response = '视频编辑功能已启动！请告诉我您想要编辑的视频内容，例如：\n• "创建数学教学视频"\n• "制作函数动画"\n• "编辑几何演示"';
                                            break;
                                        case '语言翻译':
                                            response = '语言翻译功能已启动！请输入您想要翻译的数学术语或表达式，我将为您提供多语言翻译。';
                                            break;
                                        case '代码生成':
                                            response = '代码生成功能已启动！请告诉我您想要生成的代码类型，例如：\n• "数学计算函数"\n• "数据可视化代码"\n• "算法实现代码"';
                                            break;
                                        default:
                                            response = `${toolNameText}功能已启动！请告诉我您的具体需求。`;
                                    }
                                    App.chat.addMessage(response, 'ai');
                                }, 800);
                                
                                // 切换到聊天标签页
                                document.querySelectorAll('.aios-tab-btn').forEach(b => b.classList.remove('active'));
                                const chatTab = document.querySelector('[data-tab="chat"]');
                                if (chatTab) {
                                    chatTab.classList.add('active');
                                }
                                document.querySelectorAll('.aios-tab-content').forEach(c => c.classList.remove('active'));
                                const chatContent = document.getElementById('chat-tab');
                                if (chatContent) {
                                    chatContent.classList.add('active');
                                }
                                
                                App.audio.play(...App.elements.soundType.value.split(':'));
                                App.vibration.trigger(App.elements.vibrateMode.value);
                            }
                        });
                    });

                    // 数据分析工具按钮点击事件
                    document.querySelectorAll('.aios-tool-btn').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const toolCard = this.closest('.tool-card');
                            if (toolCard) {
                                const toolNameEl = toolCard.querySelector('h4');
                                if (toolNameEl) {
                                    const toolName = toolNameEl.textContent;
                                    
                                    App.chat.addMessage(`我想要使用${toolName}功能`, 'user');
                                    
                                    // 根据不同工具提供特定功能
                                    setTimeout(() => {
                                        let response = '';
                                        let currentExpression = App.elements.expressionInput.value.trim();
                                        
                                        switch(toolName) {
                                            case '数据可视化':
                                                response = '数据可视化功能已启动！我可以帮您：\n\n';
                                                response += '• 绘制函数图像：输入函数表达式，如 "sin(x)" 或 "x^2"\n';
                                                response += '• 创建数据图表：提供数据点，我将生成对应图表\n';
                                                response += '• 数学关系可视化：展示数学概念的可视化表示\n\n';
                                                if (currentExpression) {
                                                    response += `检测到当前表达式：${currentExpression}\n`;
                                                    response += '是否要为这个表达式创建可视化图表？';
                                                } else {
                                                    response += '请在计算器中输入表达式或直接告诉我您想要可视化的内容。';
                                                }
                                                break;
                                            case '智能搜索':
                                                response = '智能搜索功能已启动！我可以帮您：\n\n';
                                                response += '• 搜索数学公式和定理\n';
                                                response += '• 查找函数定义和性质\n';
                                                response += '• 探索数学概念和应用\n';
                                                response += '• 查找解题方法和步骤\n\n';
                                                response += '请告诉我您想要搜索的内容，例如："二次函数公式" 或 "积分定理"';
                                                break;
                                            case '快速计算':
                                                response = '快速计算功能已启动！我可以帮您：\n\n';
                                                response += '• 复杂表达式计算\n';
                                                response += '• 批量数值计算\n';
                                                response += '• 数学统计分析\n';
                                                response += '• 方程求解\n\n';
                                                if (currentExpression) {
                                                    response += `检测到当前表达式：${currentExpression}\n`;
                                                    response += '是否要使用AI增强计算功能来处理这个表达式？';
                                                } else {
                                                    response += '请输入您想要计算的数学表达式或描述您的计算需求。';
                                                }
                                                break;
                                            default:
                                                response = `${toolName}功能已启动！请提供相关数据或具体需求。`;
                                        }
                                        App.chat.addMessage(response, 'ai');
                                    }, 800);
                                    
                                    // 切换到聊天标签页
                                    document.querySelectorAll('.aios-tab-btn').forEach(b => b.classList.remove('active'));
                                    const chatTab = document.querySelector('[data-tab="chat"]');
                                    if (chatTab) {
                                        chatTab.classList.add('active');
                                    }
                                    document.querySelectorAll('.aios-tab-content').forEach(c => c.classList.remove('active'));
                                    const chatContent = document.getElementById('chat-tab');
                                    if (chatContent) {
                                        chatContent.classList.add('active');
                                    }
                                    
                                    App.audio.play(...App.elements.soundType.value.split(':'));
                                    App.vibration.trigger(App.elements.vibrateMode.value);
                                }
                            }
                        });
                    });

                    // 语音交互功能
                    App.elements.voiceBtn.addEventListener('click', () => {
                        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                            const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                            recognition.lang = 'zh-CN';
                            recognition.continuous = false;
                            recognition.interimResults = false;

                            recognition.onstart = () => {
                                App.elements.voiceBtn.textContent = '🎤 正在录音...';
                                App.elements.voiceBtn.style.background = 'rgba(231, 76, 60, 0.7)';
                            };

                            recognition.onresult = (event) => {
                                const transcript = event.results[0][0].transcript;
                                App.elements.chatInput.value = transcript;
                                App.chat.sendMessage();
                            };

                            recognition.onerror = () => {
                                App.elements.voiceBtn.textContent = '🎤 语音交互';
                                App.elements.voiceBtn.style.background = '';
                                alert('语音识别失败，请重试');
                            };

                            recognition.onend = () => {
                                App.elements.voiceBtn.textContent = '🎤 语音';
                                App.elements.voiceBtn.style.background = '';
                            };

                            recognition.start();
                        } else {
                            alert('您的浏览器不支持语音识别功能');
                        }
                        
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // 关闭AIOS面板 - 原有按钮
                    App.elements.closeAiosBtn.addEventListener('click', () => {
                        App.elements.aiosPanel.classList.remove('active');
                        App.elements.closeAiosLeftBtn.style.display = 'none';
                        App.elements.closeAiosRightBtn.style.display = 'none';
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // API配置按钮点击事件 - 修复冒泡问题
                    App.elements.apiConfigBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        App.elements.apiPanel.classList.add('active');
                        App.events.loadApiConfig();
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    // 处理模型选择变化
                    App.elements.apiModel.addEventListener('change', () => {
                        if (App.elements.apiModel.value === 'custom') {
                            App.elements.customModel.style.display = 'block';
                        } else {
                            App.elements.customModel.style.display = 'none';
                        }
                    });

                    // API面板关闭按钮
                    App.elements.apiCloseBtn.addEventListener('click', () => {
                        App.elements.apiPanel.classList.remove('active');
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    // 新增的左侧和右侧关闭按钮
                    const closeAiosPanel = () => {
                        App.elements.aiosPanel.classList.remove('active');
                        App.elements.closeAiosLeftBtn.style.display = 'none';
                        App.elements.closeAiosRightBtn.style.display = 'none';
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    };
                    
                    App.elements.closeAiosLeftBtn.addEventListener('click', closeAiosPanel);
                    App.elements.closeAiosRightBtn.addEventListener('click', closeAiosPanel);
                    
                    // 聊天导航按钮功能已通过CSS设置
                    
                    App.elements.chatTopBtn.addEventListener('click', () => {
                        const chatMessages = App.elements.chatMessages;
                        chatMessages.scrollTo({
                            top: 0,
                            behavior: 'smooth'
                        });
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    App.elements.chatBottomBtn.addEventListener('click', () => {
                        const chatMessages = App.elements.chatMessages;
                        chatMessages.scrollTo({
                            top: chatMessages.scrollHeight,
                            behavior: 'smooth'
                        });
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    // 聊天回展按钮功能
                    App.elements.chatTrackBtn.addEventListener('click', () => {
                        App.chatTracking.returnToPosition();
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    // 聊天清空按钮功能
                    App.elements.chatClearBtn.addEventListener('click', () => {
                        // 确认对话框
                        if (confirm('确定要清空所有聊天历史吗？此操作不可恢复。')) {
                            App.chat.clearHistory();
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        }
                    });

                    // 搜索功能事件
                    App.elements.searchBtn.addEventListener('click', () => {
                        const query = App.elements.searchInput.value.trim();
                        if (query) {
                            const results = App.search.perform(query, App.elements.searchCategory.value);
                            App.search.display(results);
                            App.search.addToHistory(query);
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        }
                    });
                    
                    App.elements.searchInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            App.elements.searchBtn.click();
                        }
                    });
                    
                    App.elements.searchCategory.addEventListener('change', () => {
                        const query = App.elements.searchInput.value.trim();
                        if (query) {
                            const results = App.search.perform(query, App.elements.searchCategory.value);
                            App.search.display(results);
                        }
                    });
                    
                    App.elements.searchHistory.addEventListener('change', (e) => {
                        if (e.target.value) {
                            App.elements.searchInput.value = e.target.value;
                            App.elements.searchBtn.click();
                        }
                    });
                    
                    App.elements.clearSearchBtn.addEventListener('click', () => App.search.clear());
                    
                    App.elements.closeSearchBtn.addEventListener('click', () => {
                        App.elements.searchPanel.classList.remove('active');
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // 预览按钮事件
                    App.elements.previewVibrationBtn.addEventListener('click', () => {
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    App.elements.previewSoundBtn.addEventListener('click', () => {
                        const [type, freq] = App.elements.soundType.value.split(':');
                        App.audio.play(type, freq, 1.0);
                    });

                    // 使用事件委托处理按钮点击
                    document.addEventListener('click', (e) => {
                        const target = e.target;
                        
                        if (target.id === 'calculate') {
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        } else if (target.id === 'clear') {
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        } else if (target.id === 'paste') {
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        }
                        
                        // 为所有示例按钮添加声音和振动
                        if (target.classList.contains('example')) {
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        }
                        
                        // 为所有复制按钮添加声音和振动
                        if (target.classList.contains('copy-icon')) {
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        }
                    });
                },

                setupOutsideClick() {
                    // 点击外部关闭面板
                    document.addEventListener('click', (e) => {
                        // 关闭AIOS面板
                        if (!App.elements.aiosPanel.contains(e.target) && 
                            !App.elements.aiosButton.contains(e.target) && 
                            !App.elements.closeAiosLeftBtn.contains(e.target) &&
                            !App.elements.closeAiosRightBtn.contains(e.target) &&
                            !App.elements.apiConfigBtn.contains(e.target) &&
                            !App.elements.apiPanel.contains(e.target) &&
                            App.elements.aiosPanel.classList.contains('active')) {
                            App.elements.aiosPanel.classList.remove('active');
                            App.elements.closeAiosLeftBtn.style.display = 'none';
                            App.elements.closeAiosRightBtn.style.display = 'none';
                        }
                        
                        // 关闭API配置面板
                        if (!App.elements.apiPanel.contains(e.target) && 
                            !App.elements.apiConfigBtn.contains(e.target) && 
                            App.elements.apiPanel.classList.contains('active')) {
                            App.elements.apiPanel.classList.remove('active');
                        }
                        
                        // 关闭搜索面板
                        if (!App.elements.searchPanel.contains(e.target) && 
                            !App.elements.searchButton.contains(e.target) && 
                            App.elements.searchPanel.classList.contains('active')) {
                            App.elements.searchPanel.classList.remove('active');
                        }
                        
                        // 关闭设置面板
                        if (!App.elements.settingsPanel.contains(e.target) && 
                            !App.elements.settingsButton.contains(e.target) && 
                            App.elements.settingsPanel.classList.contains('active')) {
                            App.elements.settingsPanel.classList.remove('active');
                        }
                    });
                },
                
                loadApiConfig() {
                    const config = App.apiConfig.getConfig();
                    App.elements.apiUrl.value = config.url;
                    App.elements.apiKey.value = config.key;
                    App.elements.apiTemperature.value = config.temperature;
                    App.elements.apiMaxTokens.value = config.maxTokens;
                    
                    // 处理模型值
                    const modelValue = config.model;
                    const isCustomOption = !document.querySelector(`#apiModel option[value="${modelValue}"]`);
                    
                    if (isCustomOption) {
                        App.elements.apiModel.value = 'custom';
                        App.elements.customModel.value = modelValue;
                        App.elements.customModel.style.display = 'block';
                    } else {
                        App.elements.apiModel.value = modelValue;
                        App.elements.customModel.style.display = 'none';
                    }
                }
            },

            // 修复不完整JSON的辅助方法
            fixIncompleteJson(jsonStr, fullBuffer, startIndex) {
                // 在完整缓冲区中查找匹配的开始位置
                const fullMatch = fullBuffer.substring(startIndex);
                const dataMatch = fullMatch.match(/^data:\s*(\{.*)/);
                
                if (!dataMatch) return null;
                
                let potentialJson = dataMatch[1];
                let braceCount = 0;
                let inString = false;
                let escapeNext = false;
                let endIndex = 0;
                
                // 逐字符分析，找到匹配的结束括号
                for (let i = 0; i < potentialJson.length; i++) {
                    const char = potentialJson[i];
                    
                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }
                    
                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }
                    
                    if (char === '"' && !escapeNext) {
                        inString = !inString;
                        continue;
                    }
                    
                    if (!inString) {
                        if (char === '{') {
                            braceCount++;
                        } else if (char === '}') {
                            braceCount--;
                            if (braceCount === 0) {
                                endIndex = i + 1;
                                break;
                            }
                        }
                    }
                }
                
                if (braceCount === 0 && endIndex > 0) {
                    return potentialJson.substring(0, endIndex);
                }
                
                return null;
            },

            // 更新连接状态指示器
            updateConnectionStatus(isConnected) {
                const apiConfigBtn = document.getElementById('apiConfigBtn');
                if (apiConfigBtn) {
                    if (isConnected) {
                        apiConfigBtn.style.background = 'linear-gradient(135deg, rgba(46, 204, 113, 0.6), rgba(39, 174, 96, 0.6))';
                        apiConfigBtn.setAttribute('title', 'API连接正常');
                    } else {
                        apiConfigBtn.style.background = 'linear-gradient(135deg, rgba(231, 76, 60, 0.6), rgba(192, 57, 43, 0.6))';
                        apiConfigBtn.setAttribute('title', 'API连接失败，请检查配置');
                    }
                }
            },

            // 初始化应用
            init() {
                console.log(`初始化应用，加载时间: ${App.performance.measure('init')}ms`);
                
                // 初始化计算器
                this.calculator.init();
                
                // 设置事件处理
                this.events.setup();
                this.events.setupOutsideClick();
                
                // 初始化聊天快捷键
                App.chat.setupKeyboardShortcuts();
                App.chat.setupSendButton();
                
                // 初始化API连接状态
                this.updateConnectionStatus(false);
                
                console.log(`应用初始化完成，总耗时: ${App.performance.measure('complete')}ms`);
            }
        };

        // 启动应用
        document.addEventListener('DOMContentLoaded', () => {
            App.init();
        });
    </script>
</body>
</html>


