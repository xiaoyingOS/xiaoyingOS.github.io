<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äºŒç»´ç ç”Ÿæˆå™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #bdbebf 0%, #000000 100%);
            min-height: 100vh;
            padding: 3px;
        }
        
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .sidebar {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            padding: 30px;
            margin-bottom: 20px;
        }
        
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }
        
        .logo {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .logo-icon {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin-bottom: 10px;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .logo h2 {
            font-size: 24px;
            color: #1a202c;
            font-weight: 700;
        }
        
        .config-sections {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .config-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
        }
        
        .config-section h3 {
            font-size: 15px;
            color: #2d3748;
            margin-bottom: 15px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .form-group {
            margin-bottom: 18px;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .form-group label {
            display: block;
            font-size: 13px;
            color: #2d3748;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .form-group label span {
            color: #667eea;
            font-weight: 600;
        }
        
        input[type="text"],
        input[type="file"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 10px 12px;
            border: 1.5px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s;
            background: #fafafa;
            color: #2d3748;
            font-family: inherit;
        }
        
        input[type="number"] {
            margin-bottom: 8px;
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        textarea {
            resize: vertical;
            min-height: 80px;
            line-height: 1.5;
        }
        
        input[type="color"] {
            width: 100%;
            height: 45px;
            border: 1.5px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            background: #fafafa;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            /* -webkit-appearance: none; */
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
        }
        
        input[type="file"] {
            padding: 8px;
            cursor: pointer;
        }
        
        small {
            display: block;
            margin-top: 5px;
            font-size: 12px;
            color: #718096;
        }
        
        .text-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding: 8px 12px;
            background: #f0f4f8;
            border-radius: 6px;
            font-size: 12px;
            color: #4a5568;
        }
        
        .text-stats strong {
            color: #667eea;
            font-weight: 600;
        }
        
        .text-stats .warning {
            color: #e53e3e;
        }
        
        .generate-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .generate-btn:active {
            transform: translateY(0);
        }
        
        .preview-area {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .preview-header {
            padding: 20px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .preview-header h1 {
            font-size: 20px;
            color: white;
            font-weight: 700;
        }
        
        .download-btn {
            padding: 10px 20px;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .preview-content {
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 50px;
            background: #f8f9fa;
        }
        
        .empty-state {
            text-align: center;
            color: #718096;
        }
        
        .empty-icon {
            font-size: 100px;
            margin-bottom: 20px;
            opacity: 0.4;
        }
        
        .empty-state h3 {
            font-size: 22px;
            color: #4a5568;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .empty-state p {
            font-size: 15px;
            color: #a0aec0;
        }
        
        .qrcode-display {
            text-align: center;
            padding: 50px;
            animation: fadeIn 0.4s ease-out;
            background: #f8f9fa;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        #qrcode {
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            max-width: 100%;
            height: auto;
        }
        
        .bottom-text {
            margin-top: 25px;
            font-size: 18px;
            color: #2d3748;
            font-weight: 600;
        }
        
        .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #fee;
            color: #c00;
            padding: 15px 20px;
            border-radius: 10px;
            border-left: 4px solid #c00;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: none;
            animation: slideInRight 0.3s;
            max-width: 400px;
            z-index: 1000;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .sidebar {
                padding: 20px;
            }
            
            .config-sections {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .preview-content,
            .qrcode-display {
                padding: 30px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar">
            <div class="logo">
                <div class="logo-icon">âš¡</div>
                <h2>äºŒç»´ç ç”Ÿæˆå™¨</h2>
            </div>
            
            <div class="config-sections">
                <div class="config-section">
                    <h3>ğŸ“ åŸºæœ¬è®¾ç½®</h3>
                    <div class="form-group">
                        <label>å†…å®¹</label>
                        <textarea id="text" placeholder="è¾“å…¥æ–‡æœ¬ã€ç½‘å€ç­‰å†…å®¹..." rows="3"></textarea>
                        <div class="text-stats">
                            <span>å­—ç¬¦: <strong id="charCount">0</strong> / <span id="maxChars">-</span></span>
                            <span>å­—èŠ‚: <strong id="byteCount">0</strong> / <span id="maxBytes">2953</span></span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>åº•éƒ¨æ–‡å­—</label>
                        <input type="text" id="bottomText" placeholder="å¯é€‰">
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>ğŸ¨ å¤–è§‚è®¾ç½®</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label>å‰æ™¯è‰²</label>
                            <input type="color" id="fgColor" value="#000000">
                        </div>
                        <div class="form-group">
                            <label>èƒŒæ™¯è‰²</label>
                            <input type="color" id="bgColor" value="#ffffff">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>èƒŒæ™¯å›¾ç‰‡</label>
                        <div style="display: flex; align-items: center;">
                            <input type="file" id="bgImageFile" accept="image/*" style="flex: 1;">
                            <button type="button" id="clearBgImage" style="margin-left: 8px; background: none; border: none; cursor: pointer; font-size: 20px; font-weight: bold;">Ã—</button>
                        </div>
                        <small>é€‰æ‹©èƒŒæ™¯å›¾ç‰‡,äºŒç»´ç å°†ç»˜åˆ¶åœ¨å›¾ç‰‡ä¸Šæ–¹</small>
                    </div>
                    <div class="form-group">
                        <label>Logoå›¾ç‰‡</label>
                        <div style="display: flex; align-items: center;">
                            <input type="file" id="logoFile" accept="image/*" style="flex: 1;">
                            <button type="button" id="clearLogo" style="margin-left: 8px; background: none; border: none; cursor: pointer; font-size: 20px; font-weight: bold;">Ã—</button>
                        </div>
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>ğŸ“ å°ºå¯¸è®¾ç½®</h3>
                    <div class="form-group">
                        <label>å°ºå¯¸ <span id="sizeValue">500</span>px</label>
                        <input type="number" id="sizeInput" value="500" min="1" placeholder="è¾“å…¥å°ºå¯¸">
                        <input type="range" id="size" min="0" max="10000" value="500" step="50">
                    </div>
                    <div class="form-group">
                        <label>è¾¹è· <span id="marginValue">20</span>px</label>
                        <input type="number" id="marginInput" value="20" min="0" placeholder="è¾“å…¥è¾¹è·">
                        <input type="range" id="margin" min="0" max="100" value="20" step="5">
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>âš™ï¸ é«˜çº§è®¾ç½®</h3>
                    <div class="form-group">
                        <label>å®¹é”™çº§åˆ«</label>
                        <select id="errorLevel">
                            <option value="L">ä½ 7%</option>
                            <option value="M" selected>ä¸­ 15%</option>
                            <option value="Q">è¾ƒé«˜ 25%</option>
                            <option value="H">é«˜ 30%</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="highContrastMode">
                            é«˜å¯¹æ¯”åº¦æ¨¡å¼ï¼ˆè¯†åˆ«å›°éš¾æ—¶å¼€å¯ï¼‰
                        </label>
                        <small>å¼€å¯æ—¶å¼ºåˆ¶ä½¿ç”¨é»‘ç™½é…è‰²ç¡®ä¿æœ€ä½³è¯†åˆ«ç‡ï¼Œå…³é—­æ—¶å¯ä½¿ç”¨è‡ªå®šä¹‰é¢œè‰²</small>
                    </div>
                    <div class="form-group">
                        <label>
                            <input type="checkbox" id="forceCompatibilityMode" checked>
                            å¼ºåˆ¶å…¼å®¹æ¨¡å¼ï¼ˆç™½è‰²å‰æ™¯/é»‘è‰²èƒŒæ™¯æ—¶å»ºè®®å¼€å¯ï¼‰
                        </label>
                        <small>å¼€å¯æ—¶è‡ªåŠ¨ç¡®ä¿äºŒç»´ç ç¬¦åˆæ‰«ææ ‡å‡†ï¼Œå¯èƒ½ä¼šè°ƒæ•´é¢œè‰²ç»„åˆ</small>
                    </div>
                    <div class="form-group">
                        <label>å¯¼å‡ºæ ¼å¼</label>
                        <select id="exportFormat">
                            <option value="png">PNG</option>
                            <option value="jpg">JPG</option>
                            <option value="webp">WebP</option>
                            <option value="svg">SVG</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <button class="generate-btn" onclick="generateQRCode()">ğŸš€ ç”ŸæˆäºŒç»´ç </button>
        </div>
        
        <div class="preview-area">
            <div class="preview-header">
                <h1>é¢„è§ˆä¸ä¸‹è½½</h1>
                <button class="download-btn" onclick="downloadQRCode()" id="downloadBtn" style="display:none;">
                    <span>ğŸ’¾</span> ä¸‹è½½
                </button>
            </div>
            
            <div class="preview-content" id="previewContent">
                <div class="empty-state">
                    <div class="empty-icon">ğŸ“±</div>
                    <h3>å¼€å§‹åˆ›å»ºæ‚¨çš„äºŒç»´ç </h3>
                    <p>é…ç½®ä¸Šæ–¹é€‰é¡¹ï¼Œç‚¹å‡»ç”ŸæˆæŒ‰é’®å³å¯é¢„è§ˆ</p>
                </div>
            </div>
            
            <div class="qrcode-display" id="qrcodeDisplay" style="display:none;">
                <canvas id="qrcode"></canvas>
                <div id="bottomTextDisplay" class="bottom-text"></div>
            </div>
        </div>
        
        <div class="error-message" id="error"></div>
    </div>

    <script>
        // QR Code ç¼–ç å®ç°
        const QRCode = (function() {
            // çº é”™ç­‰çº§
            const ErrorCorrectLevel = {
                L: 1,
                M: 0,
                Q: 3,
                H: 2
            };
            
            // QR Code æ¨¡å¼
            const Mode = {
                MODE_NUMBER: 1 << 0,
                MODE_ALPHA_NUM: 1 << 1,
                MODE_8BIT_BYTE: 1 << 2,
                MODE_KANJI: 1 << 3
            };
            
            // å¤šé¡¹å¼
            function QRPolynomial(num, shift) {
                if (num.length == undefined) {
                    throw new Error(num.length + "/" + shift);
                }
                
                let offset = 0;
                while (offset < num.length && num[offset] == 0) {
                    offset++;
                }
                
                this.num = new Array(num.length - offset + shift);
                for (let i = 0; i < num.length - offset; i++) {
                    this.num[i] = num[i + offset];
                }
            }
            
            QRPolynomial.prototype = {
                get: function(index) {
                    return this.num[index];
                },
                
                getLength: function() {
                    return this.num.length;
                },
                
                multiply: function(e) {
                    const num = new Array(this.getLength() + e.getLength() - 1);
                    
                    for (let i = 0; i < this.getLength(); i++) {
                        for (let j = 0; j < e.getLength(); j++) {
                            num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
                        }
                    }
                    
                    return new QRPolynomial(num, 0);
                },
                
                mod: function(e) {
                    if (this.getLength() - e.getLength() < 0) {
                        return this;
                    }
                    
                    const ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
                    const num = new Array(this.getLength());
                    
                    for (let i = 0; i < this.getLength(); i++) {
                        num[i] = this.get(i);
                    }
                    
                    for (let i = 0; i < e.getLength(); i++) {
                        num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
                    }
                    
                    return new QRPolynomial(num, 0).mod(e);
                }
            };
            
            // æ•°å­¦å·¥å…·
            const QRMath = {
                glog: function(n) {
                    if (n < 1) {
                        throw new Error("glog(" + n + ")");
                    }
                    return QRMath.LOG_TABLE[n];
                },
                
                gexp: function(n) {
                    while (n < 0) {
                        n += 255;
                    }
                    while (n >= 256) {
                        n -= 255;
                    }
                    return QRMath.EXP_TABLE[n];
                },
                
                EXP_TABLE: new Array(256),
                LOG_TABLE: new Array(256)
            };
            
            for (let i = 0; i < 8; i++) {
                QRMath.EXP_TABLE[i] = 1 << i;
            }
            for (let i = 8; i < 256; i++) {
                QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
            }
            for (let i = 0; i < 255; i++) {
                QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
            }
            
            // RS Block
            function QRRSBlock(totalCount, dataCount) {
                this.totalCount = totalCount;
                this.dataCount = dataCount;
            }
            
            QRRSBlock.RS_BLOCK_TABLE = [
                // Version 1: M, L, H, Q
                [1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9],
                // Version 2
                [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16],
                // Version 3
                [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13],
                // Version 4
                [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9],
                // Version 5
                [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12],
                // Version 6
                [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15],
                // Version 7
                [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14],
                // Version 8
                [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15],
                // Version 9
                [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13],
                // Version 10
                [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16],
                // Version 11
                [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13],
                // Version 12
                [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15],
                // Version 13
                [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12],
                // Version 14
                [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13],
                // Version 15
                [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13],
                // Version 16
                [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16],
                // Version 17
                [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15],
                // Version 18
                [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15],
                // Version 19
                [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14],
                // Version 20
                [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16],
                // Version 21
                [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17],
                // Version 22
                [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13],
                // Version 23
                [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16],
                // Version 24
                [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17],
                // Version 25
                [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16],
                // Version 26
                [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17],
                // Version 27
                [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16],
                // Version 28
                [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16],
                // Version 29
                [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16],
                // Version 30
                [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16],
                // Version 31
                [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16],
                // Version 32
                [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16],
                // Version 33
                [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16],
                // Version 34
                [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17],
                // Version 35
                [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16],
                // Version 36
                [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16],
                // Version 37
                [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16],
                // Version 38
                [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16],
                // Version 39
                [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16],
                // Version 40
                [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]
            ];
            
            QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
                const rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
                
                if (rsBlock == undefined) {
                    throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
                }
                
                const length = rsBlock.length / 3;
                const list = [];
                
                for (let i = 0; i < length; i++) {
                    const count = rsBlock[i * 3 + 0];
                    const totalCount = rsBlock[i * 3 + 1];
                    const dataCount = rsBlock[i * 3 + 2];
                    
                    for (let j = 0; j < count; j++) {
                        list.push(new QRRSBlock(totalCount, dataCount));
                    }
                }
                
                return list;
            };
            
            QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
                switch(errorCorrectLevel) {
                    case ErrorCorrectLevel.L:
                        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
                    case ErrorCorrectLevel.M:
                        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
                    case ErrorCorrectLevel.Q:
                        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
                    case ErrorCorrectLevel.H:
                        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
                    default:
                        return undefined;
                }
            };
            
            // Bit Buffer
            function QRBitBuffer() {
                this.buffer = [];
                this.length = 0;
            }
            
            QRBitBuffer.prototype = {
                get: function(index) {
                    const bufIndex = Math.floor(index / 8);
                    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) == 1;
                },
                
                put: function(num, length) {
                    for (let i = 0; i < length; i++) {
                        this.putBit(((num >>> (length - i - 1)) & 1) == 1);
                    }
                },
                
                getLengthInBits: function() {
                    return this.length;
                },
                
                putBit: function(bit) {
                    const bufIndex = Math.floor(this.length / 8);
                    if (this.buffer.length <= bufIndex) {
                        this.buffer.push(0);
                    }
                    
                    if (bit) {
                        this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
                    }
                    
                    this.length++;
                }
            };
            
            // 8bit Byte
            function QR8bitByte(data) {
                this.mode = Mode.MODE_8BIT_BYTE;
                this.data = data;
                this.parsedData = utf8Encode(data);
            }
            
            QR8bitByte.prototype = {
                getLength: function(buffer) {
                    return this.parsedData.length;
                },
                
                write: function(buffer) {
                    for (let i = 0; i < this.parsedData.length; i++) {
                        buffer.put(this.parsedData[i], 8);
                    }
                }
            };
            
            // UTF-8 ç¼–ç å‡½æ•°
            function utf8Encode(str) {
                const utf8 = [];
                for (let i = 0; i < str.length; i++) {
                    let charcode = str.charCodeAt(i);
                    if (charcode < 0x80) {
                        utf8.push(charcode);
                    } else if (charcode < 0x800) {
                        utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));
                    } else if (charcode < 0xd800 || charcode >= 0xe000) {
                        utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
                    } else {
                        i++;
                        charcode = 0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                        utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
                    }
                }
                return utf8;
            }
            
            // QRCode ä¸»ç±»
            function QRCodeModel(typeNumber, errorCorrectLevel) {
                this.typeNumber = typeNumber;
                this.errorCorrectLevel = errorCorrectLevel;
                this.modules = null;
                this.moduleCount = 0;
                this.dataCache = null;
                this.dataList = [];
            }
            
            QRCodeModel.prototype = {
                addData: function(data) {
                    const newData = new QR8bitByte(data);
                    this.dataList.push(newData);
                    this.dataCache = null;
                },
                
                isDark: function(row, col) {
                    if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
                        throw new Error(row + "," + col);
                    }
                    return this.modules[row][col];
                },
                
                getModuleCount: function() {
                    return this.moduleCount;
                },
                
                make: function() {
                    this.makeImpl(false, this.getBestMaskPattern());
                },
                
                makeImpl: function(test, maskPattern) {
                    this.moduleCount = this.typeNumber * 4 + 17;
                    this.modules = new Array(this.moduleCount);
                    
                    for (let row = 0; row < this.moduleCount; row++) {
                        this.modules[row] = new Array(this.moduleCount);
                        
                        for (let col = 0; col < this.moduleCount; col++) {
                            this.modules[row][col] = null;
                        }
                    }
                    
                    this.setupPositionProbePattern(0, 0);
                    this.setupPositionProbePattern(this.moduleCount - 7, 0);
                    this.setupPositionProbePattern(0, this.moduleCount - 7);
                    this.setupPositionAdjustPattern();
                    this.setupTimingPattern();
                    this.setupTypeInfo(test, maskPattern);
                    
                    if (this.typeNumber >= 7) {
                        this.setupTypeNumber(test);
                    }
                    
                    if (this.dataCache == null) {
                        this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
                    }
                    
                    this.mapData(this.dataCache, maskPattern);
                },
                
                setupPositionProbePattern: function(row, col) {
                    for (let r = -1; r <= 7; r++) {
                        if (row + r <= -1 || this.moduleCount <= row + r) continue;
                        
                        for (let c = -1; c <= 7; c++) {
                            if (col + c <= -1 || this.moduleCount <= col + c) continue;
                            
                            if ((0 <= r && r <= 6 && (c == 0 || c == 6)) ||
                                (0 <= c && c <= 6 && (r == 0 || r == 6)) ||
                                (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
                                this.modules[row + r][col + c] = true;
                            } else {
                                this.modules[row + r][col + c] = false;
                            }
                        }
                    }
                },
                
                getBestMaskPattern: function() {
                    let minLostPoint = 0;
                    let pattern = 0;
                    
                    for (let i = 0; i < 8; i++) {
                        this.makeImpl(true, i);
                        const lostPoint = QRUtil.getLostPoint(this);
                        
                        if (i == 0 || minLostPoint > lostPoint) {
                            minLostPoint = lostPoint;
                            pattern = i;
                        }
                    }
                    
                    return pattern;
                },
                
                setupTimingPattern: function() {
                    for (let r = 8; r < this.moduleCount - 8; r++) {
                        if (this.modules[r][6] != null) {
                            continue;
                        }
                        this.modules[r][6] = (r % 2 == 0);
                    }
                    
                    for (let c = 8; c < this.moduleCount - 8; c++) {
                        if (this.modules[6][c] != null) {
                            continue;
                        }
                        this.modules[6][c] = (c % 2 == 0);
                    }
                },
                
                setupPositionAdjustPattern: function() {
                    const pos = QRUtil.getPatternPosition(this.typeNumber);
                    
                    for (let i = 0; i < pos.length; i++) {
                        for (let j = 0; j < pos.length; j++) {
                            const row = pos[i];
                            const col = pos[j];
                            
                            if (this.modules[row][col] != null) {
                                continue;
                            }
                            
                            for (let r = -2; r <= 2; r++) {
                                for (let c = -2; c <= 2; c++) {
                                    if (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0)) {
                                        this.modules[row + r][col + c] = true;
                                    } else {
                                        this.modules[row + r][col + c] = false;
                                    }
                                }
                            }
                        }
                    }
                },
                
                setupTypeNumber: function(test) {
                    const bits = QRUtil.getBCHTypeNumber(this.typeNumber);
                    
                    for (let i = 0; i < 18; i++) {
                        const mod = (!test && ((bits >> i) & 1) == 1);
                        this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
                    }
                    
                    for (let i = 0; i < 18; i++) {
                        const mod = (!test && ((bits >> i) & 1) == 1);
                        this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
                    }
                },
                
                setupTypeInfo: function(test, maskPattern) {
                    const data = (this.errorCorrectLevel << 3) | maskPattern;
                    const bits = QRUtil.getBCHTypeInfo(data);
                    
                    for (let i = 0; i < 15; i++) {
                        const mod = (!test && ((bits >> i) & 1) == 1);
                        
                        if (i < 6) {
                            this.modules[i][8] = mod;
                        } else if (i < 8) {
                            this.modules[i + 1][8] = mod;
                        } else {
                            this.modules[this.moduleCount - 15 + i][8] = mod;
                        }
                    }
                    
                    for (let i = 0; i < 15; i++) {
                        const mod = (!test && ((bits >> i) & 1) == 1);
                        
                        if (i < 8) {
                            this.modules[8][this.moduleCount - i - 1] = mod;
                        } else if (i < 9) {
                            this.modules[8][15 - i - 1 + 1] = mod;
                        } else {
                            this.modules[8][15 - i - 1] = mod;
                        }
                    }
                    
                    this.modules[this.moduleCount - 8][8] = (!test);
                },
                
                mapData: function(data, maskPattern) {
                    let inc = -1;
                    let row = this.moduleCount - 1;
                    let bitIndex = 7;
                    let byteIndex = 0;
                    
                    for (let col = this.moduleCount - 1; col > 0; col -= 2) {
                        if (col == 6) col--;
                        
                        while (true) {
                            for (let c = 0; c < 2; c++) {
                                if (this.modules[row][col - c] == null) {
                                    let dark = false;
                                    
                                    if (byteIndex < data.length) {
                                        dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
                                    }
                                    
                                    const mask = QRUtil.getMask(maskPattern, row, col - c);
                                    
                                    if (mask) {
                                        dark = !dark;
                                    }
                                    
                                    this.modules[row][col - c] = dark;
                                    bitIndex--;
                                    
                                    if (bitIndex == -1) {
                                        byteIndex++;
                                        bitIndex = 7;
                                    }
                                }
                            }
                            
                            row += inc;
                            
                            if (row < 0 || this.moduleCount <= row) {
                                row -= inc;
                                inc = -inc;
                                break;
                            }
                        }
                    }
                }
            };
            
            QRCodeModel.PAD0 = 0xEC;
            QRCodeModel.PAD1 = 0x11;
            
            QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
                const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
                const buffer = new QRBitBuffer();
                
                for (let i = 0; i < dataList.length; i++) {
                    const data = dataList[i];
                    buffer.put(data.mode, 4);
                    buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
                    data.write(buffer);
                }
                
                let totalDataCount = 0;
                for (let i = 0; i < rsBlocks.length; i++) {
                    totalDataCount += rsBlocks[i].dataCount;
                }
                
                if (buffer.getLengthInBits() > totalDataCount * 8) {
                    throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
                }
                
                if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
                    buffer.put(0, 4);
                }
                
                while (buffer.getLengthInBits() % 8 != 0) {
                    buffer.putBit(false);
                }
                
                while (true) {
                    if (buffer.getLengthInBits() >= totalDataCount * 8) {
                        break;
                    }
                    buffer.put(QRCodeModel.PAD0, 8);
                    
                    if (buffer.getLengthInBits() >= totalDataCount * 8) {
                        break;
                    }
                    buffer.put(QRCodeModel.PAD1, 8);
                }
                
                return QRCodeModel.createBytes(buffer, rsBlocks);
            };
            
            QRCodeModel.createBytes = function(buffer, rsBlocks) {
                let offset = 0;
                let maxDcCount = 0;
                let maxEcCount = 0;
                
                const dcdata = new Array(rsBlocks.length);
                const ecdata = new Array(rsBlocks.length);
                
                for (let r = 0; r < rsBlocks.length; r++) {
                    const dcCount = rsBlocks[r].dataCount;
                    const ecCount = rsBlocks[r].totalCount - dcCount;
                    
                    maxDcCount = Math.max(maxDcCount, dcCount);
                    maxEcCount = Math.max(maxEcCount, ecCount);
                    
                    dcdata[r] = new Array(dcCount);
                    
                    for (let i = 0; i < dcdata[r].length; i++) {
                        dcdata[r][i] = 0xff & buffer.buffer[i + offset];
                    }
                    offset += dcCount;
                    
                    const rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
                    const rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
                    
                    const modPoly = rawPoly.mod(rsPoly);
                    ecdata[r] = new Array(rsPoly.getLength() - 1);
                    for (let i = 0; i < ecdata[r].length; i++) {
                        const modIndex = i + modPoly.getLength() - ecdata[r].length;
                        ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
                    }
                }
                
                let totalCodeCount = 0;
                for (let i = 0; i < rsBlocks.length; i++) {
                    totalCodeCount += rsBlocks[i].totalCount;
                }
                
                const data = new Array(totalCodeCount);
                let index = 0;
                
                for (let i = 0; i < maxDcCount; i++) {
                    for (let r = 0; r < rsBlocks.length; r++) {
                        if (i < dcdata[r].length) {
                            data[index++] = dcdata[r][i];
                        }
                    }
                }
                
                for (let i = 0; i < maxEcCount; i++) {
                    for (let r = 0; r < rsBlocks.length; r++) {
                        if (i < ecdata[r].length) {
                            data[index++] = ecdata[r][i];
                        }
                    }
                }
                
                return data;
            };
            
            // QR Util
            const QRUtil = {
                PATTERN_POSITION_TABLE: [
                    [],
                    [6, 18],
                    [6, 22],
                    [6, 26],
                    [6, 30],
                    [6, 34],
                    [6, 22, 38],
                    [6, 24, 42],
                    [6, 26, 46],
                    [6, 28, 50],
                    [6, 30, 54],
                    [6, 32, 58],
                    [6, 34, 62],
                    [6, 26, 46, 66],
                    [6, 26, 48, 70],
                    [6, 26, 50, 74],
                    [6, 30, 54, 78],
                    [6, 30, 56, 82],
                    [6, 30, 58, 86],
                    [6, 34, 62, 90],
                    [6, 28, 50, 72, 94],
                    [6, 26, 50, 74, 98],
                    [6, 30, 54, 78, 102],
                    [6, 28, 54, 80, 106],
                    [6, 32, 58, 84, 110],
                    [6, 30, 58, 86, 114],
                    [6, 34, 62, 90, 118],
                    [6, 26, 50, 74, 98, 122],
                    [6, 30, 54, 78, 102, 126],
                    [6, 26, 52, 78, 104, 130],
                    [6, 30, 56, 82, 108, 134],
                    [6, 34, 60, 86, 112, 138],
                    [6, 30, 58, 86, 114, 142],
                    [6, 34, 62, 90, 118, 146],
                    [6, 30, 54, 78, 102, 126, 150],
                    [6, 24, 50, 76, 102, 128, 154],
                    [6, 28, 54, 80, 106, 132, 158],
                    [6, 32, 58, 84, 110, 136, 162],
                    [6, 26, 54, 82, 110, 138, 166],
                    [6, 30, 58, 86, 114, 142, 170]
                ],
                
                G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
                G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
                G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
                
                getBCHTypeInfo: function(data) {
                    let d = data << 10;
                    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
                        d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15)));
                    }
                    return ((data << 10) | d) ^ QRUtil.G15_MASK;
                },
                
                getBCHTypeNumber: function(data) {
                    let d = data << 12;
                    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
                        d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18)));
                    }
                    return (data << 12) | d;
                },
                
                getBCHDigit: function(data) {
                    let digit = 0;
                    while (data != 0) {
                        digit++;
                        data >>>= 1;
                    }
                    return digit;
                },
                
                getPatternPosition: function(typeNumber) {
                    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
                },
                
                getMask: function(maskPattern, i, j) {
                    switch (maskPattern) {
                        case 0: return (i + j) % 2 == 0;
                        case 1: return i % 2 == 0;
                        case 2: return j % 3 == 0;
                        case 3: return (i + j) % 3 == 0;
                        case 4: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
                        case 5: return (i * j) % 2 + (i * j) % 3 == 0;
                        case 6: return ((i * j) % 2 + (i * j) % 3) % 2 == 0;
                        case 7: return ((i * j) % 3 + (i + j) % 2) % 2 == 0;
                        default: throw new Error("bad maskPattern:" + maskPattern);
                    }
                },
                
                getErrorCorrectPolynomial: function(errorCorrectLength) {
                    let a = new QRPolynomial([1], 0);
                    
                    for (let i = 0; i < errorCorrectLength; i++) {
                        a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
                    }
                    
                    return a;
                },
                
                getLengthInBits: function(mode, type) {
                    if (1 <= type && type < 10) {
                        switch(mode) {
                            case Mode.MODE_NUMBER: return 10;
                            case Mode.MODE_ALPHA_NUM: return 9;
                            case Mode.MODE_8BIT_BYTE: return 8;
                            case Mode.MODE_KANJI: return 8;
                            default: throw new Error("mode:" + mode);
                        }
                    } else if (type < 27) {
                        switch(mode) {
                            case Mode.MODE_NUMBER: return 12;
                            case Mode.MODE_ALPHA_NUM: return 11;
                            case Mode.MODE_8BIT_BYTE: return 16;
                            case Mode.MODE_KANJI: return 10;
                            default: throw new Error("mode:" + mode);
                        }
                    } else if (type < 41) {
                        switch(mode) {
                            case Mode.MODE_NUMBER: return 14;
                            case Mode.MODE_ALPHA_NUM: return 13;
                            case Mode.MODE_8BIT_BYTE: return 16;
                            case Mode.MODE_KANJI: return 12;
                            default: throw new Error("mode:" + mode);
                        }
                    } else {
                        throw new Error("type:" + type);
                    }
                },
                
                getLostPoint: function(qrCode) {
                    const moduleCount = qrCode.getModuleCount();
                    let lostPoint = 0;
                    
                    for (let row = 0; row < moduleCount; row++) {
                        for (let col = 0; col < moduleCount; col++) {
                            let sameCount = 0;
                            const dark = qrCode.isDark(row, col);
                            
                            for (let r = -1; r <= 1; r++) {
                                if (row + r < 0 || moduleCount <= row + r) {
                                    continue;
                                }
                                
                                for (let c = -1; c <= 1; c++) {
                                    if (col + c < 0 || moduleCount <= col + c) {
                                        continue;
                                    }
                                    
                                    if (r == 0 && c == 0) {
                                        continue;
                                    }
                                    
                                    if (dark == qrCode.isDark(row + r, col + c)) {
                                        sameCount++;
                                    }
                                }
                            }
                            
                            if (sameCount > 5) {
                                lostPoint += (3 + sameCount - 5);
                            }
                        }
                    }
                    
                    for (let row = 0; row < moduleCount - 1; row++) {
                        for (let col = 0; col < moduleCount - 1; col++) {
                            let count = 0;
                            if (qrCode.isDark(row, col)) count++;
                            if (qrCode.isDark(row + 1, col)) count++;
                            if (qrCode.isDark(row, col + 1)) count++;
                            if (qrCode.isDark(row + 1, col + 1)) count++;
                            if (count == 0 || count == 4) {
                                lostPoint += 3;
                            }
                        }
                    }
                    
                    for (let row = 0; row < moduleCount; row++) {
                        for (let col = 0; col < moduleCount - 6; col++) {
                            if (qrCode.isDark(row, col) &&
                                !qrCode.isDark(row, col + 1) &&
                                qrCode.isDark(row, col + 2) &&
                                qrCode.isDark(row, col + 3) &&
                                qrCode.isDark(row, col + 4) &&
                                !qrCode.isDark(row, col + 5) &&
                                qrCode.isDark(row, col + 6)) {
                                lostPoint += 40;
                            }
                        }
                    }
                    
                    for (let col = 0; col < moduleCount; col++) {
                        for (let row = 0; row < moduleCount - 6; row++) {
                            if (qrCode.isDark(row, col) &&
                                !qrCode.isDark(row + 1, col) &&
                                qrCode.isDark(row + 2, col) &&
                                qrCode.isDark(row + 3, col) &&
                                qrCode.isDark(row + 4, col) &&
                                !qrCode.isDark(row + 5, col) &&
                                qrCode.isDark(row + 6, col)) {
                                lostPoint += 40;
                            }
                        }
                    }
                    
                    let darkCount = 0;
                    
                    for (let col = 0; col < moduleCount; col++) {
                        for (let row = 0; row < moduleCount; row++) {
                            if (qrCode.isDark(row, col)) {
                                darkCount++;
                            }
                        }
                    }
                    
                    const ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
                    lostPoint += ratio * 10;
                    
                    return lostPoint;
                }
            };
            
            return {
                ErrorCorrectLevel: ErrorCorrectLevel,
                QRCodeModel: QRCodeModel
            };
        })();
        
        let logoImage = null;
        let bgImage = null;
        
        // åå…­è¿›åˆ¶é¢œè‰²è½¬RGB
        function hexToRgb(hex) {
            hex = hex.replace('#', '');
            if (hex.length === 3) {
                hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
            }
            const result = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }
        
        // RGBè½¬åå…­è¿›åˆ¶
        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
        
        // è®¡ç®—é¢œè‰²äº®åº¦
        function getBrightness(rgb) {
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        }
        
        // æ™ºèƒ½è°ƒæ•´é¢œè‰²å¯¹æ¯”åº¦
        function adjustColorsForContrast(fgColor, bgColor) {
            const fgRgb = hexToRgb(fgColor);
            const bgRgb = hexToRgb(bgColor);
            const fgBrightness = getBrightness(fgRgb);
            const bgBrightness = getBrightness(bgRgb);
            const contrast = Math.abs(fgBrightness - bgBrightness);
            
            // å¦‚æœå¯¹æ¯”åº¦è¶³å¤Ÿï¼Œè¿”å›åŸè‰²
            if (contrast >= 125) {
                return { fg: fgColor, bg: bgColor };
            }
            
            // æ™ºèƒ½è°ƒæ•´é¢œè‰²
            let adjustedFg, adjustedBg;
            
            if (bgBrightness > 128) {
                // èƒŒæ™¯è¾ƒäº®ï¼ŒåŠ æ·±å‰æ™¯è‰²
                const newFgRgb = {
                    r: Math.max(0, fgRgb.r - 80),
                    g: Math.max(0, fgRgb.g - 80),
                    b: Math.max(0, fgRgb.b - 80)
                };
                adjustedFg = rgbToHex(newFgRgb.r, newFgRgb.g, newFgRgb.b);
                adjustedBg = bgColor;
            } else if (fgBrightness < 128) {
                // å‰æ™¯è¾ƒæš—ï¼Œè°ƒäº®èƒŒæ™¯è‰²
                adjustedFg = fgColor;
                const newBgRgb = {
                    r: Math.min(255, bgRgb.r + 80),
                    g: Math.min(255, bgRgb.g + 80),
                    b: Math.min(255, bgRgb.b + 80)
                };
                adjustedBg = rgbToHex(newBgRgb.r, newBgRgb.g, newBgRgb.b);
            } else {
                // å…¶ä»–æƒ…å†µï¼Œå¾®è°ƒèƒŒæ™¯è‰²
                adjustedFg = fgColor;
                const newBgRgb = {
                    r: Math.max(0, bgRgb.r - 30),
                    g: Math.max(0, bgRgb.g - 30),
                    b: Math.max(0, bgRgb.b - 30)
                };
                adjustedBg = rgbToHex(newBgRgb.r, newBgRgb.g, newBgRgb.b);
            }
            
            return { fg: adjustedFg, bg: adjustedBg };
        }
        
        // å°ºå¯¸æ»‘å—å’Œè¾“å…¥æ¡†åŒå‘åŒæ­¥
        document.getElementById('size').addEventListener('input', function(e) {
            const value = e.target.value;
            document.getElementById('sizeValue').textContent = value;
            document.getElementById('sizeInput').value = value;
        });
        
        document.getElementById('sizeInput').addEventListener('input', function(e) {
            const value = Math.max(0, parseInt(e.target.value) || 1);
            document.getElementById('sizeValue').textContent = value;
            document.getElementById('size').value = Math.min(value, 10000);
        });
        
        // è¾¹è·æ»‘å—å’Œè¾“å…¥æ¡†åŒå‘åŒæ­¥
        document.getElementById('margin').addEventListener('input', function(e) {
            const value = e.target.value;
            document.getElementById('marginValue').textContent = value;
            document.getElementById('marginInput').value = value;
        });
        
        document.getElementById('marginInput').addEventListener('input', function(e) {
            const value = Math.max(0, parseInt(e.target.value) || 0);
            document.getElementById('marginValue').textContent = value;
            document.getElementById('margin').value = Math.min(value, 1000);
        });

        // Logoä¸Šä¼ 
        document.getElementById('logoFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        logoImage = img;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        // æ¸…é™¤Logo
        document.getElementById('clearLogo').addEventListener('click', function() {
            logoImage = null;
            document.getElementById('logoFile').value = '';
        });
        
        // èƒŒæ™¯å›¾ç‰‡ä¸Šä¼ 
        document.getElementById('bgImageFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        bgImage = img;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        // æ¸…é™¤èƒŒæ™¯å›¾ç‰‡
        document.getElementById('clearBgImage').addEventListener('click', function() {
            bgImage = null;
            document.getElementById('bgImageFile').value = '';
        });
        
        // Version 40 å„å®¹é”™çº§åˆ«çš„æœ€å¤§å®¹é‡(å­—èŠ‚)
        const maxCapacity = {
            L: 2953,
            M: 2331,
            Q: 1663,
            H: 1273
        };
        
        // æ›´æ–°æ–‡æœ¬ç»Ÿè®¡ä¿¡æ¯
        function updateTextStats() {
            const text = document.getElementById('text').value;
            const errorLevel = document.getElementById('errorLevel').value;
            const charCount = text.length;
            const byteCount = new Blob([text]).size;
            const maxBytes = maxCapacity[errorLevel];
            
            document.getElementById('charCount').textContent = charCount;
            document.getElementById('byteCount').textContent = byteCount;
            document.getElementById('maxBytes').textContent = maxBytes;
            
            // å¦‚æœè¶…å‡ºå®¹é‡,æ ‡çº¢
            const byteCountEl = document.getElementById('byteCount');
            if (byteCount > maxBytes) {
                byteCountEl.classList.add('warning');
            } else {
                byteCountEl.classList.remove('warning');
            }
        }
        
        // æ–‡æœ¬è¾“å…¥æ¡†ç›‘å¬
        document.getElementById('text').addEventListener('input', updateTextStats);
        
        // å®¹é”™çº§åˆ«æ”¹å˜æ—¶æ›´æ–°ç»Ÿè®¡
        document.getElementById('errorLevel').addEventListener('change', updateTextStats);
        
        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–ç»Ÿè®¡
        updateTextStats();
        
        // ç”ŸæˆäºŒç»´ç 
        function generateQRCode() {
            const text = document.getElementById('text').value.trim();
            const sizeInput = parseInt(document.getElementById('sizeInput').value);
            const marginInput = parseInt(document.getElementById('marginInput').value);
            const size = sizeInput || parseInt(document.getElementById('size').value);
            const margin = marginInput || parseInt(document.getElementById('margin').value);
            const fgColor = document.getElementById('fgColor').value;
            const bgColor = document.getElementById('bgColor').value;
            const bottomText = document.getElementById('bottomText').value.trim();
            const errorLevelStr = document.getElementById('errorLevel').value;
            const errorElement = document.getElementById('error');
            const previewContent = document.getElementById('previewContent');
            const qrcodeDisplay = document.getElementById('qrcodeDisplay');
            const downloadBtn = document.getElementById('downloadBtn');
            
            errorElement.style.display = 'none';
            
            if (!text) {
                errorElement.textContent = 'âš ï¸ è¯·è¾“å…¥è¦ç”ŸæˆäºŒç»´ç çš„å†…å®¹ï¼';
                errorElement.style.display = 'block';
                setTimeout(() => errorElement.style.display = 'none', 3000);
                return;
            }
            
            try {
                const errorLevel = QRCode.ErrorCorrectLevel[errorLevelStr];
                
                // æ™ºèƒ½é€‰æ‹©ç‰ˆæœ¬å·1-40ï¼Œç¡®ä¿å…¼å®¹æ€§
                let typeNumber = 40;
                let minVersion = 1;
                
                // å¯¹äºçŸ­æ–‡æœ¬ï¼Œå¼ºåˆ¶ä½¿ç”¨æœ€å°ç‰ˆæœ¬ç¡®ä¿å…¼å®¹æ€§
                const byteLength = new Blob([text]).size;
                
                // ä¼˜åŒ–ç‰ˆæœ¬é€‰æ‹©é€»è¾‘ï¼Œç¡®ä¿çŸ­æ–‡æœ¬ä½¿ç”¨åˆé€‚ç‰ˆæœ¬
                if (byteLength <= 14) {
                    minVersion = 1; // ç‰ˆæœ¬1å¯ä»¥å¤„ç†æœ€å¤š17ä¸ªæ•°å­—æˆ–25ä¸ªå­—æ¯æ•°å­—
                } else if (byteLength <= 26) {
                    minVersion = 2; // ç‰ˆæœ¬2å¯ä»¥å¤„ç†æ›´å¤šæ•°æ®
                } else if (byteLength <= 42) {
                    minVersion = 3; // ç‰ˆæœ¬3
                }
                
                // å°è¯•æ‰¾åˆ°æœ€å°å¯è¡Œç‰ˆæœ¬
                for (let i = minVersion; i <= 40; i++) {
                    try {
                        const testQr = new QRCode.QRCodeModel(i, errorLevel);
                        testQr.addData(text);
                        testQr.make();
                        typeNumber = i;
                        break;
                    } catch (e) {
                        if (i > 40) {
                            throw new Error('æ–‡æœ¬å†…å®¹è¿‡é•¿,è¶…å‡ºäºŒç»´ç æœ€å¤§å®¹é‡');
                        }
                        continue;
                    }
                }
                
                console.log('å®¹é”™çº§åˆ«: ' + errorLevelStr + '\né€‰æ‹©ç‰ˆæœ¬: ' + typeNumber + '\næ–‡æœ¬é•¿åº¦: ' + text.length + '\nå­—èŠ‚æ•°: ' + new Blob([text]).size);
                
                const qr = new QRCode.QRCodeModel(typeNumber, errorLevel);
                
                // ä½¿ç”¨åŸå§‹æ–‡æœ¬ï¼Œä¸æ·»åŠ ä»»ä½•å¡«å……å­—ç¬¦
                // ç°ä»£äºŒç»´ç æ ‡å‡†ä¸éœ€è¦æ‰‹åŠ¨å¡«å……ï¼Œç¼–ç åº“ä¼šè‡ªåŠ¨å¤„ç†
                qr.addData(text);
                qr.make();
                
                const canvas = document.getElementById('qrcode');
                const ctx = canvas.getContext('2d');
                const moduleCount = qr.getModuleCount();
                const qrSize = size - margin * 2;
                const cellSize = qrSize / moduleCount;
                canvas.width = size;
                canvas.height = size;
                
                // ç¡®ä¿æ¨¡å—å°ºå¯¸è‡³å°‘ä¸º2åƒç´ ï¼Œæé«˜æ‰«æå™¨è¯†åˆ«ç‡
                if (cellSize < 2) {
                    // å¦‚æœæ¨¡å—å¤ªå°ï¼Œå¢åŠ ç”»å¸ƒå°ºå¯¸ä»¥ç¡®ä¿æœ€å°æ¨¡å—å°ºå¯¸
                    const minModuleSize = 2;
                    const newSize = moduleCount * minModuleSize + margin * 2;
                    canvas.width = newSize;
                    canvas.height = newSize;
                }

                // è·å–é«˜å¯¹æ¯”åº¦æ¨¡å¼è®¾ç½®
                const highContrastMode = document.getElementById('highContrastMode').checked;
                
                // è·å–å¼ºåˆ¶å…¼å®¹æ¨¡å¼è®¾ç½®
                const forceCompatibilityMode = document.getElementById('forceCompatibilityMode').checked;
                
                // ç¡®å®šæœ€ç»ˆä½¿ç”¨çš„é¢œè‰²
                let finalFgColor, finalBgColor;
                
                if (highContrastMode) {
                    // é«˜å¯¹æ¯”åº¦æ¨¡å¼æ—¶ä½¿ç”¨é»‘ç™½é…è‰²
                    finalFgColor = '#000000';
                    finalBgColor = '#FFFFFF';
                } else {
                    // ä½¿ç”¨æ™ºèƒ½è°ƒæ•´åçš„é¢œè‰²ï¼Œå³ä½¿æœ‰èƒŒæ™¯å›¾ç‰‡ä¹Ÿä½¿ç”¨ç”¨æˆ·é€‰æ‹©çš„é¢œè‰²
                    const adjusted = adjustColorsForContrast(fgColor, bgColor);
                    finalFgColor = adjusted.fg;
                    finalBgColor = adjusted.bg;
                }
                
                // æ£€æµ‹é¢œè‰²ç»„åˆçš„å¯¹æ¯”åº¦
                const fgRgb = hexToRgb(finalFgColor);
                const bgRgb = hexToRgb(finalBgColor);
                const fgBrightness = getBrightness(fgRgb);
                const bgBrightness = getBrightness(bgRgb);
                const contrast = Math.abs(fgBrightness - bgBrightness);
                
                // ä½¿ç”¨ç”¨æˆ·é€‰æ‹©çš„åŸå§‹é¢œè‰²
                let actualFgColor = finalFgColor;
                let actualBgColor = finalBgColor;
                
                // åªåœ¨å¼ºåˆ¶å…¼å®¹æ¨¡å¼å¼€å¯ä¸”å‰æ™¯è‰²æ¯”èƒŒæ™¯è‰²äº®æ—¶æ‰è°ƒæ•´é¢œè‰²
                if (forceCompatibilityMode && fgBrightness > bgBrightness) {
                    actualFgColor = finalBgColor;
                    actualBgColor = finalFgColor;
                    
                    errorElement.textContent = 'âœ… å¼ºåˆ¶å…¼å®¹æ¨¡å¼ï¼šå·²è°ƒæ•´é¢œè‰²ä»¥ç¡®ä¿å¯æ‰«ææ€§';
                    errorElement.style.display = 'block';
                    setTimeout(() => errorElement.style.display = 'none', 3000);
                } else if (contrast < 100) {
                    // å¦‚æœå¯¹æ¯”åº¦è¾ƒä½ï¼Œæ˜¾ç¤ºæç¤º
                    errorElement.textContent = 'âš ï¸ é¢œè‰²å¯¹æ¯”åº¦è¾ƒä½ï¼Œå¯èƒ½å½±å“æ‰«æè¯†åˆ«ã€‚å»ºè®®å¼€å¯å¼ºåˆ¶å…¼å®¹æ¨¡å¼æˆ–é€‰æ‹©å¯¹æ¯”åº¦æ›´é«˜çš„é¢œè‰²ç»„åˆã€‚';
                    errorElement.style.display = 'block';
                    setTimeout(() => errorElement.style.display = 'none', 4000);
                }
                
                // èƒŒæ™¯å›¾ç‰‡æˆ–çº¯è‰²èƒŒæ™¯
                if (bgImage) {
                    // è®¡ç®—èƒŒæ™¯å›¾ç‰‡çš„ç»˜åˆ¶å°ºå¯¸,ä¿æŒåŸå§‹æ¯”ä¾‹ä¸å˜å½¢
                    const imgAspect = bgImage.width / bgImage.height;
                    const canvasAspect = canvas.width / canvas.height;
                    
                    let drawWidth, drawHeight, drawX, drawY;
                    
                    if (imgAspect > canvasAspect) {
                        drawHeight = canvas.height;
                        drawWidth = drawHeight * imgAspect;
                        drawX = (canvas.width - drawWidth) / 2;
                        drawY = 0;
                    } else {
                        drawWidth = canvas.width;
                        drawHeight = drawWidth / imgAspect;
                        drawX = 0;
                        drawY = (canvas.height - drawHeight) / 2;
                    }
                    
                    ctx.drawImage(bgImage, drawX, drawY, drawWidth, drawHeight);
                    
                    // æ·»åŠ å®é™…èƒŒæ™¯è‰²åŠé€æ˜é®ç½©
                    const bgRgb = hexToRgb(actualBgColor);
                    ctx.fillStyle = `rgba(${bgRgb.r}, ${bgRgb.g}, ${bgRgb.b}, 0.69)`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    // ä½¿ç”¨å®é™…çš„èƒŒæ™¯è‰²
                    ctx.fillStyle = actualBgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                // è®¡ç®—å®é™…æ¨¡å—å°ºå¯¸
                const actualCellSize = Math.floor((canvas.width - margin * 2) / moduleCount);
                const actualQrSize = actualCellSize * moduleCount;
                const offset = (canvas.width - actualQrSize) / 2;
                
                // ç¡®ä¿æ¨¡å—è‡³å°‘ä¸º2åƒç´ ï¼Œæé«˜æ‰«æå™¨å…¼å®¹æ€§
                const finalCellSize = Math.max(actualCellSize, 2);
                const finalQrSize = finalCellSize * moduleCount;
                const finalOffset = (canvas.width - finalQrSize) / 2;
                
                // äºŒç»´ç  - æ ‡å‡†æ¸²æŸ“æ–¹å¼
                ctx.fillStyle = actualFgColor;
                ctx.imageSmoothingEnabled = false; // ç¦ç”¨å›¾åƒå¹³æ»‘ï¼Œä¿æŒæ¸…æ™°çš„è¾¹ç¼˜
                
                for (let row = 0; row < moduleCount; row++) {
                    for (let col = 0; col < moduleCount; col++) {
                        if (qr.isDark(row, col)) {
                            const x = Math.floor(col * finalCellSize + finalOffset);
                            const y = Math.floor(row * finalCellSize + finalOffset);
                            
                            ctx.fillRect(x, y, finalCellSize, finalCellSize);
                            
                            // ä¸ºå°å°ºå¯¸äºŒç»´ç å¢å¼ºå¯¹æ¯”åº¦
                            if (finalCellSize <= 3) {
                                ctx.fillRect(x, y, finalCellSize, finalCellSize);
                            }
                        }
                    }
                }
                
                // æ·»åŠ é™åŒºï¼ˆquiet zoneï¼‰- äºŒç»´ç æ ‡å‡†è¦æ±‚çš„ç©ºç™½åŒºåŸŸ
                ctx.fillStyle = actualBgColor;
                ctx.fillRect(0, 0, canvas.width, finalOffset);
                ctx.fillRect(0, canvas.height - finalOffset, canvas.width, finalOffset);
                ctx.fillRect(0, 0, finalOffset, canvas.height);
                ctx.fillRect(canvas.width - finalOffset, 0, finalOffset, canvas.height);
                
                // Logo
                if (logoImage) {
                    const logoSize = qrSize * 0.2;
                    const logoX = (canvas.width - logoSize) / 2;
                    const logoY = (canvas.height - logoSize) / 2;
                    
                    // LogoèƒŒæ™¯ï¼Œä½¿ç”¨å®é™…çš„èƒŒæ™¯è‰²
                    ctx.fillStyle = actualBgColor;
                    ctx.fillRect(logoX - 5, logoY - 5, logoSize + 10, logoSize + 10);
                    
                    // ç»˜åˆ¶Logo,ä¿æŒåŸå§‹æ¸…æ™°åº¦
                    ctx.drawImage(logoImage, logoX, logoY, logoSize, logoSize);
                }
                
                // åº•éƒ¨æ–‡å­—
                const bottomTextDisplay = document.getElementById('bottomTextDisplay');
                if (bottomText) {
                    bottomTextDisplay.textContent = bottomText;
                    bottomTextDisplay.style.display = 'block';
                } else {
                    bottomTextDisplay.style.display = 'none';
                }
                
                previewContent.style.display = 'none';
                qrcodeDisplay.style.display = 'block';
                downloadBtn.style.display = 'flex';
            } catch (e) {
                errorElement.textContent = 'âŒ ç”Ÿæˆå¤±è´¥ï¼š' + e.message;
                errorElement.style.display = 'block';
                setTimeout(() => errorElement.style.display = 'none', 3000);
            }
        }
        
        // ä¸‹è½½äºŒç»´ç 
        function downloadQRCode() {
            const canvas = document.getElementById('qrcode');
            const format = document.getElementById('exportFormat').value;
            const link = document.createElement('a');
            
            let mimeType = 'image/png';
            let extension = 'png';
            
            if (format === 'jpg') {
                mimeType = 'image/jpeg';
                extension = 'jpg';
            } else if (format === 'webp') {
                mimeType = 'image/webp';
                extension = 'webp';
            } else if (format === 'svg') {
                // SVGå¯¼å‡º
                const svgData = canvasToSVG(canvas);
                const blob = new Blob([svgData], {type: 'image/svg+xml'});
                link.href = URL.createObjectURL(blob);
                link.download = 'qrcode.svg';
                link.click();
                return;
            }
            
            link.download = 'qrcode.' + extension;
            link.href = canvas.toDataURL(mimeType, 0.95);
            link.click();
        }
        
        // Canvasè½¬SVG
        function canvasToSVG(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}">`;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3] / 255;
                    
                    if (a > 0) {
                        const color = `rgb(${r},${g},${b})`;
                        svg += `<rect x="${x}" y="${y}" width="1" height="1" fill="${color}" opacity="${a}"/>`;
                    }
                }
            }
            
            svg += '</svg>';
            return svg;
        }
        
        // æ ¸å¿ƒä»£ç ï¼šå¼ºåˆ¶ä¿æŒæ»‘å—ç„¦ç‚¹ï¼Œé˜²æ­¢è·³è½¬
        const sliders = document.querySelectorAll('input[type="range"]');
        sliders.forEach(slider => {
            let isDragging = false;
            
            slider.addEventListener('mousedown', e => {
                isDragging = true;
                slider.focus();
                
                const moveHandler = e => {
                    if (isDragging) {
                        slider.focus();
                    }
                };
                
                const upHandler = () => {
                    isDragging = false;
                    document.removeEventListener('mousemove', moveHandler);
                    document.removeEventListener('mouseup', upHandler);
                };
                
                document.addEventListener('mousemove', moveHandler);
                document.addEventListener('mouseup', upHandler);
            });
            
            slider.addEventListener('input', e => {
                slider.focus();
            });
        });
        
        // é˜»æ­¢è¾“å…¥æ¡†ç„¦ç‚¹
        // document.querySelectorAll('input[type="number"]').forEach(input => {
        //     input.addEventListener('focus', e => {
        //         e.preventDefault();
        //         input.blur();
        //     });
        // });
    </script>
</body>
</html>