<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>专业数学计算器 ProMax</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax @3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --glass-color: rgba(255, 255, 255, 0.15);
            --text-color: #ffffff;
            --setting-icon-color: #ffd700;
            --setting-bg-color: transparent;
            --transition-fast: 0.15s;
            --transition-medium: 0.3s;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body, html {
            height: 100%;
            overflow: auto;
            color: var(--text-color);
            position: relative;
            user-select: text;
        }

        /* 高级质感渐变背景 - 优化GPU加速 */
        .gradient-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg,
                #2c3e50 0%,
                #34495e 10%,
                #3498db 25%,
                #2980b9 35%,
                #1abc9c 45%,
                #16a085 55%,
                #27ae60 65%,
                #f1c40f 80%,
                #e67e22 90%,
                #e74c3c 100%);
            background-size: 400% 400%;
            animation: gradientShift 30s ease infinite;
            z-index: -2;
            will-change: transform;
            transform: translateZ(0);
        }

        /* 背景柔和发光效果 - 优化GPU加速 */
        .glow-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 30%, rgba(52, 152, 219, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(26, 188, 156, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(241, 196, 15, 0.15) 0%, transparent 50%);
            z-index: -1;
            opacity: 0.3;
            will-change: opacity;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* 顶部标题栏 - 非固定悬浮，去除背景以避免颜色线 */
        .top-header {
            width: 100%;
            padding: 15px 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* 标题容器 - 修改为顶部居中，去除下边距 */
        .header-title {
            display: inline-block;
            font-size: clamp(1.5em, 4vw, 2.5em);
            font-weight: 800;
            white-space: nowrap;
            letter-spacing: 1px;
            background-color: #000000;
            border-radius: 10px;
            padding: 8px 20px;
            box-shadow:
                0 0 15px rgba(241, 196, 15, 0.6),
                0 0 30px rgba(52, 152, 219, 0.4),
                0 0 45px rgba(26, 188, 156, 0.3);
            text-align: center;
            margin: 0;
        }

        /* 标题文字渐变效果 - 优化GPU加速 */
        .title-text {
            background: linear-gradient(135deg,
                #f1c40f 0%,
                #f7dc6f 15%,
                #1abc9c 30%,
                #ffffff 50%,
                #3498db 70%,
                #f7dc6f 85%,
                #f1c40f 100%);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleTextFlow 8s ease-in-out infinite;
            text-shadow: 0 0 15px rgba(241, 196, 15, 0.3);
            display: inline-block;
            will-change: transform;
        }

        @keyframes titleTextFlow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* 设置按钮容器 */
        .settings-container {
            display: flex;
            justify-content: center;
            margin: 0;
        }

        /* 优化按钮动画 - 使用GPU加速和简化动画 */
        .settings-button {
            cursor: pointer;
            font-size: 3em;
            animation: rotateSettings 48s linear infinite;
            transition: transform var(--transition-fast);
            transform-origin: center center;
            display: inline-block;
            width: 1em;
            height: 1em;
            line-height: 1;
            text-align: center;
            vertical-align: middle;
            margin-right: 20px;
            will-change: transform;
        }

        /* 搜索按钮 - 镜像效果，镜头向右，使用呼吸动画 */
        .search-button {
            cursor: pointer;
            font-size: 3em;
            animation: searchBreathe 4s ease-in-out infinite;
            transition: transform var(--transition-fast);
            transform-origin: center center;
            display: inline-block;
            width: 1em;
            height: 1em;
            line-height: 1;
            text-align: center;
            vertical-align: middle;
            margin-right: 20px;
            transform: scaleX(-1);
            will-change: transform;
        }

        /* AIOS按钮 - 机器人风格，使用放大缩小动画 */
        .aios-button {
            cursor: pointer;
            font-size: 3em;
            animation: aiosPulse 3s ease-in-out infinite;
            transition: transform var(--transition-fast);
            transform-origin: center center;
            display: inline-block;
            width: 1em;
            height: 1em;
            line-height: 1;
            text-align: center;
            vertical-align: middle;
            filter: drop-shadow(0 0 10px rgba(138, 43, 226, 0.6));
            will-change: transform;
        }

        /* 简化设置按钮旋转动画 - 减少关键帧 */
        @keyframes rotateSettings {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(4680deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(4680deg); }
            100% { transform: rotate(0deg); }
        }

        /* 设置按钮点击效果 */
        .settings-button:active {
            animation: rotateSettingsClick 0.5s ease;
        }

        @keyframes rotateSettingsClick {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* 搜索按钮呼吸效果 - 上下浮动 */
        @keyframes searchBreathe {
            0% { transform: translateY(0px) scale(1); }
            25% { transform: translateY(-8px) scale(1.1); }
            50% { transform: translateY(0px) scale(1); }
            75% { transform: translateY(5px) scale(0.95); }
            100% { transform: translateY(0px) scale(1); }
        }

        /* AIOS按钮放大缩小动画 */
        @keyframes aiosPulse {
            0% { transform: scale(1); opacity: 1; }
            25% { transform: scale(1.3); opacity: 0.9; }
            50% { transform: scale(1); opacity: 1; }
            75% { transform: scale(0.8); opacity: 0.95; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* AIOS按钮点击效果 */
        .aios-button:active {
            animation: aiosActivate 0.6s ease;
        }

        @keyframes aiosActivate {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        /* 搜索按钮点击效果 */
        .search-button:active {
            animation: searchPulse 0.6s ease;
        }

        @keyframes searchPulse {
            0% { transform: scale(1); opacity: 1; }
            25% { transform: scale(1.3); opacity: 0.8; }
            50% { transform: scale(1); opacity: 1; }
            75% { transform: scale(0.8); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0px 20px 10px;
            position: relative;
            z-index: 3;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
            text-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
        }

        .calculator {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }

        .input-section, .output-section {
            flex: 1;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 0 20px rgba(241, 196, 15, 0.4),
                0 0 40px rgba(52, 152, 219, 0.3),
                0 0 60px rgba(26, 188, 156, 0.2);
        }

        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--text-color);
            border-bottom: 2px solid rgba(241, 196, 15, 0.5);
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-color);
        }

        input, select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 16px;
            transition: all var(--transition-medium);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
        }

        input:focus, select:focus, textarea:focus {
            border-color: rgba(241, 196, 15, 0.6);
            box-shadow: 0 0 0 3px rgba(241, 196, 15, 0.3);
            outline: none;
        }

        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-medium);
            min-width: 140px;
        }

        .calculate-btn {
            background: rgba(52, 152, 219, 0.7);
            color: white;
            backdrop-filter: blur(5px);
        }

        .calculate-btn:hover {
            background: rgba(41, 128, 185, 0.9);
            transform: translateY(-2px);
        }

        .clear-btn {
            background: rgba(231, 76, 60, 0.7);
            color: white;
            backdrop-filter: blur(5px);
        }

        .clear-btn:hover {
            background: rgba(192, 57, 43, 0.9);
            transform: translateY(-2px);
        }

        .paste-btn {
            background: rgba(46, 204, 113, 0.7);
            color: white;
            backdrop-filter: blur(5px);
        }

        .paste-btn:hover {
            background: rgba(39, 174, 96, 0.9);
            transform: translateY(-2px);
        }

        .output {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 20px;
            min-height: 200px;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(5px);
        }

        .math-expression {
            font-size: 1.2rem;
            text-align: center;
            padding: 15px;
            margin: 10px 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            position: relative;
            backdrop-filter: blur(5px);
        }

        .copy-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            color: rgba(52, 152, 219, 0.8);
            font-size: 1.2rem;
            transition: all var(--transition-medium);
        }

        .copy-icon:hover {
            color: rgba(41, 128, 185, 0.9);
            transform: scale(1.1);
        }

        .steps {
            margin-top: 20px;
        }

        .step {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            backdrop-filter: blur(5px);
        }

        .step-title {
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .example-section {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 0 20px rgba(241, 196, 15, 0.4),
                0 0 40px rgba(52, 152, 219, 0.3),
                0 0 60px rgba(26, 188, 156, 0.2);
            margin-bottom: 30px;
        }

        .examples {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .example {
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all var(--transition-medium);
            border-left: 4px solid rgba(241, 196, 15, 0.7);
            backdrop-filter: blur(5px);
        }

        .example:hover {
            background: rgba(233, 236, 239, 0.2);
            transform: translateY(-3px);
        }

        .example-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--text-color);
        }

        .example-expression {
            font-family: monospace;
            color: rgba(255, 255, 0, 0.9);
            word-break: break-all;
            white-space: normal;
        }

        .function-reference {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 25px;
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow:
                0 0 20px rgba(241, 196, 15, 0.4),
                0 0 40px rgba(52, 152, 219, 0.3),
                0 0 60px rgba(26, 188, 156, 0.2);
        }

        .function-categories {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .function-category {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            backdrop-filter: blur(5px);
        }

        .category-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-color);
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
        }

        .function-list {
            list-style-type: none;
        }

        .function-list li {
            padding: 5px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.3);
        }

        .function-list li:last-child {
            border-bottom: none;
        }

        footer {
            text-align: center;
            margin-top: 30px;
            color: white;
            opacity: 0.8;
        }

        .error {
            color: rgba(231, 76, 60, 0.9);
            background: rgba(250, 219, 216, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(46, 204, 113, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
        }

        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-20px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }

        .result-text {
            font-family: 'Courier New', monospace;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0 0 0;
            border-left: 4px solid rgba(52, 152, 219, 0.7);
            font-size: 1.3rem;
            line-height: 1.6;
            font-weight: bold;
            word-break: break-word;
            white-space: pre-wrap;
            overflow-wrap: break-word;
            backdrop-filter: blur(5px);
        }

        .approximation-text {
            font-size: 0.9em;
            color: rgba(108, 117, 125, 0.9);
            margin-top: 5px;
            padding: 5px 15px;
            text-align: left;
            border-top: 1px dashed rgba(255, 255, 255, 0.3);
        }

        .exponential {
            color: rgba(231, 76, 60, 0.9);
            font-weight: bold;
        }

        .result-title {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 10px;
        }

        .evaluation-input {
            margin-top: 10px;
            padding: 10px;
            background: rgba(232, 244, 252, 0.2);
            border-radius: 5px;
            backdrop-filter: blur(5px);
        }

        .evaluation-input input {
            margin: 5px;
            padding: 8px;
            width: 80px;
        }

        .infinity-warning {
            color: rgba(231, 76, 60, 0.9);
            background: rgba(253, 234, 234, 0.3);
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid rgba(231, 76, 60, 0.9);
        }

        /* AIOS面板 - 优化性能 */
        .aios-panel {
            position: fixed;
            top: 0;
            left: 0;
            transform: none;
            width: 100vw;
            height: 100vh;
            max-width: 100vw;
            max-height: 100vh;
            padding: 0;
            border-radius: 0;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(75, 0, 130, 0.1));
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: none;
            box-shadow:
                0 0 15px rgba(138, 43, 226, 0.4),
                0 0 30px rgba(75, 0, 130, 0.3),
                0 0 45px rgba(138, 43, 226, 0.2),
                inset 0 0 20px rgba(138, 43, 226, 0.1);
            z-index: 997;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-medium);
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            will-change: opacity;
        }

        .aios-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        /* 手机端优化 */
        @media (max-width: 768px) {
            .aios-panel {
                width: 100vw;
                height: 100vh;
                max-width: 100vw;
                max-height: 100vh;
                padding: 0;
                border-radius: 0;
            }
            
            .aios-tabs {
                flex-direction: row;
                gap: 5px;
                margin-bottom: 20px;
            }
            
            .aios-tab-btn {
                width: 80px !important;
                height: 40px !important;
                min-width: 80px !important;
                max-width: 80px !important;
                min-height: 40px !important;
                max-height: 40px !important;
                font-size: 0.8em !important;
                box-sizing: border-box !important;
            }
            
            .chat-container {
                padding: 15px;
            }
            
            .chat-messages {
                height: 350px;
            }
            
            .chat-input-container {
                flex-direction: column;
                gap: 10px;
            }
            
            #chatInput {
                padding: 15px;
                font-size: 16px;
            }
            
            .aios-send-btn {
                width: 40px !important;
                height: 40px !important;
                min-width: 40px !important;
                max-width: 40px !important;
                min-height: 40px !important;
                max-height: 40px !important;
                font-size: 1em !important;
                box-sizing: border-box !important;
            }
            
            .analysis-tools {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .tool-card {
                padding: 15px;
            }
            
            .ai-tools-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
            
            .ai-tool-item {
                padding: 15px 10px;
            }
            
            .aios-actions {
                flex-direction: column;
                gap: 10px;
            }
            
            .aios-action-btn {
                padding: 18px;
                font-size: 1em;
            }
        }

        .aios-tabs {
            display: none; /* 原有标签页隐藏 */
        }
        
        /* 新增横向标签页样式 - 仅在桌面端显示 */
        .aios-tabs-horizontal {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .aios-tabs-horizontal .aios-tab-btn {
            width: 91px !important;
            height: 40px !important;
            min-width: 91px !important;
            max-width: 91px !important;
            min-height: 40px !important;
            max-height: 40px !important;
            padding: 0;
            border: none;
            border-radius: 6px;
            background: rgba(138, 43, 226, 0.2);
            color: var(--text-color);
            cursor: pointer;
            transition: all var(--transition-medium);
            font-size: 0.9em !important;
            font-weight: 600;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-sizing: border-box !important;
            flex-direction: column;
        }
        
        .aios-tabs-horizontal .aios-tab-btn.active {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.6));
            color: white;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
        }
        
        .aios-tabs-horizontal .aios-tab-btn:hover {
            background: rgba(138, 43, 226, 0.3);
            transform: translateY(-2px);
        }
        
        .aios-tabs-horizontal .aios-tab-btn.active:hover {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.7), rgba(75, 0, 130, 0.7));
            box-shadow: 0 6px 20px rgba(138, 43, 226, 0.5);
        }
        
        /* 手机端保持原有布局 */
        @media (max-width: 768px) {
            .aios-tabs {
                display: flex !important; /* 手机端恢复原有标签页 */
                flex-direction: row;
                gap: 5px;
                margin-bottom: 20px;
            }
            
            .aios-tabs-horizontal {
                display: none; /* 手机端隐藏横向标签页 */
            }
        }

        .aios-tab-btn {
            width: 91px !important;
            height: 69px !important;
            min-width: 91px !important;
            max-width: 91px !important;
            min-height: 69px !important;
            max-height: 69px !important;
            padding: 0;
            border: none;
            border-radius: 6px;
            background: rgba(138, 43, 226, 0.2);
            color: var(--text-color);
            cursor: pointer;
            transition: all var(--transition-medium);
            font-size: 1.2em !important;
            font-weight: 600;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            box-sizing: border-box !important;
            flex-direction: column;
        }

        .aios-tab-btn.active {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.6));
            color: white;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.4);
        }

        .aios-tab-btn:hover {
            background: rgba(138, 43, 226, 0.3);
            transform: translateY(-2px);
        }

        .aios-tab-btn.active:hover {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.7), rgba(75, 0, 130, 0.7));
            box-shadow: 0 6px 20px rgba(138, 43, 226, 0.5);
        }

        .aios-tab-content {
            display: none;
        }

        .aios-tab-content.active {
            display: block;
        }

        /* API配置区域样式 */
        .api-config-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid rgba(138, 43, 226, 0.3);
            overflow: hidden;
        }

        .api-config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(138, 43, 226, 0.2);
            cursor: pointer;
            transition: background 0.3s;
        }

        .api-config-header:hover {
            background: rgba(138, 43, 226, 0.3);
        }

        .api-config-title {
            font-weight: bold;
            color: var(--text-color);
            font-size: 1.1em;
        }

        .api-config-toggle {
            color: var(--text-color);
            transition: transform 0.3s;
        }

        .api-config-content {
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
        }

        .api-config-item {
            margin-bottom: 12px;
        }

        .api-config-item label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: var(--text-color);
        }

        .api-config-item input {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            font-size: 0.9em;
        }

        .api-config-btn {
            padding: 3px 6px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0);
            color: white;
            cursor: pointer;
            font-size: 1.5rem;
            font-weight: 600;
            transition: all 0.3s;
            width: auto;
            height: auto;
            min-width: 30px;
            max-width: 300px;
            display: inline-block;
            text-align: center;
            line-height: 1.2;
            vertical-align: middle;
            flex-shrink: 0;
            margin-top: 10px;
        }

        .api-config-btn:hover {
            background: rgba(138, 43, 226, 0.8);
            transform: scale(1.05);
        }

        /* API配置面板样式 */
        .api-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            padding: 30px;
            border-radius: 15px;
            background: rgba(138, 43, 226, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 2px solid rgba(138, 43, 226, 0.3);
            box-shadow:
                0 0 15px rgba(138, 43, 226, 0.4),
                0 0 30px rgba(75, 0, 130, 0.3),
                0 0 45px rgba(138, 43, 226, 0.2);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-medium);
            will-change: opacity;
        }

        .api-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        .api-panel h2 {
            text-align: center;
            margin-bottom: 20px;
            color: var(--text-color);
        }

        .api-close-btn {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: rgba(231, 76, 60, 0.7);
            color: white;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .api-close-btn:hover {
            background: rgba(192, 57, 43, 0.9);
        }

        .api-config-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .api-save-btn, .api-test-btn, .api-reset-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            transition: all 0.3s;
        }

        .api-save-btn {
            background: rgba(46, 204, 113, 0.7);
            color: white;
        }

        .api-save-btn:hover {
            background: rgba(39, 174, 96, 0.9);
        }

        .api-test-btn {
            background: rgba(241, 196, 15, 0.7);
            color: #2c3e50;
        }

        .api-test-btn:hover {
            background: rgba(243, 156, 18, 0.9);
        }

        .api-reset-btn {
            background: rgba(231, 76, 60, 0.7);
            color: white;
        }

        .api-reset-btn:hover {
            background: rgba(192, 57, 43, 0.9);
        }

        /* 聊天界面样式 - 优化版本 */
        .chat-container {
            background: #333333; /* Changed to black-gray color */
            border-radius: 10px;
            padding: 10px;
            border: 1px solid rgba(138, 43, 226, 0.2);
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.5); /* Darker background for messages */
            border-radius: 8px;
            min-height: 720px;
            max-height: 725px;/*电脑端聊天页面高度*/
        }
        /* 手机端适配 */
@media (max-width: 768px) {
    .chat-messages {
        /*适人握持*/
        min-height: 520px; /* 设置一个合理的手机端最小高度 */
        
    }
}

        .ai-message {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
        }

        .user-message {
            display: flex;
            margin-bottom: 15px;
            align-items: flex-start;
            justify-content: flex-end;
        }

        /* 思考过程样式 */
        .reasoning-container {
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid rgba(138, 43, 226, 0.2);
            overflow: hidden;
        }

        .reasoning-header {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: rgba(138, 43, 226, 0.1);
            cursor: pointer;
            transition: background 0.3s;
        }

        .reasoning-header:hover {
            background: rgba(138, 43, 226, 0.2);
        }

        .reasoning-toggle {
            color: rgba(255, 255, 255, 0.7);
            margin-right: 8px;
            font-size: 0.9em;
            transition: transform 0.3s;
        }

        .reasoning-title {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.9em;
            font-style: italic;
        }

        .reasoning-content {
            padding: 10px 12px;
            color: rgb(255, 255, 255);
            font-size: 0.9em;
            line-height: 1.4;
            opacity: 0.8;
        }

        .reasoning-content p {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        /* 主内容样式 */
        .main-content {
            margin-top: 5px;
        }

        .ai-avatar {
            font-size: 1.2em;
            margin-right: 8px;
            min-width: 25px;
            flex-shrink: 0;
        }

        .user-avatar {
            font-size: 1.2em;
            margin-left: 8px;
            min-width: 25px;
            flex-shrink: 0;
        }

        /* 去除消息方框，只显示文字 */
        .message-content {
            position: relative;
        }

        .user-content {
            position: relative;
        }

        /* 消息内容支持换行展示 */
        .message-content p, .user-content p {
            margin: 0 0 15px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
        }

        /* 复制和折叠图标样式 */
        .message-actions {
            display: inline-block;
            margin-left: 5px;
            opacity: 0.7;
            transition: opacity 0.2s;
            vertical-align: middle;
        }

        .message-content:hover .message-actions,
        .user-content:hover .message-actions {
            opacity: 1;
        }

        .message-actions {
            font-size: 14px; /* Increased size */
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.2s;
            display: inline-block;
            vertical-align: middle;
        }

        .message-actions:hover {
            color: rgba(255, 255, 255, 1);
        }
        
        /* 折叠控件样式 - 移到消息上方 */
        .expand-controls {
            text-align: right;
            margin-bottom: 5px;
            padding: 3px 5px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 12px;
        }
        
        .message-action-icon {
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            transition: color 0.2s;
            margin-left: 5px;
        }
        
        .message-action-icon:hover {
            color: rgba(255, 255, 255, 1);
        }

        /* 消息折叠样式 */
        .collapsed-message {
            max-height: 100px;
            overflow: hidden;
            position: relative;
        }

        .collapsed-message::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.5));
        }

        /* 消息内容样式 */
        .message-content p, .user-content p {
            margin: 0 0 10px 0;
            white-space: pre-wrap;
            word-wrap: break-word;
            line-height: 1.5;
            overflow-wrap: break-word;
            max-width: 100%;
            word-break: break-word;
            overflow-x: auto;
            font-family: inherit;
        }

        /* 聊天消息容器样式 - 固定大小 */
        .chat-messages {
            overflow-y: auto;
            margin-bottom: 10px;
            padding: 8px;
            padding-right: 10px; /* 减少右侧内边距 */
            background: rgba(0, 0, 0, 0.5); /* Darker background for messages */
            border-radius: 8px;
            height: 520px; /* 增加固定高度 */
            max-height: 520px; /* 确保最大高度等于固定高度 */
            position: relative;
            flex-shrink: 0; /* 防止伸缩 */
            flex-grow: 0; /* 防止增长 */
        }

        .expand-indicator {
            font-size: 14px; /* Increased size */
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            margin-left: 5px;
            display: inline-block;
            vertical-align: middle;
        }

        .expand-indicator:hover {
            color: rgba(255, 255, 255, 1);
        }

        .chat-input-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .input-row {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }

        #chatInput {
            flex: 1;
            padding: 10px 12px;
            border: 2px solid rgba(138, 43, 226, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            font-size: 14px;
            font-family: 'Courier New', monospace; /* 使用等宽字体处理代码 */
            resize: none;
            min-height: 40px;
            max-height: 120px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        #chatInput:focus {
            border-color: rgba(138, 43, 226, 0.6);
            box-shadow: 0 0 0 2px rgba(138, 43, 226, 0.3);
            outline: none;
        }

        .aios-send-btn {
            width: 66px !important;
            height: 66px !important;
            min-width: 66px !important;
            max-width: 66px !important;
            min-height: 66px !important;
            max-height: 66px !important;
            border: none;
            border-radius: 6px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.6));
            color: white;
            font-size: 1.5em !important;
            cursor: pointer;
            transition: all var(--transition-medium);
            flex-shrink: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box !important;
            transform: rotate(-90deg);
        }

        .aios-send-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4);
        }
        
        /* 停止按钮状态样式 */
        .aios-send-btn.stop-mode {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.8), rgba(192, 57, 43, 0.8));
            transform: scale(1.1) rotate(-90deg);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.5);
        }
        
        .aios-send-btn.stop-mode:hover {
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.9), rgba(192, 57, 43, 0.9));
            transform: scale(1.15) rotate(-90deg);
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.7);
        }

        /* 数据分析工具样式 */
        .analysis-tools {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }

        .tool-card {
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all var(--transition-medium);
        }

        .tool-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(138, 43, 226, 0.3);
            background: rgba(138, 43, 226, 0.15);
        }

        .tool-icon {
            font-size: 2em;
            margin-bottom: 8px;
        }

        .tool-card h4 {
            color: var(--text-color);
            margin-bottom: 5px;
            font-size: 1em;
        }

        .tool-card p {
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 12px;
            font-size: 0.8em;
        }

        .aios-tool-btn {
            padding: 8px 12px;
            border: none;
            border-radius: 15px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.6));
            color: white;
            cursor: pointer;
            transition: all var(--transition-medium);
            font-weight: 600;
            font-size: 0.9em;
        }

        .aios-tool-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4);
        }

        /* AI工具网格样式 */
        .ai-tools-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .ai-tool-item {
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 8px;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            transition: all var(--transition-medium);
        }

        .ai-tool-item:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 6px 15px rgba(138, 43, 226, 0.3);
            background: rgba(138, 43, 226, 0.2);
        }

        .tool-emoji {
            font-size: 1.5em;
            display: block;
            margin-bottom: 5px;
        }

        .tool-name {
            color: var(--text-color);
            font-weight: 600;
            font-size: 0.8em;
        }

        .aios-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .aios-action-btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.6), rgba(75, 0, 130, 0.6));
            color: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-medium);
        }

        .aios-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 15px rgba(138, 43, 226, 0.4);
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.7), rgba(75, 0, 130, 0.7));
        }

        /* 搜索面板 - 优化性能 */
        .search-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1280px;
            max-width: 90vw;
            max-height: 90vh;
            padding: 40px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow:
                0 0 15px rgba(52, 152, 219, 0.4),
                0 0 30px rgba(26, 188, 156, 0.3),
                0 0 45px rgba(241, 196, 15, 0.2);
            z-index: 998;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-medium);
            overflow-y: auto;
            will-change: opacity;
        }

        .search-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        .search-input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        #searchInput {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            font-size: 16px;
            transition: all var(--transition-medium);
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
        }

        #searchInput:focus {
            border-color: rgba(52, 152, 219, 0.6);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
            outline: none;
        }

        .search-submit-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            background: rgba(52, 152, 219, 0.7);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-medium);
        }

        .search-submit-btn:hover {
            background: rgba(41, 128, 185, 0.9);
            transform: translateY(-2px);
        }

        .search-options {
            margin-bottom: 20px;
        }

        .search-results-container {
            margin-bottom: 20px;
        }

        .search-results {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
        }

        .search-result-item {
            padding: 10px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: all var(--transition-medium);
            border-left: 3px solid rgba(52, 152, 219, 0.7);
        }

        .search-result-item:hover {
            background: rgba(233, 236, 239, 0.2);
            transform: translateX(5px);
        }

        .search-result-title {
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 5px;
        }

        .search-result-description {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
        }

        .no-results {
            text-align: center;
            color: rgba(255, 255, 255, 0.6);
            font-style: italic;
        }

        .search-actions {
            display: flex;
            gap: 10px;
        }

        /* 修复设置面板 - 优化性能 */
        .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 1280px;
            max-width: 90vw;
            padding: 40px;
            border-radius: 15px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow:
                0 0 15px rgba(241, 196, 15, 0.4),
                0 0 30px rgba(52, 152, 219, 0.3),
                0 0 45px rgba(26, 188, 156, 0.2);
            z-index: 999;
            opacity: 0;
            pointer-events: none;
            transition: opacity var(--transition-medium);
            will-change: opacity;
        }

        .settings-panel.active {
            opacity: 1;
            pointer-events: all;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px dashed rgba(255, 255, 255, 0.3);
        }

        .setting-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .setting-item label {
            display: flex;
            align-items: center;
            font-weight: 600;
            min-width: 120px;
        }

        .setting-item i {
            margin-right: 8px;
            font-style: normal;
            color: var(--setting-icon-color);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 24px;
            flex-shrink: 0;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: 0.4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background: linear-gradient(135deg, #f1c40f, #1abc9c);
        }

        input:checked + .slider:before {
            transform: translateX(91px);
        }

        select {
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.2);
            background-color: #3c3131;
            color: var(--text-color);
            font-size: 0.9em;
            cursor: pointer;
            min-width: 180px;
            width: 180px;
        }

        .range-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-value {
            min-width: 40px;
            text-align: right;
        }

        .dynamic-slider {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            width: 120px;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(90deg,
                #2c3e50, #3498db, #1abc9c, #16a085, #27ae60, #f1c40f, #e67e22, #e74c3c);
            background-size: 300% 100%;
            outline: none;
            cursor: pointer;
        }

        .dynamic-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.8);
            border: 2px solid #f1c40f;
            transition: all var(--transition-fast);
        }

        .dynamic-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 12px rgba(241, 196, 15, 1);
        }

        .dynamic-slider::-moz-range-thumb {
            -moz-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(241, 196, 15, 0.8);
            border: 2px solid #f1c40f;
            transition: all var(--transition-fast);
        }

        .preview-button {
            width: 100%;
            padding: 12px;
            border-radius: 10px;
            background: linear-gradient(135deg, #f1c40f, #1abc9c);
            color: #2c3e50;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 8px;
            transition: all var(--transition-medium);
            box-shadow: 0 0 12px rgba(241, 196, 15, 0.4);
            font-size: 0.95em;
        }

        .preview-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(241, 196, 15, 0.6);
        }

        .preview-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }

        /* AIOS面板关闭按钮样式 - Windows/MacOS风格 */
        .aios-panel-close-btn {
            position: fixed;
            top: 20px;
            font-size: 18px;
            font-weight: bold;
            color: rgba(255, 255, 255, 0.9);
            cursor: pointer;
            transition: all 0.2s;
            z-index: 1001;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(231, 76, 60, 0.9);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: none;
        }

        .aios-panel-close-btn:hover {
            background: rgba(231, 76, 60, 1);
            transform: scale(1.1);
        }

        .aios-panel-close-left {
            left: 20px;
        }

        .aios-panel-close-right {
            right: 20px;
        }

        /* 手机端适配 */
        @media (max-width: 768px) {
            .aios-panel-close-btn {
                width: 36px;
                height: 36px;
                font-size: 16px;
                top: 10px;
            }
            
            .aios-panel-close-left {
                left: 10px;
            }
            
            .aios-panel-close-right {
                right: 10px;
            }
        }

        /* 聊天导航按钮样式 */
        .chat-nav-btn {
            padding: 4px 8px;
            background: rgba(52, 152, 219, 0.7);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            margin: 5px 0;
            display: inline-block;
            white-space: nowrap;
        }

        .chat-nav-btn:hover {
            background: rgba(41, 128, 185, 0.9);
            transform: scale(1.05);
        }

        .chat-nav-top {
            align-self: flex-end;
            margin-bottom: 5px;
        }

        .chat-nav-bottom {
            align-self: flex-end;
            margin-top: 5px;
        }

        /* 聊天控制按钮容器 - 完全悬浮透明 */
        .chat-controls-container {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 13px;
            z-index: 1000;
        }

        /* 聊天控制按钮位置 - 透明样式 */
        #chatTrackBtn, #chatTopBtn, #chatBottomBtn {
            display: block;
            margin: 0;
            padding: 0;
            background: transparent;
            color: rgba(255, 255, 255, 1);
            font-size: 16px;
            cursor: pointer;
            transition: color 0.2s;
            white-space: nowrap;
        }

        #chatTrackBtn:hover, #chatTopBtn:hover, #chatBottomBtn:hover {
            color: rgba(255, 255, 255, 1);
        }

        /* AI思考加载动画 */
        .thinking-indicator {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            padding: 12px 15px;
            background: rgba(138, 43, 226, 0.1);
            border-radius: 8px;
            border-left: 3px solid rgba(138, 43, 226, 0.7);
            animation: fadeIn 0.3s ease-in;
        }
        
        /* 停止消息样式 */
        .stop-message {
            opacity: 0.8;
            background: rgba(231, 76, 60, 0.1);
            border-left: 3px solid rgba(231, 76, 60, 0.7);
        }

        .thinking-dots {
            display: flex;
            gap: 4px;
            margin-left: 10px;
        }

        .thinking-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: rgba(138, 43, 226, 0.8);
            animation: thinkingPulse 1.4s infinite ease-in-out both;
        }

        .thinking-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .thinking-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes thinkingPulse {
            0%, 80%, 100% {
                transform: scale(0.8);
                opacity: 0.5;
            }
            40% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .calculator {
                flex-direction: column;
            }

            h1 {
                font-size: 2.2rem;
            }

            .function-categories {
                grid-template-columns: 1fr;
            }

            .result-text {
                font-size: 1.1rem;
            }

            textarea, .example-expression, .result-text {
                word-break: break-word;
                white-space: pre-wrap;
            }

            .container {
                padding: 0px 10px 0px;
            }

            .top-header {
                padding: 10px 15px;
            }

            .header-title {
                font-size: clamp(1.2em, 3.5vw, 2em);
                padding: 6px 15px;
            }

            .settings-button {
                font-size: 2.5em;
                width: 60px;
                height: 60px;
                line-height: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="gradient-background"></div>
    <div class="glow-effect"></div>

    <!-- 顶部标题栏 -->
    <div class="top-header">
        <div class="header-title">
            <span class="title-text">专业数学计算器 ProMax</span>
        </div>
    </div>

    <!-- 搜索、设置和AiOS按钮区域 -->
    <div class="settings-container">
        <div class="search-button" title="搜索">🔍</div>
        <div class="settings-button" title="设置">⚙️</div>
        <div class="aios-button" title="AiOS">🤖</div>
    </div>

    <!-- AIOS面板外部关闭按钮 -->
    <div class="aios-panel-close-btn aios-panel-close-left" id="closeAiosLeftBtn" style="display: none;">×</div>
    <div class="aios-panel-close-btn aios-panel-close-right" id="closeAiosRightBtn" style="display: none;">×</div>
    
    <div class="aios-panel">
        <div style="display: flex; justify-content: center; align-items: center; margin: 0; margin-bottom: 10px; flex-wrap: wrap;">
            <h2 style="margin: 0; margin-right: 15px;">🤖 AIOS 智能助手</h2>
            <div class="aios-tabs-horizontal">
                <button class="aios-tab-btn active" data-tab="chat">
                    <span>💬</span>
                    <span>智能对话</span>
                </button>
                <button class="aios-tab-btn" data-tab="analysis">
                    <span>📊</span>
                    <span>数据分析</span>
                </button>
                <button class="aios-tab-btn" data-tab="tools">
                    <span>🔧</span>
                    <span>AI工具</span>
                </button>
            </div>
            <button class="api-config-btn" id="apiConfigBtn" title="点击配置API，设置后可使用智能AI对话">🔗 API</button>
        </div>
        
        <div class="aios-operations">
            <!-- 智能对话标签页 -->
            <div class="aios-tab-content active" id="chat-tab">
                
                <div class="chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <!-- 聊天控制按钮 - 悬浮在中间 -->
                        <div class="chat-controls-container">
                            <span id="chatTopBtn" title="回到顶部">↑顶部</span>
                            <span id="chatTrackBtn" title="返回上次位置">↑回展↓</span>
                            <span id="chatBottomBtn" title="前往底部">↓底部</span>
                            <span id="chatClearBtn" title="清空聊天历史">🗑️清空</span>
                            <span id="voiceBtn" title="语音交互">🎤语音</span>
                            <span id="closeAiosBtn" title="关闭面板">❌关闭</span>
                        </div>
                        
                        <div class="ai-message">
                            <span class="ai-avatar">🤖</span>
                            <div class="message-content">
                                <p>您好！我是AIOS智能助手，有什么可以帮助您的吗？</p>
                            </div>
                        </div>
                    </div>
                    
                    <div class="chat-input-container">
                        <div class="input-row">
                            <textarea id="chatInput" placeholder="输入您的问题... (Ctrl+Enter发送，支持数学公式)" autocomplete="off"></textarea>
                            <button class="aios-send-btn" id="sendBtn">➤</button>
                        </div>
                        <div class="math-shortcuts" style="display: flex; gap: 5px; margin-top: 5px; flex-wrap: wrap;">
                            <span class="math-shortcut" data-formula="∫" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">∫</span>
                            <span class="math-shortcut" data-formula="∂" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">∂</span>
                            <span class="math-shortcut" data-formula="∑" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">∑</span>
                            <span class="math-shortcut" data-formula="∏" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">∏</span>
                            <span class="math-shortcut" data-formula="√" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">√</span>
                            <span class="math-shortcut" data-formula="∞" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">∞</span>
                            <span class="math-shortcut" data-formula="π" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">π</span>
                            <span class="math-shortcut" data-formula="α" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">α</span>
                            <span class="math-shortcut" data-formula="β" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">β</span>
                            <span class="math-shortcut" data-formula="θ" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">θ</span>
                            <span class="math-shortcut" data-formula="λ" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">λ</span>
                            <span class="math-shortcut" data-formula="μ" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">μ</span>
                            <span class="math-shortcut" data-formula="σ" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">σ</span>
                            <span class="math-shortcut" data-formula="φ" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">φ</span>
                            <span class="math-shortcut" data-formula="ω" style="cursor: pointer; padding: 2px 5px; background: rgba(138, 43, 226, 0.2); border-radius: 3px; font-size: 12px;">ω</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 数据分析标签页 -->
            <div class="aios-tab-content" id="analysis-tab">
                <div class="analysis-tools">
                    <div class="tool-card">
                        <div class="tool-icon">📈</div>
                        <h4>数据可视化</h4>
                        <p>将您的数据转换为图表</p>
                        <button class="aios-tool-btn">开始分析</button>
                    </div>
                    <div class="tool-card">
                        <div class="tool-icon">🔍</div>
                        <h4>智能搜索</h4>
                        <p>快速找到您需要的信息</p>
                        <button class="aios-tool-btn">开始搜索</button>
                    </div>
                    <div class="tool-card">
                        <div class="tool-icon">⚡</div>
                        <h4>快速计算</h4>
                        <p>AI驱动的数学计算</p>
                        <button class="aios-tool-btn">开始计算</button>
                    </div>
                </div>
            </div>
            
            <!-- AI工具标签页 -->
            <div class="aios-tab-content" id="tools-tab">
                <div class="ai-tools-grid">
                    <div class="ai-tool-item">
                        <span class="tool-emoji">🎨</span>
                        <span class="tool-name">图像生成</span>
                    </div>
                    <div class="ai-tool-item">
                        <span class="tool-emoji">📝</span>
                        <span class="tool-name">文本创作</span>
                    </div>
                    <div class="ai-tool-item">
                        <span class="tool-emoji">🎵</span>
                        <span class="tool-name">音乐创作</span>
                    </div>
                    <div class="ai-tool-item">
                        <span class="tool-emoji">🎬</span>
                        <span class="tool-name">视频编辑</span>
                    </div>
                    <div class="ai-tool-item">
                        <span class="tool-emoji">🌐</span>
                        <span class="tool-name">语言翻译</span>
                    </div>
                    <div class="ai-tool-item">
                        <span class="tool-emoji">🧮</span>
                        <span class="tool-name">代码生成</span>
                    </div>
                </div>
            </div>
        </div>
        
        
    </div>

    <div class="search-panel">
        <h2>🔍 搜索功能</h2>
        
        <div class="search-input-container">
            <input type="text" id="searchInput" placeholder="输入数学公式或函数名称..." autocomplete="off">
            <button id="searchBtn" class="search-submit-btn">搜索</button>
        </div>
        
        <div class="search-options">
            <div class="setting-item">
                <label for="searchCategory"><i>📁</i> 搜索类别</label>
                <select id="searchCategory">
                    <option value="all">全部</option>
                    <option value="functions">数学函数</option>
                    <option value="constants">常数</option>
                    <option value="examples">示例表达式</option>
                    <option value="operations">计算类型</option>
                </select>
            </div>
            
            <div class="setting-item">
                <label for="searchHistory"><i>📜</i> 搜索历史</label>
                <select id="searchHistory">
                    <option value="">-- 选择历史搜索 --</option>
                </select>
            </div>
        </div>
        
        <div class="search-results-container">
            <h3>搜索结果</h3>
            <div id="searchResults" class="search-results">
                <p class="no-results">暂无搜索结果</p>
            </div>
        </div>
        
        <div class="search-actions">
            <button class="preview-button" id="clearSearchBtn">
                🗑️ 清空搜索
            </button>
            <button class="preview-button" id="closeSearchBtn">
                ❌ 关闭面板
            </button>
        </div>
    </div>

    <!-- API配置面板 -->
    <div class="api-panel">
        <h2>🔑 API配置</h2>
        
        <div class="api-config-item">
            <label for="apiUrl">API网址:</label>
            <input type="text" id="apiUrl" value="https://apis.iflow.cn/v1/chat/completions" placeholder="API网址">
        </div>
        <div class="api-config-item">
            <label for="apiKey">API密钥:</label>
            <input type="text" id="apiKey" value="sk-7e78b23bab66db15f31aba020042ef81" placeholder="API密钥">
        </div>
        <div class="api-config-item">
            <label for="apiModel">模型:</label>
            <select id="apiModel">
                <option value="glm-4.6" selected>glm-4.6</option>
                <option value="qwen3-235b-a22b-thinking-2507">qwen3-235b-a22b-thinking-2507</option>
                <option value="qwen3-235b-a22b-instruct">qwen3-235b-a22b-instruct</option>
                <option value="qwen3-235b">qwen3-235b</option>
                <option value="qwen3-32b">qwen3-32b</option>
                <option value="qwen3-max">qwen3-max</option>
                <option value="qwen3-vl-plus">qwen3-vl-plus</option>
                <option value="qwen3-max-preview">qwen3-max-preview</option>
                <option value="tstars2.0">tstars2.0</option>
                <option value="qwen3-coder-plus">qwen3-coder-plus</option>
                <option value="deepseek-v3.2">deepseek-v3.2</option>
                <option value="deepseek-r1">deepseek-r1</option>
                <option value="deepseek-v3">deepseek-v3</option>
                <option value="kimi-k2-0905">kimi-k2-0905</option>
                <option value="kimi-k2">kimi-k2</option>
                <option value="custom">自定义模型</option>
            </select>
            <input type="text" id="customModel" placeholder="输入自定义模型名称" style="display: none; margin-top: 5px; width: 100%;">
        </div>
        <div class="api-config-item">
            <label for="apiTemperature">Temperature:</label>
            <input type="number" id="apiTemperature" value="0.7" min="0" max="2" step="0.1">
        </div>
        <div class="api-config-item">
            <label for="apiMaxTokens">Max Tokens:</label>
            <input type="number" id="apiMaxTokens" value="3000" min="1" max="256000" step="1">
        </div>
        
        <div class="api-config-actions">
            <button class="api-save-btn" id="apiSaveBtn">保存配置</button>
            <button class="api-test-btn" id="apiTestBtn">测试连接</button>
            <button class="api-reset-btn" id="apiResetBtn">关闭API面板</button>
            <button class="api-close-btn" id="apiCloseBtn">关闭</button><!--不能直接删除 要改自己叫AI修改-->
        </div>
    </div>

    <div class="settings-panel">
        <h2>🛠️ 反馈设置</h2>

        <div class="setting-item">
            <label for="soundToggle"><i>🔊</i> 启用声音</label>
            <label class="toggle-switch">
                <input type="checkbox" id="soundToggle" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="setting-item">
            <label for="vibrateToggle"><i>📳</i> 启用震动</label>
            <label class="toggle-switch">
                <input type="checkbox" id="vibrateToggle" checked>
                <span class="slider"></span>
            </label>
        </div>

        <div class="setting-item">
            <label><i>🎶</i> 声音类型</label>
            <select id="soundType">
                <option value="sine:440">纯净电子音 (440Hz)</option>
                <option value="square:880">明亮电子音 (880Hz)</option>
                <option value="sawtooth:110">低沉环境音</option>
                <option value="triangle:220">柔和脉冲音</option>
                <option value="sine:660">温暖中音</option>
                <option value="square:1320">清脆高音</option>
            </select>
        </div>

        <div class="setting-item">
            <label><i>🔊</i> 音量强度</label>
            <div class="range-container">
                <input type="range" class="dynamic-slider" id="volumeControl" min="0" max="100" value="30">
                <span class="range-value" id="volumeValue">30%</span>
            </div>
        </div>

        <div class="setting-item">
            <label><i>⚡</i> 震动模式</label>
            <select id="vibrateMode">
                <option value="short">短促 (50ms)</option>
                <option value="medium">中等 (200ms)</option>
                <option value="long">长久 (500ms)</option>
                <option value="rhythm">节奏 (100/50/100ms)</option>
                <option value="heartbeat">心跳 (100/100/100/300ms)</option>
                <option value="custom">自定义 (200/100/200ms)</option>
            </select>
        </div>

        <div class="setting-item">
            <label><i>📳</i> 震感强度</label>
            <div class="range-container">
                <input type="range" class="dynamic-slider" id="vibrationStrength" min="1" max="10" value="5">
                <span class="range-value" id="vibrationValue">5</span>
            </div>
        </div>

        <div class="preview-buttons-container">
            <button class="preview-button" id="previewVibration">
                📳 预览震动效果
            </button>
            <button class="preview-button" id="previewSound">
                🔊 预览声音效果
            </button>
        </div>
    </div>

    <div class="container">
        <header>
            <!-- 标题已移动到顶部 -->
        </header>

        <div class="calculator">
            <div class="input-section">
                <h2 class="section-title"><i class="fas fa-edit"></i> 输入表达式</h2>

                <div class="input-group">
                    <label for="expression"><i class="fas fa-square-root-alt"></i> 数学表达式</label>
                    <textarea id="expression" placeholder="例如: e + π + √(3)"></textarea>
                </div>

                <div class="input-group">
                    <label for="operation"><i class="fas fa-tasks"></i> 计算类型</label>
                    <select id="operation">
                        <option value="derivative">求导 (d/dx)</option>
                        <option value="integral">积分 (∫ dx)</option>
                        <option value="second_derivative">二阶导数 (d²/dx²)</option>
                        <option value="nth_derivative">n阶导数 (dⁿ/dxⁿ)</option>
                        <option value="simplify" selected>表达式化简</option>
                        <option value="evaluate">表达式求值</option>
                    </select>
                </div>

                <div class="input-group" id="nth-derivative-group" style="display: none;">
                    <label for="nth-order"><i class="fas fa-sort-numeric-up"></i> 导数阶数 (n)</label>
                    <input type="number" id="nth-order" min="1" max="10" value="3">
                </div>

                <div class="input-group" id="variable-group">
                    <label for="variable"><i class="fas fa-font"></i> 变量</label>
                    <input type="text" id="variable" value="x" placeholder="例如: x, y, t...">
                </div>

                <div class="input-group" id="evaluation-inputs" style="display: none;">
                    <label><i class="fas fa-keyboard"></i> 变量赋值</label>
                    <div class="evaluation-input">
                        <div id="variable-inputs">
                            </div>
                        <p style="font-size: 0.9rem; color: #ccc; margin-top: 5px;">为表达式中的变量输入具体数值</p>
                    </div>
                </div>

                <div class="btn-group">
                    <button class="calculate-btn" id="calculate">
                        <i class="fas fa-calculator"></i> 计算
                    </button>
                    <button class="paste-btn" id="paste">
                        <i class="fas fa-paste"></i> 粘贴
                    </button>
                    <button class="clear-btn" id="clear">
                        <i class="fas fa-broom"></i> 清除
                    </button>
                </div>
            </div>

            <div class="output-section">
                <h2 class="section-title"><i class="fas fa-chart-line"></i> 计算结果 </h2>
                <div class="output" id="output">
                    <p style="text-align: center; color: #ccc; padding: 30px;">
                        计算结果将显示在这里...
                    </p>
                </div>

                <div class="steps" id="steps">
                    </div>
            </div>
        </div>

        <div class="example-section">
            <h2 class="section-title"><i class="fas fa-lightbulb"></i> 示例表达式</h2>
            <p>点击以下示例快速尝试计算器功能：</p>

            <div class="examples">
                <div class="example" data-expr="e + π + √(3)">
                    <div class="example-title">常数项数值合并/符号保留测试</div>
                    <div class="example-expression">e + π + √(3)</div>
                </div>

                <div class="example" data-expr="(x+y)^3">
                    <div class="example-title">多项式展开/积分</div>
                    <div class="example-expression">(x+y)^3</div>
                </div>

                <div class="example" data-expr="425+163+225+60+24+25+50+51+495+24*x+40+98+570+91+112+190+15*x+271+110+119+200+165+240+100+435+415+920+405+104+269+640+133+124+120+133+227+207+354+240+240+128+261+60+144+129+169+88+700+519+94+637+466+613+475+15">
                    <div class="example-title">积分/求导优化测试 (长表达式)</div>
                    <div class="example-expression">425+163+...+15*x+...+15</div>
                </div>

                <div class="example" data-expr="exp(x) * log(x)">
                    <div class="example-title">非初等函数积分 (e^x ln(x))</div>
                    <div class="example-expression">exp(x) * log(x)</div>
                </div>

                <div class="example" data-expr="tan(π/2) + x + 1/x">
                    <div class="example-title">化简/求值 无穷大测试</div>
                    <div class="example-expression">tan(π/2) + x + 1/x</div>
                </div>

                <div class="example" data-expr="ln(x) + cos(0)">
                    <div class="example-title">化简/求值 0点对数测试</div>
                    <div class="example-expression">ln(x) + cos(0)</div>
                </div>

                <div class="example" data-expr="x^4 + 3*x^2 - 6*x + x + 1">
                    <div class="example-title">多项式求导</div>
                    <div class="example-expression">x^4 + 3*x^2 - 6*x + x + 1</div>
                </div>

                <div class="example" data-expr="log3(27) + log5(1) + log(x) + π/2">
                    <div class="example-title">任意底对数 + π 显示测试</div>
                    <div class="example-expression">log3(27) + log5(1) + log(x) + π/2</div>
                </div>
            </div>
        </div>

        <div class="function-reference">
            <h2 class="section-title"><i class="fas fa-book"></i> 支持的函数与符号</h2>

            <div class="function-categories">
                <div class="function-category">
                    <div class="category-title">基本运算</div>
                    <ul class="function-list">
                        <li>+ (加法)</li>
                        <li>- (减法)</li>
                        <li>* (乘法)</li>
                        <li>^ (幂运算)</li>
                        <li>() (括号)</li>
                        <li>sqrt(x) - 平方根 ($\sqrt{x}$) <i class="fas fa-check-circle"></i></li>
                    </ul>
                </div>

                <div class="function-category">
                    <div class="category-title">三角函数</div>
                    <ul class="function-list">
                        <li>sin(x) - 正弦</li>
                        <li>cos(x) - 余弦</li>
                        <li>tan(x) - 正切</li>
                        <li>cot(x) - 余切</li>
                        <li>sec(x) - 正割</li>
                        <li>csc(x) - 余割</li>
                        <li>asin(x) - 反正弦</li>
                        <li>acos(x) - 反余弦</li>
                        <li>atan(x) - 反正切</li>
                    </ul>
                </div>

                <div class="function-category">
                    <div class="category-title">双曲函数</div>
                    <ul class="function-list">
                        <li>sinh(x) - 双曲正弦</li>
                        <li>cosh(x) - 双曲余弦</li>
                        <li>tanh(x) - 双曲正切</li>
                        <li>asinh(x) - 反双曲正弦</li>
                        <li>acosh(x) - 反双曲余弦</li>
                        <li>atanh(x) - 反双曲正切</li>
                    </ul>
                </div>

                <div class="function-category">
                    <div class="category-title">指数与对数 <i class="fas fa-magic"></i></div>
                    <ul class="function-list">
                        <li>exp(x) - 指数函数 ($e^x$)</li>
                        <li>log(x) 或 ln(x) - **自然对数** ($\ln(x)$)</li>
                        <li>log10(x) 或 lg(x) - **以10为底**对数 ($\lg(x)$)</li>
                        <li>logN(v) (例如 log3(5)) - **任意底**对数 ($\log_N(v)$) <i class="fas fa-check-circle"></i></li>
                    </ul>
                </div>

                <div class="function-category">
                    <div class="category-title">特殊函数与积分</div>
                    <ul class="function-list">
                        <li>abs(x) - 绝对值</li>
                        <li>factorial(n) - 阶乘</li>
                        <li>gamma(x) - 伽马函数</li>
                        <li>∫(e^x/x)dx - 指数积分 (非初等函数) <i class="fas fa-check-circle"></i></li>
                    </ul>
                </div>

                <div class="function-category">
                    <div class="category-title">常数</div>
                    <ul class="function-list">
                        <li>pi - 圆周率 $\pi$ <i class="fas fa-check-circle"></i></li>
                        <li>e - 自然常数</li>
                        <li>i - 虚数单位</li>
                        <li>inf - 无穷大</li>
                    </ul>
                </div>
            </div>
        </div>

        <footer>
            <p>专业数学计算器 ProMax &copy; 2025</p>
        </footer>
    </div>

    <script>
        // 极致性能优化：使用单例模式和高效缓存
        const App = {
            // 性能监控
            performance: {
                startTime: performance.now(),
                measure: function(name) {
                    return performance.now() - this.startTime;
                }
            },

            // 全局缓存系统
            cache: {
                dom: new Map(),
                results: new Map(),
                calculations: new Map(),
                maxSize: 100,
                
                get(key) {
                    const value = this.results.get(key);
                    if (value) {
                        // LRU: 移动到最后
                        this.results.delete(key);
                        this.results.set(key, value);
                    }
                    return value;
                },
                
                set(key, value) {
                    if (this.results.size >= this.maxSize) {
                        // 删除最旧的项
                        const firstKey = this.results.keys().next().value;
                        this.results.delete(firstKey);
                    }
                    this.results.set(key, value);
                },
                
                clear() {
                    this.results.clear();
                }
            },

            // DOM元素缓存
            elements: {},
            
            // 声音控制变量
            audio: {
                context: null,
                oscillator: null,
                gainNode: null,
                isPlaying: false,
                
                init() {
                    if (!this.context) {
                        this.context = new (window.AudioContext || window.webkitAudioContext)();
                        this.gainNode = this.context.createGain();
                        this.gainNode.connect(this.context.destination);
                        this.gainNode.gain.value = 0.06; // 初始音量降低
                    }
                    return this.context;
                },
                
                play(type, freq, duration = 0.3) {
                    if (!App.elements.soundToggle.checked) return;
                    
                    const audioCtx = this.init();
                    
                    if (this.isPlaying && this.oscillator) {
                        this.oscillator.stop();
                    }
                    
                    this.oscillator = audioCtx.createOscillator();
                    this.oscillator.connect(this.gainNode);
                    this.oscillator.type = type;
                    this.oscillator.frequency.setValueAtTime(parseFloat(freq), audioCtx.currentTime);
                    this.oscillator.start(0);
                    this.oscillator.stop(audioCtx.currentTime + duration);
                    this.isPlaying = true;
                    
                    setTimeout(() => {
                        this.isPlaying = false;
                    }, duration * 1000);
                }
            },

            // 振动控制
            vibration: {
                patterns: {
                    'short': 50,
                    'medium': 200,
                    'long': 500,
                    'rhythm': [100, 50, 100],
                    'heartbeat': [100, 100, 100, 300],
                    'custom': [200, 100, 200]
                },
                
                trigger(patternName) {
                    if (!App.elements.vibrateToggle.checked || !navigator.vibrate) return;
                    
                    const pattern = this.patterns[patternName];
                    const strength = parseInt(App.elements.vibrationStrength.value);
                    let adjustedPattern;
                    
                    if (Array.isArray(pattern)) {
                        adjustedPattern = pattern.map(val => Math.min(val * strength / 5, 1000));
                    } else {
                        adjustedPattern = Math.min(pattern * strength / 5, 1000);
                    }
                    
                    navigator.vibrate(adjustedPattern);
                }
            },

            // 搜索数据库
            searchData: {
                functions: [
                    { name: 'sin', description: '正弦函数', example: 'sin(x)', category: 'functions' },
                    { name: 'cos', description: '余弦函数', example: 'cos(x)', category: 'functions' },
                    { name: 'tan', description: '正切函数', example: 'tan(x)', category: 'functions' },
                    { name: 'log', description: '对数函数', example: 'log(x)', category: 'functions' },
                    { name: 'ln', description: '自然对数', example: 'ln(x)', category: 'functions' },
                    { name: 'sqrt', description: '平方根', example: 'sqrt(x)', category: 'functions' },
                    { name: 'exp', description: '指数函数', example: 'exp(x)', category: 'functions' },
                    { name: 'abs', description: '绝对值', example: 'abs(x)', category: 'functions' },
                    { name: 'derivative', description: '求导', example: 'derivative(x^2)', category: 'operations' },
                    { name: 'integral', description: '积分', example: 'integral(x^2)', category: 'operations' }
                ],
                constants: [
                    { name: 'pi', description: '圆周率 π', example: 'pi', category: 'constants' },
                    { name: 'e', description: '自然常数', example: 'e', category: 'constants' },
                    { name: 'i', description: '虚数单位', example: 'i', category: 'constants' }
                ],
                examples: [
                    { name: '二次函数求导', description: 'x² 的导数', example: 'derivative(x^2)', category: 'examples' },
                    { name: '三角函数积分', description: 'sin(x) 的积分', example: 'integral(sin(x))', category: 'examples' },
                    { name: '复合函数', description: 'e^x + ln(x)', example: 'exp(x) + ln(x)', category: 'examples' },
                    { name: '平方根计算', description: '√(x² + 1)', example: 'sqrt(x^2 + 1)', category: 'examples' }
                ]
            },

            // 搜索历史
            searchHistory: JSON.parse(localStorage.getItem('searchHistory') || '[]'),

            // 聊天位置跟踪
            chatTracking: {
                lastExpandedMessage: null,
                trackExpandedMessage: function(messageElement) {
                    // 记录展开/折叠的消息元素
                    this.lastExpandedMessage = messageElement;
                },
                returnToPosition: function() {
                    if (this.lastExpandedMessage) {
                        // 获取消息元素的位置
                        let targetElement = this.lastExpandedMessage;
                        
                        // 如果记录的是AI消息，尝试找到其中的思考过程容器
                        if (targetElement.classList.contains('ai-message')) {
                            const reasoningContainer = targetElement.querySelector('.reasoning-container');
                            if (reasoningContainer) {
                                targetElement = reasoningContainer;
                            }
                        }
                        
                        const messageRect = targetElement.getBoundingClientRect();
                        const chatMessages = App.elements.chatMessages;
                        const chatRect = chatMessages.getBoundingClientRect();
                        
                        // 计算消息相对于聊天容器的位置
                        const relativeTop = messageRect.top - chatRect.top + chatMessages.scrollTop;
                        
                        // 平滑滚动到消息位置
                        chatMessages.scrollTo({
                            top: relativeTop - 50, // 稍微向上偏移，确保消息完全可见
                            behavior: 'smooth'
                        });
                        
                        // 添加视觉反馈
                        this.addVisualFeedback(targetElement);
                    } else {
                        // 如果没有记录的位置，显示提示
                        App.calculator.showSuccessMessage('没有记录的回展位置，请先点击思考过程的回展按钮');
                    }
                },
                addVisualFeedback: function(messageElement) {
                    // 为消息元素添加临时高亮效果
                    const originalBorder = messageElement.style.border;
                    const originalBoxShadow = messageElement.style.boxShadow;
                    
                    messageElement.style.border = '2px solid rgba(241, 196, 15, 0.8)';
                    messageElement.style.boxShadow = '0 0 15px rgba(241, 196, 15, 0.6)';
                    messageElement.style.transition = 'border 0.3s, box-shadow 0.3s';
                    
                    // 2秒后恢复原始样式
                    setTimeout(() => {
                        messageElement.style.border = originalBorder;
                        messageElement.style.boxShadow = originalBoxShadow;
                    }, 2000);
                }
            },

            // API配置管理
            apiConfig: {
                defaultConfig: {
                    url: 'https://apis.iflow.cn/v1/chat/completions',
                    key: 'sk-7e78b23bab66db15f31aba020042ef81',
                    model: 'glm-4.6',
                    temperature: 0.7,
                    maxTokens: 1000
                },
                
                connectionStatus: false,
                
                getConfig() {
                    const savedConfig = localStorage.getItem('apiConfig');
                    if (savedConfig) {
                        try {
                            return JSON.parse(savedConfig);
                        } catch (e) {
                            console.error('解析API配置失败:', e);
                            return { ...this.defaultConfig };
                        }
                    }
                    return { ...this.defaultConfig };
                },
                
                saveConfig(config) {
                    try {
                        localStorage.setItem('apiConfig', JSON.stringify(config));
                        return true;
                    } catch (e) {
                        console.error('保存API配置失败:', e);
                        return false;
                    }
                },
                
                resetToDefault() {
                    this.saveConfig(this.defaultConfig);
                    return this.defaultConfig;
                },
                
                // 测试API连接
                async testConnection(config) {
                    try {
                        console.log('测试API连接:', config.url);
                        
                        const response = await fetch(config.url, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${config.key}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                model: config.model,
                                messages: [
                                    { role: 'user', content: '你好，这是一个连接测试' }
                                ],
                                temperature: parseFloat(config.temperature),
                                max_tokens: 10
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP错误: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        if (data.choices && data.choices.length > 0) {
                            this.connectionStatus = true;
                            return { success: true, message: '连接成功' };
                        } else {
                            throw new Error('API返回数据格式错误');
                        }
                    } catch (error) {
                        this.connectionStatus = false;
                        throw error;
                    }
                },
                
                async callAPI(messages) {
                    const config = this.getConfig();
                    
                    try {
                        console.log('=== AIOS API调用开始 (非流式) ===');
                        console.log('API URL:', config.url);
                        console.log('使用模型:', config.model);
                        console.log('Temperature:', config.temperature);
                        console.log('Max Tokens:', config.maxTokens);
                        
                        // 处理消息格式：如果是字符串，转换为标准格式；如果是数组，直接使用
                        let messagesArray;
                        if (typeof messages === 'string') {
                            messagesArray = [
                                { role: 'user', content: messages }
                            ];
                            console.log('发送消息:', messages);
                        } else if (Array.isArray(messages)) {
                            messagesArray = messages;
                            console.log('发送消息数组:', JSON.stringify(messages, null, 2));
                        } else {
                            throw new Error('消息格式错误，应该是字符串或数组');
                        }
                        
                        const requestBody = {
                            model: config.model,
                            messages: messagesArray,
                            temperature: parseFloat(config.temperature),
                            max_tokens: parseInt(config.maxTokens)
                        };
                        
                        console.log('请求体:', JSON.stringify(requestBody, null, 2));
                        
                        // 使用fetch发送请求
                        const response = await fetch(config.url, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${config.key}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(requestBody)
                        });
                        
                        console.log('API响应状态:', response.status, response.statusText);
                        
                        const data = await response.json();
                        console.log('API响应数据:', JSON.stringify(data, null, 2));
                        
                        if (data.choices && data.choices.length > 0 && data.choices[0].message) {
                            console.log('API调用成功，返回内容:', data.choices[0].message.content);
                            console.log('=== AIOS API调用结束 (非流式) ===');
                            return data.choices[0].message.content;
                        } else {
                            console.error('API返回数据格式:', JSON.stringify(data, null, 2));
                            // 检查特定错误并返回友好提示
                            if (data.status === "435" && data.msg === "Model not support") {
                                const availableModels = 'glm-4.6, qwen3-235b-a22b-thinking-2507, qwen3-235b-a22b-instruct, qwen3-235b, qwen3-32b, qwen3-max, qwen3-vl-plus, qwen3-max-preview, tstars2.0, qwen3-coder-plus, deepseek-v3.2, deepseek-r1, deepseek-v3, kimi-k2-0905, kimi-k2';
                                const error = new Error(`当前模型不被支持，请尝试更换为以下可用模型之一：${availableModels}`);
                                console.error('模型不支持错误:', error);
                                console.log('=== AIOS API调用结束 (非流式) ===');
                                throw error;
                            } else {
                                // 提供更详细的错误信息
                                const errorMsg = `API返回数据格式错误。状态码: ${response.status}, 返回数据: ${JSON.stringify(data)}`;
                                const error = new Error(errorMsg);
                                console.error('数据格式错误:', error);
                                console.log('=== AIOS API调用结束 (非流式) ===');
                                throw error;
                            }
                        }
                    } catch (error) {
                        console.error('API调用错误:', error);
                        console.error('错误详情:', {
                            name: error.name,
                            message: error.message,
                            stack: error.stack
                        });
                        console.log('=== AIOS API调用结束 (非流式) ===');
                        throw error;
                    }
                },
                
                // 新增流式API调用方法
                async callStreamAPI(messages, onChunk, abortController) {
                    const config = this.getConfig();
                    
                    // 初始化流式缓冲区
                    this.streamBuffer = '';
                    let requestActive = true; // 添加请求状态标志
                    let reader = null; // 保存reader引用以便取消
                    let response = null; // 保存响应对象
                    
                    // 创建取消处理函数
                    const handleAbort = () => {
                        console.log('收到取消请求，正在停止...');
                        requestActive = false;
                        
                        // 取消reader
                        if (reader) {
                            try {
                                reader.cancel('用户停止生成').catch(e => {
                                    console.log('取消reader时的预期错误:', e);
                                });
                            } catch (e) {
                                console.log('取消reader时出错:', e);
                            }
                        }
                        
                        // 取消fetch请求
                        if (abortController) {
                            try {
                                abortController.abort('用户停止生成');
                            } catch (e) {
                                console.log('取消请求时出错:', e);
                            }
                        }
                    };
                    
                    // 监听取消信号
                    if (abortController.signal.aborted) {
                        console.log('请求在开始前已被取消');
                        return;
                    }
                    
                    abortController.signal.addEventListener('abort', handleAbort);
                    
                    try {
                        console.log('=== AIOS API调用开始 ===');
                        console.log('API URL:', config.url);
                        console.log('使用模型:', config.model);
                        console.log('Temperature:', config.temperature);
                        console.log('Max Tokens:', config.maxTokens);
                        
                        // 处理消息格式：如果是字符串，转换为标准格式；如果是数组，直接使用
                        let messagesArray;
                        if (typeof messages === 'string') {
                            messagesArray = [
                                { role: 'user', content: messages }
                            ];
                            console.log('发送消息:', messages);
                        } else if (Array.isArray(messages)) {
                            messagesArray = messages;
                            console.log('发送消息数组:', JSON.stringify(messages, null, 2));
                        } else {
                            throw new Error('消息格式错误，应该是字符串或数组');
                        }
                        
                        const requestBody = {
                            model: config.model,
                            messages: messagesArray,
                            temperature: parseFloat(config.temperature),
                            max_tokens: parseInt(config.maxTokens),
                            stream: true  // 启用流式输出
                        };
                        
                        console.log('请求体:', JSON.stringify(requestBody, null, 2));
                        
                        // 使用fetch发送流式请求
                        const response = await fetch(config.url, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${config.key}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(requestBody),
                            signal: abortController.signal
                        });
                        
                        // 检查请求是否已被取消
                        if (abortController.signal.aborted) {
                            console.log('请求在发送后但处理响应前被取消');
                            throw new DOMException('请求被取消', 'AbortError');
                        }
                        
                        console.log('响应状态:', response.status, response.statusText);
                        
                        if (!response.ok) {
                            console.error('API请求失败，状态码:', response.status);
                            throw new Error(`API请求失败，状态码: ${response.status}`);
                        }
                        
                        console.log('开始处理流式响应...');
                        
                        // 处理流式响应
                        reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let chunkCount = 0;
                        
                        while (requestActive && !abortController.signal.aborted) {
                            try {
                                // 检查是否已被取消
                                if (abortController.signal.aborted) {
                                    console.log('检测到取消信号，停止读取数据');
                                    break;
                                }
                                
                                const { done, value } = await reader.read();
                                if (done) {
                                    console.log('流式响应完成，总共接收到', chunkCount, '个数据块');
                                    break;
                                }
                                
                                // 再次检查是否已被取消
                                if (abortController.signal.aborted) {
                                    console.log('读取数据后检测到取消信号');
                                    break;
                                }
                                
                                // 解码数据块
                                const chunk = decoder.decode(value, { stream: true });
                                chunkCount++;
                                
                                console.log(`--- 数据块 #${chunkCount} ---`);
                                console.log('原始数据长度:', chunk.length);
                                
                                // 处理可能不完整的JSON数据
                                let buffer = (this.streamBuffer || '') + chunk;
                                let processedLines = [];
                                
                                // 简化的解析方法：直接按data:分割
                                const dataSections = buffer.split(/data:\s*/);
                                
                                for (let i = 0; i < dataSections.length && requestActive && !abortController.signal.aborted; i++) {
                                    const section = dataSections[i].trim();
                                    if (!section) continue;
                                    
                                    if (section === '[DONE]') {
                                        console.log('收到流式结束标记 [DONE]');
                                        requestActive = false;
                                        return;
                                    }
                                    
                                    // 尝试找到完整的JSON字符串
                                    let jsonStr = '';
                                    let braceCount = 0;
                                    let inString = false;
                                    let escapeNext = false;
                                    
                                    for (let j = 0; j < section.length; j++) {
                                        const char = section[j];
                                        
                                        if (escapeNext) {
                                            escapeNext = false;
                                            jsonStr += char;
                                            continue;
                                        }
                                        
                                        if (char === '\\') {
                                            escapeNext = true;
                                            jsonStr += char;
                                            continue;
                                        }
                                        
                                        if (char === '"' && !escapeNext) {
                                            inString = !inString;
                                            jsonStr += char;
                                            continue;
                                        }
                                        
                                        if (!inString) {
                                            if (char === '{') {
                                                braceCount++;
                                            } else if (char === '}') {
                                                braceCount--;
                                            }
                                        }
                                        
                                        jsonStr += char;
                                        
                                        if (braceCount === 0 && jsonStr.startsWith('{')) {
                                            break;
                                        }
                                    }
                                    
                                    if (jsonStr && jsonStr.startsWith('{') && braceCount === 0) {
                                        try {
                                            const data = JSON.parse(jsonStr);
                                            processedLines.push(data);
                                        } catch (e) {
                                            console.error('解析JSON失败:', e);
                                        }
                                    }
                                }
                                
                                // 检查是否有未处理的数据（可能是不完整的JSON）
                                const lastSection = dataSections[dataSections.length - 1];
                                const hasIncompleteJson = lastSection && !lastSection.includes('}') && lastSection.trim();
                                
                                if (hasIncompleteJson) {
                                    // 如果缓冲区还有不完整的数据，保存到下一次处理
                                    this.streamBuffer = lastSection;
                                } else {
                                    this.streamBuffer = '';
                                }
                                
                                // 处理解析成功的数据
                                for (const data of processedLines) {
                                    // 再次检查是否已被取消
                                    if (abortController.signal.aborted) {
                                        console.log('处理数据前检测到取消信号');
                                        requestActive = false;
                                        return;
                                    }
                                    
                                    const delta = data.choices?.[0]?.delta;
                                    
                                    // 分别处理 content 和 reasoning_content
                                    if (delta?.content && delta.content.trim()) {
                                        // 调用回调函数处理正常内容
                                        onChunk(delta.content, 'content');
                                    }
                                    
                                    if (delta?.reasoning_content && delta.reasoning_content.trim()) {
                                        // 调用回调函数处理思考过程
                                        onChunk(delta.reasoning_content, 'reasoning');
                                    }
                                    
                                    // 检查是否完成
                                    if (data.choices?.[0]?.finish_reason) {
                                        console.log('流式响应完成原因:', data.choices[0].finish_reason);
                                        requestActive = false;
                                        return;
                                    }
                                }
                            } catch (readError) {
                                if (readError.name === 'AbortError' || abortController.signal.aborted) {
                                    console.log('读取数据时检测到取消信号');
                                    requestActive = false;
                                    break;
                                } else {
                                    throw readError;
                                }
                            }
                        }
                        
                        // 确保请求状态被正确设置
                        requestActive = false;
                        
                    } catch (error) {
                        console.log('=== AIOS API调用结束 ===');
                        requestActive = false;
                        
                        // 移除事件监听器
                        abortController.signal.removeEventListener('abort', handleAbort);
                        
                        if (error.name === 'AbortError' || abortController.signal.aborted) {
                            console.log('API请求已被取消');
                            // 不抛出错误，让调用方处理取消
                            return;
                        } else {
                            console.error('流式API调用错误:', error);
                            console.error('错误详情:', {
                                name: error.name,
                                message: error.message,
                                stack: error.stack
                            });
                            throw error;
                        }
                    } finally {
                        // 移除事件监听器
                        abortController.signal.removeEventListener('abort', handleAbort);
                    }
                }
            },

            // 优化后的计算器核心
            calculator: {
                tolerance: 1e-10,
                
                init() {
                    this.cacheDOM();
                    this.bindEvents();
                    this.setupPasteHandler();
                    this.handleOperationChange();
                },
                
                cacheDOM() {
                    App.elements = {
                        // 设置面板元素
                        settingsButton: document.querySelector('.settings-button'),
                        searchButton: document.querySelector('.search-button'),
                        aiosButton: document.querySelector('.aios-button'),
                        settingsPanel: document.querySelector('.settings-panel'),
                        searchPanel: document.querySelector('.search-panel'),
                        aiosPanel: document.querySelector('.aios-panel'),
                        soundToggle: document.getElementById('soundToggle'),
                        vibrateToggle: document.getElementById('vibrateToggle'),
                        soundType: document.getElementById('soundType'),
                        vibrateMode: document.getElementById('vibrateMode'),
                        volumeControl: document.getElementById('volumeControl'),
                        volumeValue: document.getElementById('volumeValue'),
                        vibrationStrength: document.getElementById('vibrationStrength'),
                        vibrationValue: document.getElementById('vibrationValue'),
                        previewVibrationBtn: document.getElementById('previewVibration'),
                        previewSoundBtn: document.getElementById('previewSound'),
                        
                        // 搜索元素
                        searchInput: document.getElementById('searchInput'),
                        searchBtn: document.getElementById('searchBtn'),
                        searchCategory: document.getElementById('searchCategory'),
                        searchHistory: document.getElementById('searchHistory'),
                        searchResults: document.getElementById('searchResults'),
                        clearSearchBtn: document.getElementById('clearSearchBtn'),
                        closeSearchBtn: document.getElementById('closeSearchBtn'),
                        
                        // AIOS元素
                        chatInput: document.getElementById('chatInput'),
                        sendBtn: document.getElementById('sendBtn'),
                        chatMessages: document.getElementById('chatMessages'),
                        voiceBtn: document.getElementById('voiceBtn'),
                        closeAiosBtn: document.getElementById('closeAiosBtn'),
                        
                        // API配置元素
                        apiConfigBtn: document.getElementById('apiConfigBtn'),
                        apiPanel: document.querySelector('.api-panel'),
                        apiCloseBtn: document.getElementById('apiCloseBtn'),
                        apiUrl: document.getElementById('apiUrl'),
                        apiKey: document.getElementById('apiKey'),
                        apiModel: document.getElementById('apiModel'),
                        customModel: document.getElementById('customModel'),
                        apiTemperature: document.getElementById('apiTemperature'),
                        apiMaxTokens: document.getElementById('apiMaxTokens'),
                        apiSaveBtn: document.getElementById('apiSaveBtn'),
                        apiTestBtn: document.getElementById('apiTestBtn'),
                        apiResetBtn: document.getElementById('apiResetBtn'),
                        
                        // 新增元素
                        closeAiosLeftBtn: document.getElementById('closeAiosLeftBtn'),
                        closeAiosRightBtn: document.getElementById('closeAiosRightBtn'),
                        chatTopBtn: document.getElementById('chatTopBtn'),
                        chatBottomBtn: document.getElementById('chatBottomBtn'),
                        chatTrackBtn: document.getElementById('chatTrackBtn'),
                        chatClearBtn: document.getElementById('chatClearBtn'),
                        
                        // 计算器元素
                        expressionInput: document.getElementById('expression'),
                        operationSelect: document.getElementById('operation'),
                        variableInput: document.getElementById('variable'),
                        variableGroup: document.getElementById('variable-group'),
                        nthDerivativeGroup: document.getElementById('nth-derivative-group'),
                        nthOrderInput: document.getElementById('nth-order'),
                        evaluationInputs: document.getElementById('evaluation-inputs'),
                        variableInputs: document.getElementById('variable-inputs'),
                        calculateBtn: document.getElementById('calculate'),
                        pasteBtn: document.getElementById('paste'),
                        clearBtn: document.getElementById('clear'),
                        outputDiv: document.getElementById('output'),
                        stepsDiv: document.getElementById('steps'),
                        examples: document.querySelectorAll('.example')
                    };
                },
                
                bindEvents() {
                    const { operationSelect, calculateBtn, clearBtn, examples, expressionInput } = App.elements;
                    
                    // 使用防抖优化输入事件
                    const debouncedUpdateVariableInputs = this.debounce(() => {
                        if (operationSelect.value === 'evaluate') {
                            this.updateVariableInputs();
                        }
                    }, 300);
                    
                    operationSelect.addEventListener('change', () => this.handleOperationChange());
                    calculateBtn.addEventListener('click', () => this.handleCalculate());
                    clearBtn.addEventListener('click', () => this.handleClear());
                    
                    examples.forEach(example => {
                        example.addEventListener('click', (e) => {
                            const expression = e.currentTarget.getAttribute('data-expr');
                            expressionInput.value = expression;
                            if (operationSelect.value === 'evaluate') {
                                this.updateVariableInputs();
                            }
                        });
                    });
                    
                    expressionInput.addEventListener('input', debouncedUpdateVariableInputs);
                },
                
                // 防抖函数
                debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                },
                
                setupPasteHandler() {
                    const { pasteBtn, expressionInput } = App.elements;
                    
                    pasteBtn.addEventListener('click', async () => {
                        try {
                            if (navigator.clipboard && navigator.clipboard.readText) {
                                const pastedText = await navigator.clipboard.readText();
                                if (pastedText) {
                                    expressionInput.value = pastedText;
                                    if (App.elements.operationSelect.value === 'evaluate') {
                                        this.updateVariableInputs();
                                    }
                                    this.showSuccessMessage('内容已粘贴！');
                                    return;
                                }
                            }
                            
                            const tempTextarea = document.createElement('textarea');
                            tempTextarea.style.position = 'fixed';
                            tempTextarea.style.left = '0';
                            tempTextarea.style.top = '0';
                            tempTextarea.style.opacity = '0';
                            document.body.appendChild(tempTextarea);
                            tempTextarea.focus();
                            
                            setTimeout(() => {
                                if (tempTextarea.value) {
                                    expressionInput.value = tempTextarea.value;
                                    if (App.elements.operationSelect.value === 'evaluate') {
                                        this.updateVariableInputs();
                                    }
                                    this.showSuccessMessage('内容已粘贴！');
                                } else {
                                    this.showSuccessMessage('请手动在输入框中粘贴内容 (Ctrl+V)');
                                    expressionInput.focus();
                                }
                                document.body.removeChild(tempTextarea);
                            }, 100);
                            
                        } catch (error) {
                            this.showSuccessMessage('请手动在输入框中粘贴内容 (Ctrl+V)');
                            expressionInput.focus();
                        }
                    });
                },
                
                handleOperationChange() {
                    const { operationSelect, nthDerivativeGroup, evaluationInputs, variableGroup } = App.elements;
                    
                    if (operationSelect.value === 'nth_derivative') {
                        nthDerivativeGroup.style.display = 'block';
                        evaluationInputs.style.display = 'none';
                        variableGroup.style.display = 'block';
                    } else if (operationSelect.value === 'evaluate') {
                        nthDerivativeGroup.style.display = 'none';
                        evaluationInputs.style.display = 'block';
                        variableGroup.style.display = 'block';
                        this.updateVariableInputs();
                    } else if (operationSelect.value === 'simplify') {
                        nthDerivativeGroup.style.display = 'none';
                        evaluationInputs.style.display = 'none';
                        variableGroup.style.display = 'none';
                    } else {
                        nthDerivativeGroup.style.display = 'none';
                        evaluationInputs.style.display = 'none';
                        variableGroup.style.display = 'block';
                    }
                },
                
                updateVariableInputs() {
                    const { expressionInput, variableInputs } = App.elements;
                    const expression = expressionInput.value.trim();
                    
                    if (!expression) {
                        variableInputs.innerHTML = '';
                        return;
                    }
                    
                    const cacheKey = `variables_${expression}`;
                    const cachedHTML = App.cache.get(cacheKey);
                    if (cachedHTML) {
                        variableInputs.innerHTML = cachedHTML;
                        return;
                    }
                    
                    try {
                        const node = math.parse(expression);
                        const variables = this.extractVariables(node);
                        
                        let html = '';
                        variables.forEach(variable => {
                            html += `
                                <div>
                                    <label for="var-${variable}">${variable} = </label>
                                    <input type="number" id="var-${variable}" value="1" step="any">
                                </div>
                            `;
                        });
                        
                        variableInputs.innerHTML = html;
                        App.cache.set(cacheKey, html);
                        
                    } catch (error) {
                        variableInputs.innerHTML = '<p style="color: #e74c3c;">无法解析表达式</p>';
                    }
                },
                
                extractVariables(node) {
                    const variables = new Set();
                    
                    const traverse = (node) => {
                        if (node.type === 'SymbolNode') {
                            if (!['pi', 'e', 'i'].includes(node.name)) {
                                variables.add(node.name);
                            }
                        } else if (node.type === 'FunctionNode') {
                            node.args.forEach(traverse);
                        } else if (node.type === 'OperatorNode') {
                            node.args.forEach(traverse);
                        } else if (node.type === 'ParenthesisNode') {
                            traverse(node.content);
                        }
                    };
                    
                    traverse(node);
                    return Array.from(variables);
                },
                
                handleCalculate() {
                    const { expressionInput, operationSelect, variableInput, nthOrderInput, outputDiv, stepsDiv } = App.elements;
                    const expression = expressionInput.value.trim();
                    const operation = operationSelect.value;
                    const variable = variableInput.value.trim() || 'x';
                    const nthOrder = nthOrderInput.value;
                    
                    if (!expression) {
                        alert('请输入数学表达式！');
                        return;
                    }
                    
                    stepsDiv.innerHTML = '';
                    outputDiv.innerHTML = '';
                    
                    try {
                        const cacheKey = `${operation}_${expression}_${variable}_${nthOrder}`;
                        const cachedResult = App.cache.get(cacheKey);
                        if (cachedResult) {
                            this.displayResult(cachedResult);
                            return;
                        }
                        
                        const processedExpression = this.preprocessExpression(expression);
                        const result = this.calculate(processedExpression, operation, variable, nthOrder);
                        App.cache.set(cacheKey, result);
                        this.displayResult(result);
                        
                    } catch (error) {
                        this.displayError(error.message, expression);
                    }
                },
                
                preprocessExpression(expr) {
                    let processed = expr;
                    
                    // 处理√符号
                    processed = processed.replace(/√\s*\(([^)]+)\)/g, 'sqrt($1)');
                    processed = processed.replace(/√\s*([a-zA-Z0-9.]+)/g, 'sqrt($1)');
                    
                    // 处理角度符号
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*\(\s*(\d*\.?\d+)\s*°\s*\)/g, '$1($2*pi/180)');
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*(\d*\.?\d+)\s*°/g, '$1($2*pi/180)');
                    
                    // 处理π
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*\(\s*π\s*\)/g, '$1(3.141592653589793)');
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*\(\s*e\s*\)/g, '$1(2.718281828459045)');
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*\(\s*pi\s*\)/g, '$1(3.141592653589793)');
                    
                    // 处理其他π表达式
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*\(\s*(\d*\.?\d*)\s*\*\s*π\s*\)/g, '$1($2*3.141592653589793)');
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*\(\s*(\d*\.?\d*)\s*π\s*\)/g, '$1($2*3.141592653589793)');
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*\(\s*π\s*\/\s*(\d+)\s*\)/g, '$1(3.141592653589793/$2)');
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*\(\s*(\d+)\s*\*\s*π\s*\/\s*(\d+)\s*\)/g, '$1($2*3.141592653589793/$3)');
                    
                    // 处理不带括号的情况
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*(\d*\.?\d*)π/g, (match, func, num) => {
                        const number = num === '' ? '1' : num;
                        return `${func}(${number}*3.141592653589793)`;
                    });
                    
                    processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan)\s*(\d*\.?\d+)(?!\w)/g, '$1($2)');
                    
                    // 处理反三角函数
                    processed = processed.replace(/arc(sin|cos|tan)/g, 'a$1');
                    
                    // 任意底对数支持 logN(v) -> log(v, N)
                    processed = processed.replace(/\blog([0-9]+)\s*\(([^)]+)\)/g, 'log($2, $1)');

                    // 处理对数无括号支持 (仅对 ln, lg)
                    processed = this.processLogarithmWithoutParentheses(processed);
                    
                    // 将 ln(x) 替换为 math.js 的 log(x) (自然对数)
                    processed = processed.replace(/ln\(/g, 'log('); 
                    
                    // 将 lg(x) 替换为 math.js 的 log10(x) (以10为底)
                    processed = processed.replace(/lg\(/g, 'log10('); 
                    
                    return processed;
                },
                
                processLogarithmWithoutParentheses(expr) {
                    let processed = expr;
                    
                    const logPatterns = [
                        { regex: /(ln|lg)\s*([0-9]+(?:\.[0-9]+)?)(?=\W|$)/g, handler: this.processSimpleNumberLog },
                        { regex: /(ln|lg)\s*([a-zA-Zπ]+)(?=\W|$)/g, handler: this.processSimpleSymbolLog },
                        { regex: /(ln|lg)\s*([0-9]+(?:\.[0-9]+)?[a-zA-Zπ]+)(?=\W|$)/g, handler: this.processNumberSymbolLog },
                        { regex: /(ln|lg)\s*([a-zA-Zπ]+[0-9]+(?:\.[0-9]+)?)(?=\W|$)/g, handler: this.processSymbolNumberLog },
                        { regex: /(ln|lg)\s*([0-9]+(?:\.[0-9]+)?[a-zA-Zπ]+[0-9]*(?:\.[0-9]+)?)(?=\W|$)/g, handler: this.processComplexLog }
                    ];
                    
                    logPatterns.forEach(pattern => {
                        processed = processed.replace(pattern.regex, (match, func, arg) => {
                            return pattern.handler.call(this, func, arg);
                        });
                    });
                    
                    const logNDigitPattern = /\blog([0-9]+)\s*([0-9]+)(?=\W|$)/g;
                    processed = processed.replace(logNDigitPattern, (match, base, arg) => {
                        return `log${base}(${arg})`;
                    });

                    return processed;
                },
                
                processSimpleNumberLog(func, arg) {
                    return `${func}(${arg})`;
                },
                
                processSimpleSymbolLog(func, arg) {
                    let processedArg = arg;
                    if (arg === 'π') processedArg = 'pi';
                    return `${func}(${processedArg})`;
                },
                
                processNumberSymbolLog(func, arg) {
                    let processedArg = arg.replace(/([0-9\.]+)([a-zA-Zπ])/g, '$1*$2');
                    processedArg = processedArg.replace(/π/g, 'pi');
                    return `${func}(${processedArg})`;
                },
                
                processSymbolNumberLog(func, arg) {
                    let processedArg = arg.replace(/([a-zA-Zπ])([0-9\.]+)/g, '$1*$2');
                    processedArg = processedArg.replace(/π/g, 'pi');
                    return `${func}(${processedArg})`;
                },
                
                processComplexLog(func, arg) {
                    let processedArg = arg
                        .replace(/([0-9\.]+)([a-zA-Zπ])/g, '$1*$2')
                        .replace(/([a-zA-Zπ])([0-9\.]+)/g, '$1*$2')
                        .replace(/([eπ])([eπ])/g, '$1*$2');
                    processedArg = processedArg.replace(/π/g, 'pi');
                    return `${func}(${processedArg})`;
                },
                
                calculate(expression, operation, variable, nthOrder) {
                    const operationNames = {
                        'derivative': '一阶导数 (d/dx)',
                        'integral': '积分 (∫ dx)',
                        'second_derivative': '二阶导数 (d²/dx²)',
                        'nth_derivative': `n阶导数 (d^${nthOrder}/d${variable}^${nthOrder})`,
                        'simplify': '表达式化简',
                        'evaluate': '表达式求值'
                    };
                    
                    let result;
                    
                    switch (operation) {
                        case 'derivative':
                            result = this.calculateDerivative(expression, variable);
                            break;
                        case 'integral':
                            result = this.calculateIntegral(expression, variable);
                            break;
                        case 'second_derivative':
                            result = this.calculateNthDerivative(expression, variable, 2);
                            break;
                        case 'nth_derivative':
                            result = this.calculateNthDerivative(expression, variable, nthOrder);
                            break;
                        case 'simplify':
                            result = this.calculateSimplify(expression, variable);
                            break;
                        case 'evaluate':
                            result = this.evaluateExpression(expression);
                            break;
                        default:
                            throw new Error('不支持的计算类型');
                    }
                    
                    result.operation = operation;
                    result.variable = variable;
                    result.name = operationNames[operation];
                    result.originalExpression = expression;
                    
                    return result;
                },
                
                calculateDerivative(expr, varName) {
                    const steps = [`原函数: ${this.formatExpressionForDisplay(expr)}`];
                    try {
                        const result = math.derivative(expr, varName).toString();
                        const copyText = `d/d${varName}(${this.cleanMathJSText(expr)}) = ${this.cleanMathJSText(result)}`;
                        return { expression: this.cleanMathJSText(result), steps, copyText };
                    } catch (error) {
                        const copyText = `d/d${varName}(${this.cleanMathJSText(expr)}) = 无法计算该导数`;
                        return { expression: "无法计算该导数", steps: [`发生错误: ${error.message}`], copyText, error: error.message };
                    }
                },
                
                calculateNthDerivative(expr, varName, order) {
                    const steps = [`原函数: ${this.formatExpressionForDisplay(expr)}`, `计算 ${order} 阶导数`];
                    const orderNum = parseInt(order);
                    if (isNaN(orderNum) || orderNum < 1) {
                        throw new Error('阶数必须是一个大于等于 1 的整数');
                    }
                    
                    let currentExpr = expr;
                    for (let i = 1; i <= orderNum; i++) {
                        currentExpr = math.derivative(currentExpr, varName).toString();
                        steps.push(`第 ${i} 阶导数: ${this.cleanMathJSText(currentExpr)}`);
                    }
                    
                    const copyText = `d^${order}/d${varName}^${order}(${this.cleanMathJSText(expr)}) = ${this.cleanMathJSText(currentExpr)}`;
                    return { expression: this.cleanMathJSText(currentExpr), steps, copyText };
                },
                
                calculateIntegral(expr, varName) {
                    const steps = [`被积函数: ${this.formatExpressionForDisplay(expr)}`];
                    try {
                        const result = math.integral(expr, varName).toString();
                        steps.push(`积分结果: ${this.cleanMathJSText(result)}`);
                        const copyText = `∫(${this.cleanMathJSText(expr)}) d${varName} = ${this.cleanMathJSText(result)} + C`;
                        return { expression: this.cleanMathJSText(result) + ' + C', steps, copyText };
                    } catch (error) {
                        const copyText = `∫(${this.cleanMathJSText(expr)}) d${varName} = 无法计算该积分`;
                        return { expression: "无法计算该积分", steps: [`发生错误: ${error.message}`], copyText, error: error.message };
                    }
                },
                
                calculateSimplify(expr, varName) {
                    const steps = [`原表达式: ${this.formatExpressionForDisplay(expr)}`];
                    try {
                        const result = math.simplify(expr).toString();
                        steps.push(`化简结果: ${this.cleanMathJSText(result)}`);
                        const copyText = `${this.cleanMathJSText(expr)} = ${this.cleanMathJSText(result)}`;
                        return { expression: this.cleanMathJSText(result), steps, copyText };
                    } catch (error) {
                        const copyText = `${this.cleanMathJSText(expr)} = 无法化简`;
                        return { expression: "无法化简", steps: [`发生错误: ${error.message}`], copyText, error: error.message };
                    }
                },
                
                evaluateExpression(expr) {
                    const variable = App.elements.variableInput.value.trim() || 'x';
                    const steps = [`表达式: ${this.formatExpressionForDisplay(expr)}`];
                    const scope = {};
                    const inputs = App.elements.variableInputs.querySelectorAll('input');
                    inputs.forEach(input => {
                        const varName = input.id.replace('var-', '');
                        scope[varName] = parseFloat(input.value) || 0;
                    });
                    
                    scope.pi = math.pi;
                    scope.e = math.e;

                    const scopeDisplay = Object.entries(scope).map(([key, value]) => `${key} = ${value}`).join(', ');
                    steps.push(`变量赋值: { ${scopeDisplay} }`);

                    try {
                        const result = math.evaluate(expr, scope);
                        steps.push(`求值结果: ${result}`);
                        const copyText = `${this.cleanMathJSText(expr)} = ${result}`;
                        return { expression: result.toString(), steps, copyText };
                    } catch (error) {
                        const copyText = `${this.cleanMathJSText(expr)} = 求值失败`;
                        return { expression: "求值失败", steps: [`发生错误: ${error.message}`], copyText, error: error.message };
                    }
                },
                
                cleanMathJSText(text) {
                    let cleaned = text;
                    
                    cleaned = cleaned.replace(/log\(([^,]+),([^)]+)\)/g, 'log<sub>$2</sub>($1)'); 
                    cleaned = cleaned.replace(/log10\(([^)]+)\)/g, 'lg($1)');
                    cleaned = cleaned.replace(/log\(([^)]+)\)/g, 'ln($1)'); 
                    cleaned = cleaned.replace(/\* /g, '');
                    cleaned = cleaned.replace(/\*/g, '');
                    cleaned = cleaned.replace(/pi/g, 'π');
                    cleaned = cleaned.replace(/sqrt\(([^)]+)\)/g, '√($1)');
                    
                    return cleaned;
                },
                
                formatExpressionForDisplay(text) {
                    let formattedText = text;

                    formattedText = formattedText.replace(/exp\(([^)]+)\)/g, '<span class="exponential">e^($1)</span>');
                    formattedText = formattedText.replace(/(\d*\.?\d*) \* exp\(([^)]+)\)/g, '$1<span class="exponential">e^($2)</span>');
                    
                    formattedText = formattedText.replace(/log\(([^,]+),([^)]+)\)/g, 'log<sub>$2</sub>($1)');
                    formattedText = formattedText.replace(/log10\(([^)]+)\)/g, 'lg($1)');
                    formattedText = formattedText.replace(/log\(([^)]+)\)/g, 'ln($1)');
                    
                    formattedText = formattedText.replace(/\* /g, '');
                    formattedText = formattedText.replace(/\*/g, '');
                    
                    formattedText = formattedText.replace(/sqrt\(([^)]+)\)/g, '√($1)');
                    formattedText = formattedText.replace(/pi/g, 'π');
                    
                    return formattedText;
                },
                
                displayResult(result) {
                    const { outputDiv, stepsDiv } = App.elements;
                    
                    const integralConstant = (result.operation === 'integral') ? ' + C' : '';
                    
                    let resultTitle = '';
                    let inputDisplay = '';

                    if (result.operation === 'integral') {
                        inputDisplay = `∫(${this.formatExpressionForDisplay(result.originalExpression)}) d${result.variable} = `;
                        resultTitle = '积分结果:';
                    } else if (result.operation === 'simplify') {
                        inputDisplay = `${this.formatExpressionForDisplay(result.originalExpression)} = `;
                        resultTitle = '化简结果:';
                    } else if (result.operation === 'evaluate') {
                        resultTitle = '求值结果:';
                    } else {
                        resultTitle = '计算结果:';
                    }
                    
                    const displayExpression = this.formatExpressionForDisplay(result.expression);

                    let outputHTML = '';
                    
                    outputHTML += `
                        <div class="math-expression">
                            <div class="result-title">${resultTitle}</div>
                            <div class="result-text">${inputDisplay}${displayExpression}${integralConstant}</div>
                            <i class="fas fa-copy copy-icon" title="复制结果" data-text="${inputDisplay}${displayExpression}${integralConstant}"></i>
                        </div>
                    `;
                    
                    outputDiv.innerHTML = outputHTML;
                    
                    if (result.steps && result.steps.length > 0) {
                        const stepsTitle = document.createElement('h3');
                        stepsTitle.innerHTML = '<i class="fas fa-list-ol"></i> 计算步骤';
                        stepsDiv.appendChild(stepsTitle);
                        
                        result.steps.forEach((step, index) => {
                            const stepElement = document.createElement('div');
                            stepElement.className = 'step';
                            
                            const displayStep = this.formatExpressionForDisplay(this.cleanMathJSText(step));
                                
                            stepElement.innerHTML = `
                                <div class="step-title">
                                    <i class="fas fa-arrow-right"></i> 步骤 ${index + 1} 
                                </div>
                                <div class="result-text">${displayStep}</div>
                            `;
                            stepsDiv.appendChild(stepElement);
                        });
                    }
                    
                    this.addCopyFunctionality();
                },
                
                displayError(message, expression) {
                    const { outputDiv } = App.elements;
                    outputDiv.innerHTML = `
                        <div class="error">
                            <strong>计算错误:</strong> ${message} 
                        </div>
                        <div class="math-expression">
                            <div class="result-title">输入表达式:</div>
                            <div class="result-text">${this.formatExpressionForDisplay(expression)}</div>
                        </div>
                    `;
                },
                
                handleClear() {
                    const { expressionInput, outputDiv, stepsDiv, variableInputs } = App.elements;
                    expressionInput.value = '';
                    outputDiv.innerHTML = '<p style="text-align: center; color: #ccc; padding: 30px;">计算结果将显示在这里...</p>';
                    stepsDiv.innerHTML = '';
                    variableInputs.innerHTML = '';
                    App.cache.clear();
                },
                
                addCopyFunctionality() {
                    document.querySelectorAll('.copy-icon').forEach(icon => {
                        icon.addEventListener('click', async (e) => {
                            const text = e.currentTarget.getAttribute('data-text');
                            try {
                                await navigator.clipboard.writeText(text);
                                this.showSuccessMessage('已复制到剪贴板！');
                            } catch (err) {
                                const textArea = document.createElement('textarea');
                                textArea.value = text;
                                document.body.appendChild(textArea);
                                textArea.select();
                                document.execCommand('copy');
                                document.body.removeChild(textArea);
                                this.showSuccessMessage('已复制到剪贴板！');
                            }
                        });
                    });
                },
                
                showSuccessMessage(message) {
                    const messageEl = document.createElement('div');
                    messageEl.className = 'success-message';
                    messageEl.innerHTML = `<i class="fas fa-check"></i> ${message}`;
                    document.body.appendChild(messageEl);
                    
                    setTimeout(() => {
                        document.body.removeChild(messageEl);
                    }, 2000);
                }
            },

            // 搜索功能
            search: {
                perform(query, category = 'all') {
                    const results = [];
                    const lowerQuery = query.toLowerCase();
                    
                    if (category === 'all' || category === 'functions') {
                        App.searchData.functions.forEach(item => {
                            if (item.name.toLowerCase().includes(lowerQuery) || 
                                item.description.toLowerCase().includes(lowerQuery)) {
                                results.push(item);
                            }
                        });
                    }
                    
                    if (category === 'all' || category === 'constants') {
                        App.searchData.constants.forEach(item => {
                            if (item.name.toLowerCase().includes(lowerQuery) || 
                                item.description.toLowerCase().includes(lowerQuery)) {
                                results.push(item);
                            }
                        });
                    }
                    
                    if (category === 'all' || category === 'examples') {
                        App.searchData.examples.forEach(item => {
                            if (item.name.toLowerCase().includes(lowerQuery) || 
                                item.description.toLowerCase().includes(lowerQuery)) {
                                results.push(item);
                            }
                        });
                    }
                    
                    return results;
                },
                
                display(results) {
                    const resultsContainer = App.elements.searchResults;
                    
                    if (results.length === 0) {
                        resultsContainer.innerHTML = '<p class="no-results">未找到相关结果</p>';
                        return;
                    }
                    
                    let html = '';
                    results.forEach(result => {
                        html += `
                            <div class="search-result-item" data-example="${result.example}">
                                <div class="search-result-title">${result.name}</div>
                                <div class="search-result-description">${result.description}</div>
                                <div class="search-result-example">示例: ${result.example}</div>
                            </div>
                        `;
                    });
                    
                    resultsContainer.innerHTML = html;
                    
                    // 添加点击事件
                    resultsContainer.querySelectorAll('.search-result-item').forEach(item => {
                        item.addEventListener('click', function() {
                            const example = this.getAttribute('data-example');
                            App.elements.expression.value = example;
                            App.elements.searchPanel.classList.remove('active');
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        });
                    });
                },
                
                addToHistory(query) {
                    if (!query.trim()) return;
                    
                    // 移除重复项
                    App.searchHistory = App.searchHistory.filter(item => item !== query);
                    // 添加到开头
                    App.searchHistory.unshift(query);
                    // 限制历史记录数量
                    App.searchHistory = App.searchHistory.slice(0, 10);
                    // 保存到本地存储
                    localStorage.setItem('searchHistory', JSON.stringify(App.searchHistory));
                    // 更新下拉列表
                    this.updateHistory();
                },
                
                updateHistory() {
                    const historySelect = App.elements.searchHistory;
                    historySelect.innerHTML = '<option value="">-- 选择历史搜索 --</option>';
                    
                    App.searchHistory.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item;
                        option.textContent = item;
                        historySelect.appendChild(option);
                    });
                },
                
                clear() {
                    App.elements.searchInput.value = '';
                    App.elements.searchResults.innerHTML = '<p class="no-results">暂无搜索结果</p>';
                    App.elements.searchCategory.value = 'all';
                    App.audio.play(...App.elements.soundType.value.split(':'));
                    App.vibration.trigger(App.elements.vibrateMode.value);
                }
            },

            // AIOS聊天功能 - 优化版本
            chat: {
                isGenerating: false,
                abortController: null,
                currentStreamRequest: null, // 添加当前请求引用
                isEditing: false, // 是否处于编辑模式
                editingMessageId: null, // 正在编辑的消息ID
                
                // 节流与防抖相关变量
                updateQueue: [],
                isProcessingQueue: false,
                lastUpdateTime: 0,
                updateThrottleDelay: 50, // 50ms节流延迟
                updateDebounceDelay: 100, // 100ms防抖延迟
                debounceTimer: null,
                
                // 聊天历史记录
                conversationHistory: [],
                maxHistoryLength: 20, // 最大保存20轮对话
                systemPrompt: "你是一个智能助手，能够帮助用户解答各种问题，包括数学计算、编程、日常生活等。请用简洁、准确、友好的方式回答用户的问题。",
                
                // 智能滚动相关属性
                autoScrollEnabled: true,
                userScrolled: false,
                lastScrollTop: 0,
                scrollThreshold: 50, // 用户滚动多少像素后认为是有意滚动
                scrollCheckInterval: null,
                
                async sendMessage() {
                    const message = App.elements.chatInput.value.trim();
                    if (!message) return;

                    console.log('sendMessage被调用，当前isGenerating状态:', this.isGenerating);

                    // 如果正在生成，则停止生成
                    if (this.isGenerating) {
                        console.log('检测到正在生成，执行停止操作');
                        this.stopGeneration();
                        return;
                    }

                    // 检查是否处于编辑模式
                    if (this.isEditing) {
                        // 找到正在编辑的消息
                        const editingMessage = document.querySelector(`[data-message-id="${this.editingMessageId}"]`);
                        if (editingMessage) {
                            // 更新编辑的消息内容
                            const userContent = editingMessage.querySelector('.user-content p');
                            if (userContent) {
                                // 处理消息内容，确保正确换行，但保留Markdown格式
                                const processedContent = message
                                    .replace(/&/g, '&amp;')
                                    .replace(/</g, '&lt;')
                                    .replace(/>/g, '&gt;');
                                
                                // 处理换行和空格，但保留Markdown格式
                                const formattedContent = processedContent
                                    .replace(/\n/g, '<br>')
                                    .replace(/  /g, '&nbsp;&nbsp;');
                                
                                // 检查消息是否过长，添加折叠功能
                                const isLongMessage = message.length > 200;
                                const messageClass = isLongMessage ? 'collapsed-message' : '';
                                
                                // 更新消息内容
                                const userContentDiv = editingMessage.querySelector('.user-content');
                                userContentDiv.className = `user-content ${messageClass}`;
                                userContentDiv.innerHTML = isLongMessage ? 
                                    `<div class="expand-controls"><span class="message-actions" title="复制">📋复制</span><span class="message-action-icon expand-toggle" title="展开">v</span> <span class="expand-indicator">点击 v 展开完整内容</span></div>
                                     <p>${formattedContent}</p>` :
                                    `<p>${formattedContent}<span class="message-actions" title="复制">📋复制</span> <span class="message-actions" title="编辑" style="margin-left: 15px;">✏️编辑</span></p>`;
                                
                                // 恢复消息样式
                                editingMessage.style.border = '';
                                editingMessage.style.borderRadius = '';
                                editingMessage.style.padding = '';
                                editingMessage.style.backgroundColor = '';
                                
                                // 重新添加复制和编辑功能
                                this.addCopyFunctionality(editingMessage);
                                
                                // 如果是长消息，添加展开/折叠功能
                                if (isLongMessage) {
                                    this.addToggleFunctionality(editingMessage);
                                }
                                
                                // 删除编辑消息之后的所有消息
                                this.removeMessagesAfter(editingMessage);
                                
                                // 不再调用updateHistoryAfterEdit，避免更新数组中的第一个用户消息
                                // 直接确保编辑后的用户消息在历史记录末尾
                                this.ensureUserMessageAtEnd(message);
                            }
                        }
                        
                        // 退出编辑模式
                        this.isEditing = false;
                        this.editingMessageId = null;
                        
                        // 清空输入框
                        App.elements.chatInput.value = '';
                        
                        // 恢复输入框占位符
                        App.elements.chatInput.placeholder = '输入您的问题... (Ctrl+Enter发送，支持数学公式)';
                        
                        // 开始生成AI回复
                        this.startGeneration();
                        
                        // 构建包含历史上下文的消息（不重复添加用户消息）
                        const contextualMessages = this.buildContextualMessageWithoutUser(message);
                        
                        // 尝试使用API回答
                        try {
                            // 调用流式API，传递完整的对话历史
                            await this.callStreamAPI(contextualMessages);
                        } catch (error) {
                            console.log('捕获到错误:', error);
                            
                            // 检查是否是因为取消导致的错误
                            if (error.name === 'AbortError' || this.abortController?.signal.aborted) {
                                console.log('API调用被用户取消');
                                return;
                            }
                            
                            // 停止生成
                            this.stopGeneration();
                            
                            // 显示错误信息
                            this.addMessage(`API调用失败: ${error.message}\n\n提示：请点击AIOS面板右侧的"API"按钮配置正确的API密钥以启用智能AI对话。`, 'ai');
                        }
                        
                        return;
                    }

                    // 添加用户消息到界面
                    this.addMessage(message, 'user');
                    App.elements.chatInput.value = '';
                    
                    // 重置滚动状态，确保新消息后自动滚动
                    this.resetScrollState();

                    // 检查是否是数学相关问题，如果是，添加当前表达式上下文
                    let enhancedMessage = message;
                    const currentExpression = App.elements.expressionInput.value.trim();
                    const currentOperation = App.elements.operationSelect.value;
                    
                    if (currentExpression && this.isMathRelatedQuestion(message)) {
                        enhancedMessage = `${message}\n\n当前计算器中的表达式: ${currentExpression}\n计算类型: ${this.getOperationName(currentOperation)}`;
                    }

                    // 将用户消息添加到历史记录（使用增强后的消息）
                    this.addToHistory('user', enhancedMessage);

                    // 开始生成，更新按钮状态
                    this.startGeneration();

                    // 构建包含历史上下文的消息（不重复添加用户消息）
                    const contextualMessages = this.buildContextualMessageWithoutUser(enhancedMessage);

                    // 尝试使用API回答
                    try {
                        // 调用流式API，传递完整的对话历史
                        await this.callStreamAPI(contextualMessages);
                    } catch (error) {
                        console.log('捕获到错误:', error);
                        
                        // 检查是否是因为取消导致的错误
                        if (error.name === 'AbortError' || this.abortController?.signal.aborted) {
                            console.log('API调用被用户取消');
                            // 不显示错误消息，因为用户主动取消
                            // 保持已生成的消息不变
                            return;
                        }
                        
                        // 停止生成但不移除已显示的消息
                        this.stopGeneration();
                        
                        // 显示错误信息，但不移除已生成的消息
                        this.addMessage(`API调用失败: ${error.message}\n\n提示：请点击AIOS面板右侧的"API"按钮配置正确的API密钥以启用智能AI对话。`, 'ai');
                    }
                },

                // 节流函数 - 限制函数执行频率
                throttle(func, delay) {
                    let lastCall = 0;
                    return function(...args) {
                        const now = Date.now();
                        if (now - lastCall >= delay) {
                            lastCall = now;
                            return func.apply(this, args);
                        }
                    };
                },
                
                // 防抖函数 - 延迟执行函数，如果在延迟时间内再次调用则重置计时器
                debounce(func, delay) {
                    let timeoutId;
                    return function(...args) {
                        clearTimeout(timeoutId);
                        timeoutId = setTimeout(() => func.apply(this, args), delay);
                    };
                },
                
                // 添加消息到历史记录
                addToHistory(role, content) {
                    this.conversationHistory.push({
                        role: role,
                        content: content
                    });
                    
                    // 限制历史记录长度
                    if (this.conversationHistory.length > this.maxHistoryLength * 2) {
                        // 保留最近的对话（每轮对话包含用户和AI两条消息）
                        this.conversationHistory = this.conversationHistory.slice(-this.maxHistoryLength * 2);
                    }
                },
                
                // 构建包含历史上下文的消息
                buildContextualMessage(userMessage) {
                    let messages = [];
                    
                    // 添加系统提示
                    if (this.conversationHistory.length === 0) {
                        messages.push({
                            role: 'system',
                            content: this.systemPrompt
                        });
                    }
                    
                    // 添加历史对话
                    messages = messages.concat(this.conversationHistory);
                    
                    // 添加当前用户消息
                    messages.push({
                        role: 'user',
                        content: userMessage
                    });
                    
                    return messages;
                },
                
                // 构建包含历史上下文的消息（不重复添加用户消息）
                buildContextualMessageWithoutUser(userMessage) {
                    let messages = [];
                    
                    // 添加系统提示
                    if (this.conversationHistory.length === 0) {
                        messages.push({
                            role: 'system',
                            content: this.systemPrompt
                        });
                    }
                    
                    // 添加历史对话（已经包含了用户消息）
                    messages = messages.concat(this.conversationHistory);
                    
                    return messages;
                },
                
                // 清空聊天历史
                clearHistory() {
                    this.conversationHistory = [];
                    // 清空界面上的消息，保留欢迎消息
                    const messages = App.elements.chatMessages.querySelectorAll('.ai-message, .user-message');
                    messages.forEach(msg => msg.remove());
                    
                    // 重新添加欢迎消息
                    this.addMessage('您好！我是AIOS智能助手，有什么可以帮助您的吗？', 'ai');
                },
                
                // 获取格式化的历史记录（用于调试）
                getFormattedHistory() {
                    return this.conversationHistory.map(msg => `[${msg.role}]: ${msg.content}`).join('\n');
                },
                
                // 优化的UI更新队列处理
                processUpdateQueue: function() {
                    if (this.isProcessingQueue || this.updateQueue.length === 0) {
                        return;
                    }
                    
                    // 检查是否已停止生成
                    if (!this.isGenerating || (this.abortController && this.abortController.signal.aborted)) {
                        console.log('检测到停止信号，清空更新队列');
                        this.updateQueue = [];
                        this.isProcessingQueue = false;
                        return;
                    }
                    
                    this.isProcessingQueue = true;
                    
                    // 使用requestAnimationFrame确保在下一帧渲染
                    requestAnimationFrame(() => {
                        // 再次检查是否已停止生成
                        if (!this.isGenerating || (this.abortController && this.abortController.signal.aborted)) {
                            console.log('在帧回调中检测到停止信号，清空更新队列');
                            this.updateQueue = [];
                            this.isProcessingQueue = false;
                            return;
                        }
                        
                        // 只处理最新的更新，忽略队列中的旧更新
                        const latestUpdate = this.updateQueue.pop();
                        this.updateQueue = []; // 清空队列，只保留最新内容
                        
                        if (latestUpdate) {
                            const { aiMessageElement, messageContentElement, fullContent } = latestUpdate;
                            
                            // 处理特殊字符，确保HTML安全，但保留Markdown格式
                            const safeContent = fullContent
                                .replace(/&/g, '&amp;')
                                .replace(/</g, '&lt;')
                                .replace(/>/g, '&gt;');
                            
                            // 处理换行和空格，但保留Markdown格式
                            const formattedContent = safeContent
                                .replace(/\n/g, '<br>')
                                .replace(/  /g, '&nbsp;&nbsp;');
                            
                            // 更新UI
                            messageContentElement.innerHTML = formattedContent + '<span class="message-actions" title="复制">📋复制</span>';
                            
                            // 滚动到底部
                            //App.elements.chatMessages.scrollTop = App.elements.chatMessages.scrollHeight;
                            
                            // 更新消息的原始内容属性
                            aiMessageElement.setAttribute('data-original-content', fullContent);
                            
                            // 重新添加复制功能
                            this.addCopyFunctionality(aiMessageElement);
                        }
                        
                        this.isProcessingQueue = false;
                        
                        // 如果还有待处理的更新，继续处理
                        if (this.updateQueue.length > 0 && this.isGenerating) {
                            this.processUpdateQueue();
                        }
                    });
                },
                
                // 队列化UI更新
                queueUIUpdate: function(aiMessageElement, messageContentElement, fullContent) {
                    // 如果队列中已有该元素的更新，替换它
                    const existingIndex = this.updateQueue.findIndex(
                        item => item.aiMessageElement === aiMessageElement
                    );
                    
                    if (existingIndex !== -1) {
                        this.updateQueue[existingIndex] = { aiMessageElement, messageContentElement, fullContent };
                    } else {
                        this.updateQueue.push({ aiMessageElement, messageContentElement, fullContent });
                    }
                    
                    // 使用防抖处理队列
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = setTimeout(() => {
                        this.processUpdateQueue();
                    }, this.updateDebounceDelay);
                },
                
                // 智能滚动功能初始化
                initSmartScroll() {
                    const chatMessages = App.elements.chatMessages;
                    
                    // 监听滚动事件
                    chatMessages.addEventListener('scroll', () => {
                        const currentScrollTop = chatMessages.scrollTop;
                        const scrollHeight = chatMessages.scrollHeight;
                        const clientHeight = chatMessages.clientHeight;
                        const distanceFromBottom = scrollHeight - currentScrollTop - clientHeight;
                        
                        // 检查用户是否向上滚动（有意查看历史消息）
                        // 降低阈值，使滚动更容易触发
                        if (currentScrollTop < this.lastScrollTop - 0) {
                            this.userScrolled = true;
                            this.autoScrollEnabled = false;
                        }
                        // 检查用户是否滚动到底部附近
                        else if (distanceFromBottom < 100) {
                            this.userScrolled = false;
                            this.autoScrollEnabled = true;
                        }
                        
                        this.lastScrollTop = currentScrollTop;
                    });
                    
                    // 监听鼠标按下事件，检测用户开始滚动
                    chatMessages.addEventListener('mousedown', () => {
                        // 用户开始交互时，暂时禁用自动滚动
                        this.wasAutoScrollEnabled = this.autoScrollEnabled;
                        this.autoScrollEnabled = false;
                    });
                    
                    // 监听鼠标释放事件
                    chatMessages.addEventListener('mouseup', () => {
                        // 用户释放鼠标后，根据位置决定是否恢复自动滚动
                        const currentScrollTop = chatMessages.scrollTop;
                        const scrollHeight = chatMessages.scrollHeight;
                        const clientHeight = chatMessages.clientHeight;
                        const distanceFromBottom = scrollHeight - currentScrollTop - clientHeight;
                        
                        // 如果在底部附近，恢复自动滚动
                        if (distanceFromBottom < 100) {
                            this.autoScrollEnabled = true;
                        }
                    });
                    
                    // 监听触摸事件（移动设备）
                    chatMessages.addEventListener('touchstart', () => {
                        this.wasAutoScrollEnabled = this.autoScrollEnabled;
                        this.autoScrollEnabled = false;
                    });
                    
                    chatMessages.addEventListener('touchend', () => {
                        const currentScrollTop = chatMessages.scrollTop;
                        const scrollHeight = chatMessages.scrollHeight;
                        const clientHeight = chatMessages.clientHeight;
                        const distanceFromBottom = scrollHeight - currentScrollTop - clientHeight;
                        
                        if (distanceFromBottom < 100) {
                            this.autoScrollEnabled = true;
                        }
                    });
                    
                    // 定期检查是否需要自动滚动（仅在AI生成时）
                    this.startScrollCheck();
                },
                
                // 开始滚动检查
                startScrollCheck() {
                    if (this.scrollCheckInterval) {
                        clearInterval(this.scrollCheckInterval);
                        this.scrollCheckInterval = null;
                    }
                    
                    // 确保自动滚动启用
                    this.autoScrollEnabled = true;
                    
                    this.scrollCheckInterval = setInterval(() => {
                        if (this.isGenerating && this.autoScrollEnabled) {
                            this.smartScrollToBottom();
                        }
                    }, 200); // 降低检查频率，减少性能开销
                    
                    console.log('滚动检查已启动，autoScrollEnabled:', this.autoScrollEnabled);
                },
                
                // 停止滚动检查
                stopScrollCheck() {
                    if (this.scrollCheckInterval) {
                        clearInterval(this.scrollCheckInterval);
                        this.scrollCheckInterval = null;
                    }
                },
                
                // 智能滚动到底部
                smartScrollToBottom() {
                    const chatMessages = App.elements.chatMessages;
                    
                    // 只有在自动滚动启用时才滚动
                    if (this.autoScrollEnabled) {
                        // 检查当前是否已经在底部附近
                        const currentScrollTop = chatMessages.scrollTop;
                        const scrollHeight = chatMessages.scrollHeight;
                        const clientHeight = chatMessages.clientHeight;
                        const distanceFromBottom = scrollHeight - currentScrollTop - clientHeight;
                        
                        // 强制滚动到底部，不管距离多少
                        chatMessages.scrollTop = chatMessages.scrollHeight;
                        
                        // 如果不在底部附近，使用平滑滚动
                        if (distanceFromBottom > 50) {
                            setTimeout(() => {
                                if (this.autoScrollEnabled && this.isGenerating) {
                                    chatMessages.scrollTo({
                                        top: chatMessages.scrollHeight,
                                        behavior: 'smooth'
                                    });
                                }
                            }, 50);
                        }
                    }
                },
                
                // 重置滚动状态（用户发送新消息时调用）
                resetScrollState() {
                    this.autoScrollEnabled = true;
                    this.userScrolled = false;
                    this.lastScrollTop = App.elements.chatMessages.scrollTop;
                    // 立即滚动到底部，确保用户看到新消息
                    App.elements.chatMessages.scrollTop = App.elements.chatMessages.scrollHeight;
                    
                    // 确保滚动检查正在运行
                    if (this.isGenerating && !this.scrollCheckInterval) {
                        this.startScrollCheck();
                    }
                },
                
                // 添加键盘快捷键支持
                setupKeyboardShortcuts() {
                    document.addEventListener('keydown', (e) => {
                        // ESC键停止生成或取消编辑
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            if (this.isGenerating) {
                                this.stopGeneration();
                            } else if (this.isEditing) {
                                this.cancelEdit();
                            }
                        }
                        
                        // Ctrl+Enter发送
                        if (e.key === 'Enter' && e.ctrlKey && document.activeElement === App.elements.chatInput) {
                            e.preventDefault();
                            this.sendMessage();
                        }
                    });
                },
                
                // 修改发送按钮的事件处理
                setupSendButton() {
                    App.elements.sendBtn.addEventListener('click', () => {
                        // 如果按钮是停止模式，则停止生成
                        if (App.elements.sendBtn.classList.contains('stop-mode')) {
                            this.stopGeneration();
                        } else {
                            this.sendMessage();
                        }
                    });
                    
                    // 初始化智能滚动功能
                    this.initSmartScroll();
                },
                
                // 检查是否是数学相关问题
                isMathRelatedQuestion(message) {
                    const mathKeywords = [
                        '计算', '求导', '积分', '化简', '求值', '解方程', '函数', '公式', 
                        '定理', '证明', '图形', '图像', '变换', '因式分解', '展开', '合并',
                        '微分', '极限', '级数', '矩阵', '向量', '几何', '代数', '三角',
                        '对数', '指数', '平方根', '立方根', '导数', '不定积分', '定积分',
                        '微分方程', '概率', '统计', '数列', '集合', '不等式', '参数方程'
                    ];
                    
                    const lowerMessage = message.toLowerCase();
                    return mathKeywords.some(keyword => lowerMessage.includes(keyword));
                },

                // 获取计算类型的中文名称
                getOperationName(operation) {
                    const operationNames = {
                        'derivative': '求导 (d/dx)',
                        'integral': '积分 (∫ dx)',
                        'second_derivative': '二阶导数 (d²/dx²)',
                        'nth_derivative': 'n阶导数',
                        'simplify': '表达式化简',
                        'evaluate': '表达式求值'
                    };
                    return operationNames[operation] || operation;
                },
                
                startGeneration() {
                    console.log('开始生成，设置isGenerating为true');
                    this.isGenerating = true;
                    
                    // 重置滚动状态，启用自动滚动
                    this.resetScrollState();
                    
                    // 更改按钮图标为停止图标，增强视觉效果
                    App.elements.sendBtn.innerHTML = '⏹';
                    App.elements.sendBtn.classList.add('stop-mode');
                    App.elements.sendBtn.title = '点击停止生成';
                    
                    // 创建新的AbortController用于取消请求
                    this.abortController = new AbortController();
                    console.log('AbortController已创建');
                    
                    // 显示AI思考中的加载动画
                    this.showThinkingIndicator();
                    
                    // 添加停止按钮的视觉反馈
                    this.addStopButtonVisualFeedback();
                },
                
                stopGeneration() {
                    console.log('停止生成功能被调用，当前isGenerating状态:', this.isGenerating);
                    
                    // 立即设置状态为非生成中
                    this.isGenerating = false;
                    
                    // 停止滚动检查
                    this.stopScrollCheck();
                    
                    // 恢复按钮图标和样式
                    App.elements.sendBtn.innerHTML = '➤';
                    App.elements.sendBtn.classList.remove('stop-mode');
                    App.elements.sendBtn.title = '发送消息 (Ctrl+Enter)';
                    
                    // 取消进行中的请求
                    if (this.abortController) {
                        console.log('正在取消API请求...');
                        try {
                            // 添加额外的停止逻辑
                            this.abortController.abort('用户主动停止');
                            console.log('API请求已成功取消');
                        } catch (error) {
                            console.error('取消请求时出错:', error);
                        }
                        this.abortController = null;
                        
                        // 显示停止提示，但不移除已生成的消息
                        this.showStopMessage();
                    } else {
                        console.log('没有进行中的请求需要取消');
                    }
                    
                    // 取消当前流式请求
                    if (this.currentStreamRequest) {
                        try {
                            this.currentStreamRequest.cancel();
                            console.log('当前流式请求已取消');
                        } catch (error) {
                            console.error('取消流式请求时出错:', error);
                        }
                        this.currentStreamRequest = null;
                    }
                    
                    // 清除防抖计时器
                    if (this.debounceTimer) {
                        clearTimeout(this.debounceTimer);
                        this.debounceTimer = null;
                        console.log('防抖计时器已清除');
                    }
                    
                    // 清空更新队列，但不移除已显示的消息
                    this.updateQueue = [];
                    this.isProcessingQueue = false;
                    console.log('更新队列已清空');
                    
                    // 隐藏加载动画
                    this.hideThinkingIndicator();
                    
                    // 移除停止按钮的视觉反馈
                    this.removeStopButtonVisualFeedback();
                    
                    console.log('停止生成功能完成');
                },
                
                // 取消编辑功能
                cancelEdit() {
                    if (!this.isEditing) return;
                    
                    console.log('取消编辑模式');
                    
                    // 找到正在编辑的消息
                    const editingMessage = document.querySelector(`[data-message-id="${this.editingMessageId}"]`);
                    if (editingMessage) {
                        // 恢复消息样式
                        editingMessage.style.border = '';
                        editingMessage.style.borderRadius = '';
                        editingMessage.style.padding = '';
                        editingMessage.style.backgroundColor = '';
                    }
                    
                    // 退出编辑模式
                    this.isEditing = false;
                    this.editingMessageId = null;
                    
                    // 清空输入框
                    App.elements.chatInput.value = '';
                    
                    // 调整输入框高度
                    App.elements.chatInput.style.height = 'auto';
                    
                    // 恢复输入框占位符
                    App.elements.chatInput.placeholder = '输入您的问题... (Ctrl+Enter发送，支持数学公式)';
                    
                    // 显示取消编辑的提示
                    App.calculator.showSuccessMessage('已取消编辑');
                },
                
                // 添加停止按钮的视觉反馈
                addStopButtonVisualFeedback() {
                    // 添加脉冲动画效果
                    App.elements.sendBtn.style.animation = 'stopPulse 1s infinite';
                    
                    // 如果没有这个动画，添加到样式表中
                    if (!document.querySelector('#stopButtonAnimation')) {
                        const style = document.createElement('style');
                        style.id = 'stopButtonAnimation';
                        style.textContent = `
                            @keyframes stopPulse {
                                0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
                                70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
                                100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                },
                
                // 移除停止按钮的视觉反馈
                removeStopButtonVisualFeedback() {
                    App.elements.sendBtn.style.animation = '';
                },
                
                // 显示停止提示消息
                showStopMessage() {
                    // 隐藏加载动画
                    this.hideThinkingIndicator();
                    
                    // 停止生成时不显示任何消息
                },
                
                async callStreamAPI(messages) {
                    // 创建AI消息容器，用于流式显示
                    const aiMessageId = this.addMessage('', 'ai', true);
                    const aiMessageElement = document.querySelector(`[data-message-id="${aiMessageId}"]`);
                    // 修复选择器，现在正常内容在.main-content p中
                    const messageContentElement = aiMessageElement?.querySelector('.main-content p');
                    
                    // 存储完整的AI回复，用于添加到历史记录
                    let fullAIResponse = '';
                    
                    // 创建响应式文本节点
                    const contentTextNode = document.createTextNode('');
                    const reasoningTextNode = document.createTextNode('');
                    
                    // 初始化内容节点
                    if (messageContentElement) {
                        messageContentElement.innerHTML = ''; // 清空现有内容
                        messageContentElement.appendChild(contentTextNode);
                    }
                    
                    // 初始化reasoning文本节点 - 需要等待reasoning-container创建后再添加
                    // 这里先不添加，在updateReasoningContent中处理
                    
                    let fullContent = '';
                    let reasoningContent = ''; // 思考过程内容
                    let buffer = ''; // 用于缓冲不完整的文本
                    let reasoningBuffer = ''; // 思考过程缓冲区
                    let chunkCount = 0; // 添加块计数器
                    let lastChunkTime = 0; // 用于节流控制
                    
                    // 创建直接更新UI的函数（不使用节流，避免重复）
                    const directUpdateUI = (chunkContent, contentType) => {
                        if (this.isGenerating && !this.abortController?.signal.aborted && chunkContent) {
                            if (contentType === 'reasoning') {
                                // 直接使用updateReasoningContent方法添加思考过程
                                this.updateReasoningContent(aiMessageElement, chunkContent);
                            } else {
                                // 使用文本节点直接追加内容，避免HTML转义问题
                                if (contentTextNode) {
                                    contentTextNode.textContent += chunkContent;
                                }
                            }
                            
                            // 确保自动滚动
                            this.smartScrollToBottom();
                        }
                    };
                    
                    // 定义处理每个数据块的回调函数
                    const handleChunk = (chunkContent, contentType) => {
                        chunkCount++;
                        const now = Date.now();
                        console.log(`handleChunk被调用 #${chunkCount}，类型: ${contentType}，内容长度:`, chunkContent.length);
                        
                        // 检查是否已停止生成
                        if (!this.isGenerating || this.abortController?.signal.aborted) {
                            console.log('检测到停止信号，停止处理后续数据块');
                            return;
                        }
                        
                        if (contentType === 'reasoning') {
                            // 处理思考过程
                            reasoningContent += chunkContent;
                            reasoningBuffer += chunkContent;
                            
                            // 尝试处理缓冲区中的内容，确保不截断中文字符
                            let processedContent = reasoningBuffer;
                            try {
                                // 简化处理：直接使用所有内容，不检查不完整字符
                                // 这样可以避免emoji等特殊字符被误判
                                processedContent = reasoningBuffer;
                                reasoningBuffer = ''; // 清空缓冲区
                            } catch (e) {
                                // 如果处理出错，使用原始内容
                                processedContent = reasoningBuffer;
                                reasoningBuffer = '';
                            }
                            
                            // 直接追加文本
                            if (chunkContent && chunkContent.trim() && this.isGenerating && !this.abortController?.signal.aborted) {
                                directUpdateUI(chunkContent, 'reasoning');
                            }
                        } else {
                            // 处理正常内容
                            fullContent += chunkContent;
                            fullAIResponse += chunkContent; // 同时更新完整回复
                            buffer += chunkContent;
                            
                            // 尝试处理缓冲区中的内容，确保不截断中文字符
                            let processedContent = buffer;
                            try {
                                // 简化处理：直接使用所有内容，不检查不完整字符
                                // 这样可以避免emoji等特殊字符被误判
                                processedContent = buffer;
                                buffer = ''; // 清空缓冲区
                            } catch (e) {
                                // 如果处理出错，使用原始内容
                                processedContent = buffer;
                                buffer = '';
                            }
                            
                            // 直接追加文本
                            if (chunkContent && chunkContent.trim() && this.isGenerating && !this.abortController?.signal.aborted) {
                                directUpdateUI(chunkContent, 'content');
                            }
                        }
                    };
                    
                    try {
                        // 调用API配置中的流式方法
                        await App.apiConfig.callStreamAPI(messages, handleChunk, this.abortController);
                        
                        // 处理缓冲区剩余的内容
                        if (buffer && buffer.trim() && messageContentElement && this.isGenerating && !this.abortController?.signal.aborted) {
                            // 直接更新，不需要节流
                            this.queueUIUpdate(aiMessageElement, messageContentElement, fullContent);
                        }
                        
                        // 处理思考过程缓冲区剩余的内容
                        if (reasoningBuffer && reasoningBuffer.trim() && this.isGenerating && !this.abortController?.signal.aborted) {
                            // 直接更新思考过程
                            this.updateReasoningContent(aiMessageElement, reasoningBuffer);
                        }
                        
                        // 正常结束，停止生成
                        if (this.isGenerating && !this.abortController?.signal.aborted) {
                            // 添加复制按钮到主内容区域
                            const mainContent = aiMessageElement.querySelector('.main-content p');
                            if (mainContent && !mainContent.querySelector('.message-actions')) {
                                const copySpan = document.createElement('span');
                                copySpan.className = 'message-actions';
                                copySpan.setAttribute('title', '复制');
                                copySpan.textContent = '📋复制';
                                mainContent.appendChild(copySpan);
                                
                                // 添加重新生成按钮
                                const regenerateSpan = document.createElement('span');
                                regenerateSpan.className = 'message-actions';
                                regenerateSpan.setAttribute('title', '重新生成');
                                regenerateSpan.textContent = '🔄重新生成';
                                regenerateSpan.style.marginLeft = '15px';
                                mainContent.appendChild(regenerateSpan);
                            }
                            
                            // 为思考过程添加复制按钮
                            const reasoningContent = aiMessageElement.querySelector('.reasoning-content');
                            if (reasoningContent && reasoningContent.style.display !== 'none') {
                                const reasoningHeader = reasoningContent.parentElement.querySelector('.reasoning-header');
                                if (reasoningHeader && !reasoningHeader.querySelector('.reasoning-copy')) {
                                    const copySpan = document.createElement('span');
                                    copySpan.className = 'reasoning-copy';
                                    copySpan.setAttribute('title', '复制思考过程');
                                    copySpan.textContent = '📋';
                                    copySpan.style.cursor = 'pointer';
                                    copySpan.style.marginLeft = '10px';
                                    reasoningHeader.appendChild(copySpan);
                                    
                                    // 添加思考过程复制功能
                                    copySpan.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        const reasoningText = reasoningContent.querySelector('p').textContent;
                                        this.copyToClipboard(reasoningText.trim(), '思考过程');
                                    });
                                }
                            }
                            
                            // 更新消息的原始内容属性
                            const combinedContent = reasoningContent ? `思考过程：\n${reasoningContent.querySelector('p').textContent}\n\n回答：\n${fullContent}` : fullContent;
                            aiMessageElement.setAttribute('data-original-content', combinedContent);
                            
                            // 添加复制功能
                            this.addCopyFunctionality(aiMessageElement);
                            
                            // 将AI回复添加到历史记录
                            if (fullAIResponse.trim()) {
                                this.addToHistory('assistant', fullAIResponse);
                            }
                            this.stopGeneration();
                        }
                    } catch (error) {
                        console.log('捕获到错误:', error);
                        
                        // 检查是否是因为取消导致的错误
                        if (error.name === 'AbortError' || this.abortController?.signal.aborted) {
                            console.log('API调用被用户取消');
                            // 不显示错误消息，因为用户主动取消
                            // 保持已生成的消息不变
                            // 将临时消息标记为永久消息，防止被清除
                            if (aiMessageElement) {
                                aiMessageElement.classList.remove('temporary-message');
                                aiMessageElement.removeAttribute('data-temporary');
                                // 更新原始内容属性（包含思考过程和正常内容）
                                const combinedContent = reasoningContent ? `思考过程：\n${reasoningContent}\n\n回答：\n${fullContent}` : fullContent;
                                aiMessageElement.setAttribute('data-original-content', combinedContent);
                            }
                            
                            // 如果有部分回复，添加到历史记录
                            if (fullAIResponse.trim()) {
                                this.addToHistory('assistant', fullAIResponse);
                            }
                            
                            // 添加复制按钮到主内容区域
                            const mainContent = aiMessageElement.querySelector('.main-content p');
                            if (mainContent && !mainContent.querySelector('.message-actions')) {
                                const copySpan = document.createElement('span');
                                copySpan.className = 'message-actions';
                                copySpan.setAttribute('title', '复制');
                                copySpan.textContent = '📋复制';
                                mainContent.appendChild(copySpan);
                                
                                // 添加重新生成按钮
                                const regenerateSpan = document.createElement('span');
                                regenerateSpan.className = 'message-actions';
                                regenerateSpan.setAttribute('title', '重新生成');
                                regenerateSpan.textContent = '🔄重新生成';
                                regenerateSpan.style.marginLeft = '15px';
                                mainContent.appendChild(regenerateSpan);
                            }
                            
                            // 为思考过程添加复制按钮
                            const reasoningContent = aiMessageElement.querySelector('.reasoning-content');
                            if (reasoningContent && reasoningContent.style.display !== 'none') {
                                const reasoningHeader = reasoningContent.parentElement.querySelector('.reasoning-header');
                                if (reasoningHeader && !reasoningHeader.querySelector('.reasoning-copy')) {
                                    const copySpan = document.createElement('span');
                                    copySpan.className = 'reasoning-copy';
                                    copySpan.setAttribute('title', '复制思考过程');
                                    copySpan.textContent = '📋';
                                    copySpan.style.cursor = 'pointer';
                                    copySpan.style.marginLeft = '10px';
                                    reasoningHeader.appendChild(copySpan);
                                    
                                    // 添加思考过程复制功能
                                    copySpan.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        const reasoningText = reasoningContent.querySelector('p').textContent;
                                        this.copyToClipboard(reasoningText.trim(), '思考过程');
                                    });
                                }
                            }
                            
                            // 更新消息的原始内容属性
                            const reasoningText = reasoningContent ? reasoningContent.querySelector('p').textContent : '';
                            const combinedContent = reasoningText ? `思考过程：\n${reasoningText}\n\n回答：\n${fullContent}` : fullContent;
                            aiMessageElement.setAttribute('data-original-content', combinedContent);
                            
                            // 添加复制功能
                            this.addCopyFunctionality(aiMessageElement);
                            return;
                        }
                        
                        // 停止生成但不移除已显示的消息
                        this.stopGeneration();
                        
                        // 将临时消息标记为永久消息，防止被清除
                        if (aiMessageElement) {
                            aiMessageElement.classList.remove('temporary-message');
                            aiMessageElement.removeAttribute('data-temporary');
                            // 更新原始内容属性（包含思考过程和正常内容）
                            const combinedContent = reasoningContent ? `思考过程：\n${reasoningContent}\n\n回答：\n${fullContent}` : fullContent;
                            aiMessageElement.setAttribute('data-original-content', combinedContent);
                        }
                        
                        // 如果有部分回复且不是被用户取消的，添加到历史记录
                        if (fullAIResponse.trim() && !this.abortController?.signal.aborted) {
                            this.addToHistory('assistant', fullAIResponse);
                        }
                        
                        // 添加复制按钮到主内容区域
                        const mainContent = aiMessageElement.querySelector('.main-content p');
                        if (mainContent && !mainContent.querySelector('.message-actions')) {
                            const copySpan = document.createElement('span');
                            copySpan.className = 'message-actions';
                            copySpan.setAttribute('title', '复制');
                            copySpan.textContent = '📋复制';
                            mainContent.appendChild(copySpan);
                            
                            // 添加重新生成按钮
                            const regenerateSpan = document.createElement('span');
                            regenerateSpan.className = 'message-actions';
                            regenerateSpan.setAttribute('title', '重新生成');
                            regenerateSpan.textContent = '🔄重新生成';
                            regenerateSpan.style.marginLeft = '15px';
                            mainContent.appendChild(regenerateSpan);
                        }
                        
                        // 为思考过程添加复制按钮
                        const reasoningContent = aiMessageElement.querySelector('.reasoning-content');
                        if (reasoningContent && reasoningContent.style.display !== 'none') {
                            const reasoningHeader = reasoningContent.parentElement.querySelector('.reasoning-header');
                            if (reasoningHeader && !reasoningHeader.querySelector('.reasoning-copy')) {
                                const copySpan = document.createElement('span');
                                copySpan.className = 'reasoning-copy';
                                copySpan.setAttribute('title', '复制思考过程');
                                copySpan.textContent = '📋';
                                copySpan.style.cursor = 'pointer';
                                copySpan.style.marginLeft = '10px';
                                reasoningHeader.appendChild(copySpan);
                                
                                // 添加思考过程复制功能
                                copySpan.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    const reasoningText = reasoningContent.querySelector('p').textContent;
                                    this.copyToClipboard(reasoningText.trim(), '思考过程');
                                });
                            }
                        }
                        
                        // 更新消息的原始内容属性
                        const reasoningText = reasoningContent ? reasoningContent.querySelector('p').textContent : '';
                        const combinedContent = reasoningText ? `思考过程：\n${reasoningText}\n\n回答：\n${fullContent}` : fullContent;
                        aiMessageElement.setAttribute('data-original-content', combinedContent);
                        
                        // 添加复制功能
                        this.addCopyFunctionality(aiMessageElement);
                        
                        // 显示错误信息，但不移除已生成的消息
                        this.addMessage(`API调用失败: ${error.message}\n\n提示：请检查API配置或网络连接。`, 'ai');
                    }
                },

                // 显示AI思考中的加载动画
                showThinkingIndicator() {
                    // 检查是否已存在思考指示器
                    if (document.querySelector('.thinking-indicator')) {
                        return;
                    }

                    const thinkingDiv = document.createElement('div');
                    thinkingDiv.className = 'thinking-indicator';
                    thinkingDiv.innerHTML = `
                        <span class="ai-avatar">🤖</span>
                        <span>AI正在思考</span>
                        <div class="thinking-dots">
                            <div class="thinking-dot"></div>
                            <div class="thinking-dot"></div>
                            <div class="thinking-dot"></div>
                        </div>
                    `;
                    
                    App.elements.chatMessages.appendChild(thinkingDiv);
                    App.elements.chatMessages.scrollTop = App.elements.chatMessages.scrollHeight;
                },

                // 隐藏AI思考中的加载动画
                hideThinkingIndicator() {
                    const thinkingIndicator = document.querySelector('.thinking-indicator');
                    if (thinkingIndicator) {
                        thinkingIndicator.remove();
                    }
                },

                addMessage(content, sender, isTemporary = false) {
                    const messageDiv = document.createElement('div');
                    messageDiv.className = sender === 'user' ? 'user-message' : 'ai-message';
                    
                    // 生成唯一消息ID
                    const messageId = Date.now().toString() + Math.random().toString(36).substring(2);
                    messageDiv.setAttribute('data-message-id', messageId);
                    
                    // 如果是临时消息，添加特殊标记
                    if (isTemporary) {
                        messageDiv.classList.add('temporary-message');
                        messageDiv.setAttribute('data-temporary', 'true');
                    }
                    
                    // 添加停止时的保护标记
                    if (this.isGenerating) {
                        messageDiv.setAttribute('data-protected', 'true');
                    }
                    
                    // 存储原始内容，用于复制
                    messageDiv.setAttribute('data-original-content', content);
                    
                    // 检查消息是否过长，仅对用户消息添加折叠功能
                    const isLongMessage = sender === 'user' && content.length > 200;
                    const messageClass = isLongMessage ? 'collapsed-message' : '';
                    
                    // 处理长文本，确保正确换行，保留Markdown格式
                    const processedContent = content
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;');
                    
                    // 处理换行和空格，但保留Markdown格式
                    const formattedContent = processedContent
                        .replace(/\n/g, '<br>')
                        .replace(/  /g, '&nbsp;&nbsp;');
                    
                    if (sender === 'user') {
                        // 将折叠功能移到消息文字的正上方，头像移到最右边
                        messageDiv.innerHTML = `
                            <div class="user-content ${messageClass}">
                                ${isLongMessage ? '<div class="expand-controls"><span class="message-actions" title="复制">📋复制</span><span class="message-action-icon expand-toggle" title="展开">v</span> <span class="expand-indicator">点击 v 展开完整内容</span></div>' : ''}
                                <p>${formattedContent}${!isLongMessage ? '<span class="message-actions" title="复制">📋复制</span> <span class="message-actions" title="编辑" style="margin-left: 15px;">✏️编辑</span>' : ''}</p>
                            </div>
                            <span class="user-avatar">👤</span>
                        `;
                    } else {
                        // AI消息结构，包含思考过程和正常内容的容器
                        messageDiv.innerHTML = `
                            <span class="ai-avatar">🤖</span>
                            <div class="message-content">
                                <!-- 正常内容容器 -->
                                <div class="main-content">
                                    <p>${formattedContent}</p>
                                </div>
                            </div>
                        `;
                    }
                    
                    App.elements.chatMessages.appendChild(messageDiv);
                    // 使用智能滚动而不是强制滚动
                    this.smartScrollToBottom();
                    
                    // 添加复制功能
                    this.addCopyFunctionality(messageDiv);
                    
                    // 添加展开/折叠功能（仅用户消息）
                    if (isLongMessage) {
                        this.addToggleFunctionality(messageDiv);
                    }
                    
                    // 返回消息ID，用于可能的后续操作（如删除临时消息）
                    return messageId;
                },
                
                // 更新思考过程内容
                updateReasoningContent(aiMessageElement, content) {
                    if (!aiMessageElement) return;
                    
                    // 查找或创建思考过程容器
                    let reasoningContainer = aiMessageElement.querySelector('.reasoning-container');
                    let reasoningContentElement = reasoningContainer?.querySelector('.reasoning-content p');
                    
                    // 如果思考过程容器不存在，创建它
                    if (!reasoningContainer) {
                        const messageContent = aiMessageElement.querySelector('.message-content');
                        if (messageContent) {
                            // 创建思考过程容器
                            reasoningContainer = document.createElement('div');
                            reasoningContainer.className = 'reasoning-container';
                            reasoningContainer.style.display = 'block'; // 确保容器可见
                            reasoningContainer.innerHTML = `
                                <div class="reasoning-header">
                                    <span class="reasoning-toggle">^</span>
                                    <span class="reasoning-title">思考过程</span>
                                </div>
                                <div class="reasoning-content" style="display: block;">
                                    <p></p>
                                </div>
                            `;
                            
                            // 将思考过程容器插入到正常内容之前
                            const mainContent = messageContent.querySelector('.main-content');
                            if (mainContent) {
                                messageContent.insertBefore(reasoningContainer, mainContent);
                            } else {
                                // 如果没有主内容容器，直接添加
                                messageContent.appendChild(reasoningContainer);
                            }
                            
                            reasoningContentElement = reasoningContainer.querySelector('.reasoning-content p');
                            
                            // 添加折叠/展开功能
                            this.addReasoningToggleFunctionality(reasoningContainer);
                        }
                    }
                    
                    // 更新思考过程内容
                    if (reasoningContentElement && content && content.trim()) {
                        // 使用文本节点追加内容，与正常内容处理方式保持一致
                        if (!reasoningContentElement.textContent) {
                            reasoningContentElement.textContent = content;
                        } else {
                            reasoningContentElement.textContent += content;
                        }
                        
                        // 显示思考过程容器和内容
                        reasoningContainer.style.display = 'block';
                        const reasoningContent = reasoningContainer.querySelector('.reasoning-content');
                        if (reasoningContent) {
                            reasoningContent.style.display = 'block';
                        }
                        
                        // 确保思考过程有复制按钮
                        const reasoningHeader = reasoningContainer.querySelector('.reasoning-header');
                        if (reasoningHeader && !reasoningHeader.querySelector('.reasoning-copy')) {
                            const copySpan = document.createElement('span');
                            copySpan.className = 'reasoning-copy';
                            copySpan.setAttribute('title', '复制思考过程');
                            copySpan.textContent = '📋';
                            copySpan.style.cursor = 'pointer';
                            copySpan.style.marginLeft = '10px';
                            reasoningHeader.appendChild(copySpan);
                            
                            // 添加思考过程复制功能
                            copySpan.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const reasoningText = reasoningContentElement.textContent;
                                this.copyToClipboard(reasoningText.trim(), '思考过程');
                            });
                        }
                        
                        // 滚动到底部
                        //App.elements.chatMessages.scrollTop = App.elements.chatMessages.scrollHeight;
                    }
                },
                
                // 添加思考过程折叠/展开功能
                addReasoningToggleFunctionality(reasoningContainer) {
                    const toggle = reasoningContainer.querySelector('.reasoning-toggle');
                    const content = reasoningContainer.querySelector('.reasoning-content');
                    const header = reasoningContainer.querySelector('.reasoning-header');
                    
                    if (toggle && content && header) {
                        // 添加回展按钮
                        if (!header.querySelector('.reasoning-track')) {
                            const trackSpan = document.createElement('span');
                            trackSpan.className = 'reasoning-track';
                            trackSpan.setAttribute('title', '回展位置');
                            trackSpan.textContent = '↩';
                            trackSpan.style.cursor = 'pointer';
                            trackSpan.style.marginLeft = '10px';
                            trackSpan.style.fontSize = '14px';
                            header.appendChild(trackSpan);
                            
                            // 添加回展功能 - 记录整个AI消息元素的位置
                            trackSpan.addEventListener('click', (e) => {
                                e.stopPropagation();
                                // 记录整个AI消息元素的位置（而不是仅仅思考过程容器）
                                const aiMessageElement = reasoningContainer.closest('.ai-message');
                                if (aiMessageElement) {
                                    App.chatTracking.trackExpandedMessage(aiMessageElement);
                                }
                                
                                // 滚动到思考过程位置
                                const messageRect = reasoningContainer.getBoundingClientRect();
                                const chatMessages = App.elements.chatMessages;
                                const chatRect = chatMessages.getBoundingClientRect();
                                
                                // 计算思考过程相对于聊天容器的位置
                                const relativeTop = messageRect.top - chatRect.top + chatMessages.scrollTop;
                                
                                // 平滑滚动到思考过程位置
                                chatMessages.scrollTo({
                                    top: relativeTop - 50, // 稍微向上偏移，确保思考过程完全可见
                                    behavior: 'smooth'
                                });
                                
                                // 添加视觉反馈
                                App.chatTracking.addVisualFeedback(reasoningContainer);
                            });
                        }
                        
                        // 为整个header添加点击展开/关闭功能，并记录位置
                        header.addEventListener('click', (e) => {
                            // 如果点击的是回展按钮或复制按钮，不触发展开/关闭
                            if (e.target.classList.contains('reasoning-track') || e.target.classList.contains('reasoning-copy')) {
                                return;
                            }
                            
                            e.stopPropagation();
                            
                            // 记录整个AI消息元素的位置，无论展开还是折叠
                            const aiMessageElement = reasoningContainer.closest('.ai-message');
                            if (aiMessageElement) {
                                App.chatTracking.trackExpandedMessage(aiMessageElement);
                            }
                            
                            if (content.style.display === 'none') {
                                // 展开思考过程
                                content.style.display = 'block';
                                toggle.textContent = '^';
                                toggle.setAttribute('title', '回展位置');
                            } else {
                                // 折叠思考过程
                                content.style.display = 'none';
                                toggle.textContent = '>';
                                toggle.setAttribute('title', '展开思考过程');
                            }
                        });
                        
                        // 修改toggle按钮点击功能，使其也能记录位置
                        toggle.addEventListener('click', (e) => {
                            e.stopPropagation();
                            
                            // 记录整个AI消息元素的位置
                            const aiMessageElement = reasoningContainer.closest('.ai-message');
                            if (aiMessageElement) {
                                App.chatTracking.trackExpandedMessage(aiMessageElement);
                            }
                            
                            if (content.style.display === 'none') {
                                // 展开思考过程
                                content.style.display = 'block';
                                toggle.textContent = '^';
                                toggle.setAttribute('title', '回展位置');
                            } else {
                                // 折叠思考过程
                                content.style.display = 'none';
                                toggle.textContent = '>';
                                toggle.setAttribute('title', '展开思考过程');
                            }
                        });
                    }
                },
                
                removeMessage(messageId) {
                    // 通过查找包含指定ID的消息来删除
                    const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                    if (messageElement) {
                        messageElement.remove();
                    }
                },
                
                copyToClipboard(text, type = '内容') {
                    try {
                        navigator.clipboard.writeText(text).then(() => {
                            App.calculator.showSuccessMessage(`已复制${type}到剪贴板！`);
                        }).catch(err => {
                            // 降级方案
                            const textArea = document.createElement('textarea');
                            textArea.value = text;
                            document.body.appendChild(textArea);
                            textArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textArea);
                            App.calculator.showSuccessMessage(`已复制${type}到剪贴板！`);
                        });
                    } catch (err) {
                        console.error('复制失败:', err);
                        App.calculator.showSuccessMessage('复制失败，请手动复制');
                    }
                },

                addCopyFunctionality(messageDiv) {
                    // 复制功能
                    const copyAction = messageDiv.querySelector('.message-actions[title="复制"]');
                    if (copyAction) {
                        copyAction.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            // 获取主内容区域，不包含思考过程
                            const mainContent = messageDiv.querySelector('.main-content p');
                            if (mainContent) {
                                // 获取主内容的文本，去除HTML标签和复制按钮
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = mainContent.innerHTML;
                                // 移除复制按钮
                                const copyButtons = tempDiv.querySelectorAll('.message-actions');
                                copyButtons.forEach(btn => btn.remove());
                                // 获取纯文本内容
                                const messageText = tempDiv.textContent || tempDiv.innerText || '';
                                
                                this.copyToClipboard(messageText.trim(), '回复内容');
                            }
                        });
                    }
                    
                    // 编辑功能 - 仅用户消息
                    const editAction = messageDiv.querySelector('.message-actions[title="编辑"]');
                    if (editAction) {
                        editAction.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            
                            // 获取用户消息内容
                            const userContent = messageDiv.querySelector('.user-content p');
                            if (userContent) {
                                // 获取纯文本内容，去除HTML标签和按钮
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = userContent.innerHTML;
                                // 移除所有按钮
                                const buttons = tempDiv.querySelectorAll('.message-actions, .message-action-icon, .expand-indicator');
                                buttons.forEach(btn => btn.remove());
                                // 获取纯文本内容
                                const messageText = tempDiv.textContent || tempDiv.innerText || '';
                                
                                // 将内容放入输入框
                                App.elements.chatInput.value = messageText.trim();
                                App.elements.chatInput.focus();
                                
                                // 触发input事件以调整高度
                                App.elements.chatInput.dispatchEvent(new Event('input'));
                                
                                // 设置编辑模式，但不立即删除后续消息
                                this.isEditing = true;
                                this.editingMessageId = messageDiv.getAttribute('data-message-id');
                                
                                // 添加视觉提示，标记正在编辑的消息
                                messageDiv.style.border = '2px dashed rgba(241, 196, 15, 0.8)';
                                messageDiv.style.borderRadius = '8px';
                                messageDiv.style.padding = '5px';
                                messageDiv.style.backgroundColor = 'rgba(241, 196, 15, 0.1)';
                                
                                // 显示取消编辑的提示
                                App.calculator.showSuccessMessage('正在编辑消息，按 ESC 或点击外部区域取消编辑');
                                
                                // 更新输入框占位符
                                App.elements.chatInput.placeholder = '编辑中... 按 ESC 取消编辑';
                            }
                        });
                    }
                    
                    // 重新生成功能 - 仅AI消息
                    const regenerateAction = messageDiv.querySelector('.message-actions[title="重新生成"]');
                    if (regenerateAction) {
                        regenerateAction.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            
                            // 找到对应的用户消息
                            const userMessage = this.findPreviousUserMessage(messageDiv);
                            if (userMessage) {
                                // 获取用户消息内容
                                const userContent = userMessage.querySelector('.user-content p');
                                if (userContent) {
                                    const tempDiv = document.createElement('div');
                                    tempDiv.innerHTML = userContent.innerHTML;
                                    // 移除所有按钮
                                    const buttons = tempDiv.querySelectorAll('.message-actions, .message-action-icon, .expand-indicator');
                                    buttons.forEach(btn => btn.remove());
                                    // 获取纯文本内容
                                    const messageText = tempDiv.textContent || tempDiv.innerText || '';
                                    
                                    // 删除当前AI消息及其之后的所有消息（与编辑功能保持一致）
                                    this.removeMessagesAfter(userMessage);
                                    
                                    // 重新生成AI回复
                                    this.regenerateAIResponse(messageText.trim());
                                }
                            }
                        });
                    }
                },
                
                addToggleFunctionality(messageDiv) {
                    const toggleIcon = messageDiv.querySelector('.expand-toggle');
                    const userContent = messageDiv.querySelector('.user-content');
                    const expandIndicator = messageDiv.querySelector('.expand-indicator');
                    
                    if (toggleIcon && userContent) {
                        toggleIcon.addEventListener('click', (e) => {
                            e.stopPropagation();
                            
                            // 跟踪当前消息元素
                            App.chatTracking.trackExpandedMessage(messageDiv);
                            
                            if (userContent.classList.contains('collapsed-message')) {
                                // 展开消息
                                userContent.classList.remove('collapsed-message');
                                toggleIcon.textContent = 'v';
                                toggleIcon.setAttribute('title', '折叠');
                                if (expandIndicator) {
                                    expandIndicator.textContent = '点击 v 折叠内容';
                                }
                            } else {
                                // 折叠消息
                                userContent.classList.add('collapsed-message');
                                toggleIcon.textContent = 'v';
                                toggleIcon.setAttribute('title', '展开');
                                if (expandIndicator) {
                                    expandIndicator.textContent = '点击 v 展开完整内容';
                                }
                            }
                        });
                        
                        if (expandIndicator) {
                            expandIndicator.addEventListener('click', (e) => {
                                e.stopPropagation();
                                toggleIcon.click();
                            });
                        }
                    }
                },

                // 删除指定消息之后的所有消息
                removeMessagesAfter(messageDiv) {
                    // 找到当前消息之后的所有消息
                    let nextElement = messageDiv.nextElementSibling;
                    const messagesToRemove = [];
                    
                    // 收集需要删除的消息
                    while (nextElement) {
                        if (nextElement.classList.contains('ai-message') || nextElement.classList.contains('user-message')) {
                            messagesToRemove.push(nextElement);
                            nextElement = nextElement.nextElementSibling;
                        } else {
                            break;
                        }
                    }
                    
                    // 删除收集到的消息
                    messagesToRemove.forEach(msg => msg.remove());
                    
                    // 从历史记录中移除相关消息
                    if (messagesToRemove.length > 0) {
                        // 移除最后几条历史记录
                        this.conversationHistory = this.conversationHistory.slice(0, -messagesToRemove.length);
                    }
                },
                
                // 编辑后更新历史记录
                updateHistoryAfterEdit(messageId, newContent) {
                    // 获取编辑的消息元素
                    const editingMessageElement = document.querySelector(`[data-message-id="${messageId}"]`);
                    if (!editingMessageElement) return;
                    
                    // 找到这个消息元素在聊天界面中的位置
                    let position = 0;
                    let currentElement = App.elements.chatMessages.firstElementChild;
                    
                    while (currentElement) {
                        if (currentElement === editingMessageElement) {
                            break;
                        }
                        if (currentElement.classList.contains('user-message') || currentElement.classList.contains('ai-message')) {
                            position++;
                        }
                        currentElement = currentElement.nextElementSibling;
                    }
                    
                    // 计算在历史记录数组中的对应位置
                    let historyIndex = 0;
                    let userMessageCount = 0;
                    
                    // 遍历历史记录，找到第N个用户消息的位置
                    for (let i = 0; i < this.conversationHistory.length; i++) {
                        if (this.conversationHistory[i].role === 'user') {
                            if (userMessageCount === Math.floor(position / 2)) {
                                historyIndex = i;
                                break;
                            }
                            userMessageCount++;
                        }
                    }
                    
                    // 更新对应位置的历史记录
                    if (historyIndex < this.conversationHistory.length && 
                        this.conversationHistory[historyIndex].role === 'user') {
                        this.conversationHistory[historyIndex].content = newContent;
                    }
                },
                
                // 确保用户消息在历史记录末尾
                ensureUserMessageAtEnd(message) {
                    // 检查是否是数学相关问题，如果是，添加当前表达式上下文
                    let enhancedMessage = message;
                    const currentExpression = App.elements.expressionInput.value.trim();
                    const currentOperation = App.elements.operationSelect.value;
                    
                    if (currentExpression && this.isMathRelatedQuestion(message)) {
                        enhancedMessage = `${message}\n\n当前计算器中的表达式: ${currentExpression}\n计算类型: ${this.getOperationName(currentOperation)}`;
                    }
                    
                    // 检查历史记录的最后一条是否是用户消息且内容匹配
                    const lastHistoryEntry = this.conversationHistory[this.conversationHistory.length - 1];
                    if (!lastHistoryEntry || lastHistoryEntry.role !== 'user' || lastHistoryEntry.content !== enhancedMessage) {
                        // 如果不匹配，将用户消息添加到历史记录末尾
                        this.addToHistory('user', enhancedMessage);
                    }
                },
                
                // 编辑用户消息功能（保留以备后用）
                editUserMessage(userMessageDiv) {
                    // 找到当前用户消息之后的所有消息
                    let nextElement = userMessageDiv.nextElementSibling;
                    const messagesToRemove = [];
                    
                    // 收集需要删除的消息
                    while (nextElement) {
                        if (nextElement.classList.contains('ai-message') || nextElement.classList.contains('user-message')) {
                            messagesToRemove.push(nextElement);
                            nextElement = nextElement.nextElementSibling;
                        } else {
                            break;
                        }
                    }
                    
                    // 删除收集到的消息
                    messagesToRemove.forEach(msg => msg.remove());
                    
                    // 从历史记录中移除相关消息
                    if (messagesToRemove.length > 0) {
                        // 移除最后几条历史记录
                        this.conversationHistory = this.conversationHistory.slice(0, -messagesToRemove.length);
                    }
                },
                
                // 查找消息在历史记录中的索引
                findMessageIndexInHistory(messageDiv, role) {
                    // 获取消息元素在聊天界面中的位置
                    let position = 0;
                    let currentElement = App.elements.chatMessages.firstElementChild;
                    
                    while (currentElement) {
                        if (currentElement === messageDiv) {
                            break;
                        }
                        if (currentElement.classList.contains('user-message') || currentElement.classList.contains('ai-message')) {
                            position++;
                        }
                        currentElement = currentElement.nextElementSibling;
                    }
                    
                    // 计算在历史记录数组中的对应位置
                    let historyIndex = 0;
                    let roleMessageCount = 0;
                    
                    // 遍历历史记录，找到第N个指定角色的消息的位置
                    for (let i = 0; i < this.conversationHistory.length; i++) {
                        if (this.conversationHistory[i].role === role) {
                            if (roleMessageCount === Math.floor(position / 2)) {
                                historyIndex = i;
                                break;
                            }
                            roleMessageCount++;
                        }
                    }
                    
                    return historyIndex;
                },

                // 重新生成AI回复功能
                async regenerateAIResponse(userMessage) {
                    // 检查用户消息是否已在历史记录中，如果没有则添加
                    const lastHistoryEntry = this.conversationHistory[this.conversationHistory.length - 1];
                    if (!lastHistoryEntry || lastHistoryEntry.role !== 'user' || lastHistoryEntry.content !== userMessage) {
                        // 检查是否是数学相关问题，如果是，添加当前表达式上下文
                        let enhancedMessage = userMessage;
                        const currentExpression = App.elements.expressionInput.value.trim();
                        const currentOperation = App.elements.operationSelect.value;
                        
                        if (currentExpression && this.isMathRelatedQuestion(userMessage)) {
                            enhancedMessage = `${userMessage}\n\n当前计算器中的表达式: ${currentExpression}\n计算类型: ${this.getOperationName(currentOperation)}`;
                        }
                        
                        // 将用户消息添加到历史记录
                        this.addToHistory('user', enhancedMessage);
                    }
                    
                    // 开始生成
                    this.startGeneration();
                    
                    // 构建包含历史上下文的消息（不重复添加用户消息）
                    const contextualMessages = this.buildContextualMessageWithoutUser(userMessage);
                    
                    try {
                        // 调用流式API
                        await this.callStreamAPI(contextualMessages);
                    } catch (error) {
                        console.log('重新生成时捕获到错误:', error);
                        
                        // 检查是否是因为取消导致的错误
                        if (error.name === 'AbortError' || this.abortController?.signal.aborted) {
                            console.log('API调用被用户取消');
                            return;
                        }
                        
                        // 停止生成
                        this.stopGeneration();
                        
                        // 显示错误信息
                        this.addMessage(`API调用失败: ${error.message}\n\n提示：请检查API配置或网络连接。`, 'ai');
                    }
                },
                
                // 查找前一个用户消息
                findPreviousUserMessage(aiMessageDiv) {
                    let prevElement = aiMessageDiv.previousElementSibling;
                    
                    // 向前查找用户消息
                    while (prevElement) {
                        if (prevElement.classList.contains('user-message')) {
                            return prevElement;
                        }
                        prevElement = prevElement.previousElementSibling;
                    }
                    
                    return null;
                },

                generateAIResponse(userMessage) {
                    const responses = [
                        "我理解您的问题。让我帮您分析一下...",
                        "这是一个很好的问题！根据我的分析...",
                        "我来为您提供一些有用的信息...",
                        "让我思考一下如何最好地帮助您...",
                        "基于您的需求，我建议..."
                    ];
                    return responses[Math.floor(Math.random() * responses.length)];
                }
            },

            // 事件处理
            events: {
                setup() {
                    // 初始化显示
                    App.elements.volumeValue.textContent = `${App.elements.volumeControl.value}%`;
                    App.elements.vibrationValue.textContent = App.elements.vibrationStrength.value;

                    // 音量控制
                    App.elements.volumeControl.addEventListener('input', () => {
                        App.elements.volumeValue.textContent = `${App.elements.volumeControl.value}%`;
                        if (App.audio.gainNode) {
                            App.audio.gainNode.value = App.elements.volumeControl.value / 100 * 0.2;
                        }
                    });

                    // 震动强度控制
                    App.elements.vibrationStrength.addEventListener('input', () => {
                        App.elements.vibrationValue.textContent = App.elements.vibrationStrength.value;
                    });

                    // 设置按钮
                    App.elements.settingsButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        App.vibration.trigger(App.elements.vibrateMode.value);
                        App.elements.settingsPanel.classList.toggle('active');
                    });

                    // 搜索按钮
                    App.elements.searchButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        App.vibration.trigger(App.elements.vibrateMode.value);
                        App.elements.searchPanel.classList.toggle('active');
                        App.search.updateHistory();
                    });

                    // AIOS按钮
                    App.elements.aiosButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        App.vibration.trigger(App.elements.vibrateMode.value);
                        const isActive = App.elements.aiosPanel.classList.toggle('active');
                        
                        // 显示或隐藏关闭按钮
                        if (isActive) {
                            App.elements.closeAiosLeftBtn.style.display = 'flex';
                            App.elements.closeAiosRightBtn.style.display = 'flex';
                        } else {
                            App.elements.closeAiosLeftBtn.style.display = 'none';
                            App.elements.closeAiosRightBtn.style.display = 'none';
                        }
                    });

                    // AIOS聊天功能已在setupSendButton中处理
                    
                    // 添加键盘快捷键支持
                    App.elements.chatInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && e.ctrlKey) {
                            e.preventDefault();
                            App.chat.sendMessage();
                        } else if (e.key === 'Escape') {
                            // ESC键停止生成或取消编辑
                            e.preventDefault();
                            if (App.chat.isGenerating) {
                                App.chat.stopGeneration();
                            } else if (App.chat.isEditing) {
                                App.chat.cancelEdit();
                            }
                        } else if (e.key === 'Enter' && e.shiftKey) {
                            // Shift+Enter发送消息
                            e.preventDefault();
                            App.chat.sendMessage();
                        } else if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey) {
                            // 普通回车换行，不发送
                            return;
                        }
                    });
                    
                    // 自动调整输入框高度
                    App.elements.chatInput.addEventListener('input', function() {
                        this.style.height = 'auto';
                        this.style.height = Math.min(this.scrollHeight, 120) + 'px';
                    });
                    
                    // 点击外部区域取消编辑
                    document.addEventListener('click', (e) => {
                        // 如果处于编辑模式
                        if (App.chat.isEditing) {
                            // 检查点击是否在聊天输入框或正在编辑的消息内
                            const isClickInInput = App.elements.chatInput.contains(e.target);
                            const isClickInEditingMessage = App.chat.editingMessageId && 
                                document.querySelector(`[data-message-id="${App.chat.editingMessageId}"]`)?.contains(e.target);
                            
                            // 如果点击不在输入框或编辑的消息内，则取消编辑
                            if (!isClickInInput && !isClickInEditingMessage) {
                                App.chat.cancelEdit();
                            }
                        }
                    });

                    // 数学快捷输入按钮事件
                    document.querySelectorAll('.math-shortcut').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const formula = this.getAttribute('data-formula');
                            const chatInput = App.elements.chatInput;
                            const start = chatInput.selectionStart;
                            const end = chatInput.selectionEnd;
                            const text = chatInput.value;
                            
                            // 在光标位置插入公式
                            chatInput.value = text.substring(0, start) + formula + text.substring(end);
                            chatInput.selectionStart = chatInput.selectionEnd = start + formula.length;
                            chatInput.focus();
                            
                            // 触发input事件以调整高度
                            chatInput.dispatchEvent(new Event('input'));
                            
                            App.audio.play(...App.elements.soundType.value.split(':'));
                        });
                    });


                    // API配置保存
                    App.elements.apiSaveBtn.addEventListener('click', async () => {
                        // 获取模型值，如果是自定义则使用输入框的值
                        let modelValue = App.elements.apiModel.value.trim();
                        if (modelValue === 'custom') {
                            modelValue = App.elements.customModel.value.trim();
                        }
                        
                        const config = {
                            url: App.elements.apiUrl.value.trim(),
                            key: App.elements.apiKey.value.trim(),
                            model: modelValue,
                            temperature: parseFloat(App.elements.apiTemperature.value),
                            maxTokens: parseInt(App.elements.apiMaxTokens.value)
                        };
                        
                        // 验证配置
                        if (!config.url || !config.key || !config.model) {
                            App.calculator.showSuccessMessage('请填写完整的API配置信息！');
                            return;
                        }
                        
                        // 显示保存中状态
                        App.elements.apiSaveBtn.textContent = '保存中...';
                        App.elements.apiSaveBtn.disabled = true;
                        
                        try {
                            // 测试API连接
                            const testResult = await App.apiConfig.testConnection(config);
                            
                            if (App.apiConfig.saveConfig(config)) {
                                App.calculator.showSuccessMessage('API配置已保存并连接成功！');
                                // 更新连接状态指示器
                                App.updateConnectionStatus(true);
                            } else {
                                App.calculator.showSuccessMessage('保存配置失败，请重试！');
                                App.updateConnectionStatus(false);
                            }
                        } catch (error) {
                            App.calculator.showSuccessMessage(`API连接测试失败: ${error.message}`);
                            App.updateConnectionStatus(false);
                        } finally {
                            // 恢复按钮状态
                            App.elements.apiSaveBtn.textContent = '保存配置';
                            App.elements.apiSaveBtn.disabled = false;
                        }
                        
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // 测试API连接按钮
                    App.elements.apiTestBtn.addEventListener('click', async () => {
                        // 获取模型值，如果是自定义则使用输入框的值
                        let modelValue = App.elements.apiModel.value.trim();
                        if (modelValue === 'custom') {
                            modelValue = App.elements.customModel.value.trim();
                        }
                        
                        const config = {
                            url: App.elements.apiUrl.value.trim(),
                            key: App.elements.apiKey.value.trim(),
                            model: modelValue,
                            temperature: parseFloat(App.elements.apiTemperature.value),
                            maxTokens: parseInt(App.elements.apiMaxTokens.value)
                        };
                        
                        // 验证配置
                        if (!config.url || !config.key || !config.model) {
                            App.calculator.showSuccessMessage('请填写完整的API配置信息！');
                            return;
                        }
                        
                        // 显示测试中状态
                        App.elements.apiTestBtn.textContent = '测试中...';
                        App.elements.apiTestBtn.disabled = true;
                        
                        try {
                            // 测试API连接
                            const testResult = await App.apiConfig.testConnection(config);
                            App.calculator.showSuccessMessage('API连接测试成功！');
                            App.updateConnectionStatus(true);
                        } catch (error) {
                            App.calculator.showSuccessMessage(`API连接测试失败: ${error.message}`);
                            App.updateConnectionStatus(false);
                        } finally {
                            // 恢复按钮状态
                            App.elements.apiTestBtn.textContent = '测试连接';
                            App.elements.apiTestBtn.disabled = false;
                        }
                        
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // API配置重置 - 修改为关闭API面板
                    App.elements.apiResetBtn.addEventListener('click', () => {
                        App.elements.apiPanel.classList.remove('active');
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // AIOS标签页切换
                    document.querySelectorAll('.aios-tab-btn').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const tabName = this.getAttribute('data-tab');
                            
                            // 切换按钮状态
                            document.querySelectorAll('.aios-tab-btn').forEach(b => b.classList.remove('active'));
                            this.classList.add('active');
                            
                            // 切换内容显示
                            document.querySelectorAll('.aios-tab-content').forEach(content => content.classList.remove('active'));
                            const targetTab = document.getElementById(`${tabName}-tab`);
                            if (targetTab) {
                                targetTab.classList.add('active');
                            }
                            
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        });
                    });

                    // AI工具点击事件
                    document.querySelectorAll('.ai-tool-item').forEach(item => {
                        item.addEventListener('click', function() {
                            const toolName = this.querySelector('.tool-name');
                            if (toolName) {
                                const toolNameText = toolName.textContent;
                                App.chat.addMessage(`我想要使用${toolNameText}功能`, 'user');
                                
                                // 根据不同工具提供特定功能
                                setTimeout(() => {
                                    let response = '';
                                    switch(toolNameText) {
                                        case '图像生成':
                                            response = '图像生成功能已启动！请描述您想要生成的图像，例如：\n• "生成一个数学函数的图像"\n• "创建一个几何图形"\n• "绘制一个数据可视化图表"';
                                            break;
                                        case '文本创作':
                                            response = '文本创作功能已启动！请告诉我您想要创作的文本类型，例如：\n• "数学公式解释"\n• "计算步骤说明"\n• "数学概念介绍"';
                                            break;
                                        case '音乐创作':
                                            response = '音乐创作功能已启动！请描述您想要创作的音乐，例如：\n• "生成一段数学节奏音乐"\n• "创建函数相关的旋律"\n• "制作几何图案音乐"';
                                            break;
                                        case '视频编辑':
                                            response = '视频编辑功能已启动！请告诉我您想要编辑的视频内容，例如：\n• "创建数学教学视频"\n• "制作函数动画"\n• "编辑几何演示"';
                                            break;
                                        case '语言翻译':
                                            response = '语言翻译功能已启动！请输入您想要翻译的数学术语或表达式，我将为您提供多语言翻译。';
                                            break;
                                        case '代码生成':
                                            response = '代码生成功能已启动！请告诉我您想要生成的代码类型，例如：\n• "数学计算函数"\n• "数据可视化代码"\n• "算法实现代码"';
                                            break;
                                        default:
                                            response = `${toolNameText}功能已启动！请告诉我您的具体需求。`;
                                    }
                                    App.chat.addMessage(response, 'ai');
                                }, 800);
                                
                                // 切换到聊天标签页
                                document.querySelectorAll('.aios-tab-btn').forEach(b => b.classList.remove('active'));
                                const chatTab = document.querySelector('[data-tab="chat"]');
                                if (chatTab) {
                                    chatTab.classList.add('active');
                                }
                                document.querySelectorAll('.aios-tab-content').forEach(c => c.classList.remove('active'));
                                const chatContent = document.getElementById('chat-tab');
                                if (chatContent) {
                                    chatContent.classList.add('active');
                                }
                                
                                App.audio.play(...App.elements.soundType.value.split(':'));
                                App.vibration.trigger(App.elements.vibrateMode.value);
                            }
                        });
                    });

                    // 数据分析工具按钮点击事件
                    document.querySelectorAll('.aios-tool-btn').forEach(btn => {
                        btn.addEventListener('click', function() {
                            const toolCard = this.closest('.tool-card');
                            if (toolCard) {
                                const toolNameEl = toolCard.querySelector('h4');
                                if (toolNameEl) {
                                    const toolName = toolNameEl.textContent;
                                    
                                    App.chat.addMessage(`我想要使用${toolName}功能`, 'user');
                                    
                                    // 根据不同工具提供特定功能
                                    setTimeout(() => {
                                        let response = '';
                                        let currentExpression = App.elements.expressionInput.value.trim();
                                        
                                        switch(toolName) {
                                            case '数据可视化':
                                                response = '数据可视化功能已启动！我可以帮您：\n\n';
                                                response += '• 绘制函数图像：输入函数表达式，如 "sin(x)" 或 "x^2"\n';
                                                response += '• 创建数据图表：提供数据点，我将生成对应图表\n';
                                                response += '• 数学关系可视化：展示数学概念的可视化表示\n\n';
                                                if (currentExpression) {
                                                    response += `检测到当前表达式：${currentExpression}\n`;
                                                    response += '是否要为这个表达式创建可视化图表？';
                                                } else {
                                                    response += '请在计算器中输入表达式或直接告诉我您想要可视化的内容。';
                                                }
                                                break;
                                            case '智能搜索':
                                                response = '智能搜索功能已启动！我可以帮您：\n\n';
                                                response += '• 搜索数学公式和定理\n';
                                                response += '• 查找函数定义和性质\n';
                                                response += '• 探索数学概念和应用\n';
                                                response += '• 查找解题方法和步骤\n\n';
                                                response += '请告诉我您想要搜索的内容，例如："二次函数公式" 或 "积分定理"';
                                                break;
                                            case '快速计算':
                                                response = '快速计算功能已启动！我可以帮您：\n\n';
                                                response += '• 复杂表达式计算\n';
                                                response += '• 批量数值计算\n';
                                                response += '• 数学统计分析\n';
                                                response += '• 方程求解\n\n';
                                                if (currentExpression) {
                                                    response += `检测到当前表达式：${currentExpression}\n`;
                                                    response += '是否要使用AI增强计算功能来处理这个表达式？';
                                                } else {
                                                    response += '请输入您想要计算的数学表达式或描述您的计算需求。';
                                                }
                                                break;
                                            default:
                                                response = `${toolName}功能已启动！请提供相关数据或具体需求。`;
                                        }
                                        App.chat.addMessage(response, 'ai');
                                    }, 800);
                                    
                                    // 切换到聊天标签页
                                    document.querySelectorAll('.aios-tab-btn').forEach(b => b.classList.remove('active'));
                                    const chatTab = document.querySelector('[data-tab="chat"]');
                                    if (chatTab) {
                                        chatTab.classList.add('active');
                                    }
                                    document.querySelectorAll('.aios-tab-content').forEach(c => c.classList.remove('active'));
                                    const chatContent = document.getElementById('chat-tab');
                                    if (chatContent) {
                                        chatContent.classList.add('active');
                                    }
                                    
                                    App.audio.play(...App.elements.soundType.value.split(':'));
                                    App.vibration.trigger(App.elements.vibrateMode.value);
                                }
                            }
                        });
                    });

                    // 语音交互功能
                    App.elements.voiceBtn.addEventListener('click', () => {
                        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
                            const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
                            recognition.lang = 'zh-CN';
                            recognition.continuous = false;
                            recognition.interimResults = false;

                            recognition.onstart = () => {
                                App.elements.voiceBtn.textContent = '🎤 正在录音...';
                                App.elements.voiceBtn.style.background = 'rgba(231, 76, 60, 0.7)';
                            };

                            recognition.onresult = (event) => {
                                const transcript = event.results[0][0].transcript;
                                App.elements.chatInput.value = transcript;
                                App.chat.sendMessage();
                            };

                            recognition.onerror = () => {
                                App.elements.voiceBtn.textContent = '🎤 语音交互';
                                App.elements.voiceBtn.style.background = '';
                                alert('语音识别失败，请重试');
                            };

                            recognition.onend = () => {
                                App.elements.voiceBtn.textContent = '🎤 语音';
                                App.elements.voiceBtn.style.background = '';
                            };

                            recognition.start();
                        } else {
                            alert('您的浏览器不支持语音识别功能');
                        }
                        
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // 关闭AIOS面板 - 原有按钮
                    App.elements.closeAiosBtn.addEventListener('click', () => {
                        App.elements.aiosPanel.classList.remove('active');
                        App.elements.closeAiosLeftBtn.style.display = 'none';
                        App.elements.closeAiosRightBtn.style.display = 'none';
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // API配置按钮点击事件 - 修复冒泡问题
                    App.elements.apiConfigBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // 阻止事件冒泡
                        App.elements.apiPanel.classList.add('active');
                        App.events.loadApiConfig();
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    // 处理模型选择变化
                    App.elements.apiModel.addEventListener('change', () => {
                        if (App.elements.apiModel.value === 'custom') {
                            App.elements.customModel.style.display = 'block';
                        } else {
                            App.elements.customModel.style.display = 'none';
                        }
                    });

                    // API面板关闭按钮
                    App.elements.apiCloseBtn.addEventListener('click', () => {
                        App.elements.apiPanel.classList.remove('active');
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    // 新增的左侧和右侧关闭按钮
                    const closeAiosPanel = () => {
                        App.elements.aiosPanel.classList.remove('active');
                        App.elements.closeAiosLeftBtn.style.display = 'none';
                        App.elements.closeAiosRightBtn.style.display = 'none';
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    };
                    
                    App.elements.closeAiosLeftBtn.addEventListener('click', closeAiosPanel);
                    App.elements.closeAiosRightBtn.addEventListener('click', closeAiosPanel);
                    
                    // 聊天导航按钮功能已通过CSS设置
                    
                    App.elements.chatTopBtn.addEventListener('click', () => {
                        const chatMessages = App.elements.chatMessages;
                        chatMessages.scrollTo({
                            top: 0,
                            behavior: 'smooth'
                        });
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    App.elements.chatBottomBtn.addEventListener('click', () => {
                        const chatMessages = App.elements.chatMessages;
                        chatMessages.scrollTo({
                            top: chatMessages.scrollHeight,
                            behavior: 'smooth'
                        });
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    // 聊天回展按钮功能
                    App.elements.chatTrackBtn.addEventListener('click', () => {
                        App.chatTracking.returnToPosition();
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    // 聊天清空按钮功能
                    App.elements.chatClearBtn.addEventListener('click', () => {
                        // 确认对话框
                        if (confirm('确定要清空所有聊天历史吗？此操作不可恢复。')) {
                            App.chat.clearHistory();
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        }
                    });

                    // 搜索功能事件
                    App.elements.searchBtn.addEventListener('click', () => {
                        const query = App.elements.searchInput.value.trim();
                        if (query) {
                            const results = App.search.perform(query, App.elements.searchCategory.value);
                            App.search.display(results);
                            App.search.addToHistory(query);
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        }
                    });
                    
                    App.elements.searchInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            App.elements.searchBtn.click();
                        }
                    });
                    
                    App.elements.searchCategory.addEventListener('change', () => {
                        const query = App.elements.searchInput.value.trim();
                        if (query) {
                            const results = App.search.perform(query, App.elements.searchCategory.value);
                            App.search.display(results);
                        }
                    });
                    
                    App.elements.searchHistory.addEventListener('change', (e) => {
                        if (e.target.value) {
                            App.elements.searchInput.value = e.target.value;
                            App.elements.searchBtn.click();
                        }
                    });
                    
                    App.elements.clearSearchBtn.addEventListener('click', () => App.search.clear());
                    
                    App.elements.closeSearchBtn.addEventListener('click', () => {
                        App.elements.searchPanel.classList.remove('active');
                        App.audio.play(...App.elements.soundType.value.split(':'));
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });

                    // 预览按钮事件
                    App.elements.previewVibrationBtn.addEventListener('click', () => {
                        App.vibration.trigger(App.elements.vibrateMode.value);
                    });
                    
                    App.elements.previewSoundBtn.addEventListener('click', () => {
                        const [type, freq] = App.elements.soundType.value.split(':');
                        App.audio.play(type, freq, 1.0);
                    });

                    // 使用事件委托处理按钮点击
                    document.addEventListener('click', (e) => {
                        const target = e.target;
                        
                        if (target.id === 'calculate') {
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        } else if (target.id === 'clear') {
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        } else if (target.id === 'paste') {
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        }
                        
                        // 为所有示例按钮添加声音和振动
                        if (target.classList.contains('example')) {
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        }
                        
                        // 为所有复制按钮添加声音和振动
                        if (target.classList.contains('copy-icon')) {
                            App.audio.play(...App.elements.soundType.value.split(':'));
                            App.vibration.trigger(App.elements.vibrateMode.value);
                        }
                    });
                },

                setupOutsideClick() {
                    // 点击外部关闭面板
                    document.addEventListener('click', (e) => {
                        // 关闭AIOS面板
                        if (!App.elements.aiosPanel.contains(e.target) && 
                            !App.elements.aiosButton.contains(e.target) && 
                            !App.elements.closeAiosLeftBtn.contains(e.target) &&
                            !App.elements.closeAiosRightBtn.contains(e.target) &&
                            !App.elements.apiConfigBtn.contains(e.target) &&
                            !App.elements.apiPanel.contains(e.target) &&
                            App.elements.aiosPanel.classList.contains('active')) {
                            App.elements.aiosPanel.classList.remove('active');
                            App.elements.closeAiosLeftBtn.style.display = 'none';
                            App.elements.closeAiosRightBtn.style.display = 'none';
                        }
                        
                        // 关闭API配置面板
                        if (!App.elements.apiPanel.contains(e.target) && 
                            !App.elements.apiConfigBtn.contains(e.target) && 
                            App.elements.apiPanel.classList.contains('active')) {
                            App.elements.apiPanel.classList.remove('active');
                        }
                        
                        // 关闭搜索面板
                        if (!App.elements.searchPanel.contains(e.target) && 
                            !App.elements.searchButton.contains(e.target) && 
                            App.elements.searchPanel.classList.contains('active')) {
                            App.elements.searchPanel.classList.remove('active');
                        }
                        
                        // 关闭设置面板
                        if (!App.elements.settingsPanel.contains(e.target) && 
                            !App.elements.settingsButton.contains(e.target) && 
                            App.elements.settingsPanel.classList.contains('active')) {
                            App.elements.settingsPanel.classList.remove('active');
                        }
                    });
                },
                
                loadApiConfig() {
                    const config = App.apiConfig.getConfig();
                    App.elements.apiUrl.value = config.url;
                    App.elements.apiKey.value = config.key;
                    App.elements.apiTemperature.value = config.temperature;
                    App.elements.apiMaxTokens.value = config.maxTokens;
                    
                    // 处理模型值
                    const modelValue = config.model;
                    const isCustomOption = !document.querySelector(`#apiModel option[value="${modelValue}"]`);
                    
                    if (isCustomOption) {
                        App.elements.apiModel.value = 'custom';
                        App.elements.customModel.value = modelValue;
                        App.elements.customModel.style.display = 'block';
                    } else {
                        App.elements.apiModel.value = modelValue;
                        App.elements.customModel.style.display = 'none';
                    }
                }
            },

            // 修复不完整JSON的辅助方法
            fixIncompleteJson(jsonStr, fullBuffer, startIndex) {
                // 在完整缓冲区中查找匹配的开始位置
                const fullMatch = fullBuffer.substring(startIndex);
                const dataMatch = fullMatch.match(/^data:\s*(\{.*)/);
                
                if (!dataMatch) return null;
                
                let potentialJson = dataMatch[1];
                let braceCount = 0;
                let inString = false;
                let escapeNext = false;
                let endIndex = 0;
                
                // 逐字符分析，找到匹配的结束括号
                for (let i = 0; i < potentialJson.length; i++) {
                    const char = potentialJson[i];
                    
                    if (escapeNext) {
                        escapeNext = false;
                        continue;
                    }
                    
                    if (char === '\\') {
                        escapeNext = true;
                        continue;
                    }
                    
                    if (char === '"' && !escapeNext) {
                        inString = !inString;
                        continue;
                    }
                    
                    if (!inString) {
                        if (char === '{') {
                            braceCount++;
                        } else if (char === '}') {
                            braceCount--;
                            if (braceCount === 0) {
                                endIndex = i + 1;
                                break;
                            }
                        }
                    }
                }
                
                if (braceCount === 0 && endIndex > 0) {
                    return potentialJson.substring(0, endIndex);
                }
                
                return null;
            },

            // 更新连接状态指示器
            updateConnectionStatus(isConnected) {
                const apiConfigBtn = document.getElementById('apiConfigBtn');
                if (apiConfigBtn) {
                    if (isConnected) {
                        apiConfigBtn.style.background = 'linear-gradient(135deg, rgba(46, 204, 113, 0.6), rgba(39, 174, 96, 0.6))';
                        apiConfigBtn.setAttribute('title', 'API连接正常');
                    } else {
                        apiConfigBtn.style.background = 'linear-gradient(135deg, rgba(231, 76, 60, 0.6), rgba(192, 57, 43, 0.6))';
                        apiConfigBtn.setAttribute('title', 'API连接失败，请检查配置');
                    }
                }
            },

            // 初始化应用
            init() {
                console.log(`初始化应用，加载时间: ${App.performance.measure('init')}ms`);
                
                // 初始化计算器
                this.calculator.init();
                
                // 设置事件处理
                this.events.setup();
                this.events.setupOutsideClick();
                
                // 初始化聊天快捷键
                App.chat.setupKeyboardShortcuts();
                App.chat.setupSendButton();
                
                // 初始化API连接状态
                this.updateConnectionStatus(false);
                
                console.log(`应用初始化完成，总耗时: ${App.performance.measure('complete')}ms`);
            }
        };

        // 启动应用
        document.addEventListener('DOMContentLoaded', () => {
            App.init();
        });
    </script>
</body>
</html>



