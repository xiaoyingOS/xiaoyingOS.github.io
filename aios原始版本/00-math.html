<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>专业数学计算器 ProMax (增强版)</title>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* 将无理数的小数点后位数从4位改为6位，修改了 generateApproximationNote 函数中的 toFixed(4) 为 toFixed(6) */
        :root {
            --primary-color: #3498db;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --text-color: #2c3e50;
            --bg-color: #f8f9fa;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: #333;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
            text-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 15px;
        }
        
        .calculator {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .input-section, .output-section {
            flex: 1;
            min-width: 300px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            overflow: visible;
            max-width: none; /* 移除最大宽度限制 */
        }
        
        .section-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--text-color);
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-color);
        }
        
        input, select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        input:focus, select:focus, textarea:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
            outline: none;
        }
        
        textarea {
            min-height: 120px;
            resize: vertical;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 140px;
        }
        
        .calculate-btn {
            background: var(--primary-color);
            color: white;
        }
        
        .calculate-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }
        
        .clear-btn {
            background: var(--danger-color);
            color: white;
        }
        
        .clear-btn:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }
        
        .paste-btn {
            background: var(--success-color);
            color: white;
        }
        
        .paste-btn:hover {
            background: #27ae60;
            transform: translateY(-2px);
        }
        
        .output {
            background: var(--bg-color);
            border-radius: 8px;
            padding: 20px;
            min-height: 200px;
            border: 2px dashed #ddd;
        }
        
        .math-expression {
            font-size: 1.2rem;
            text-align: left;
            padding: 15px;
            margin: 10px 0;
            background: white;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
            position: relative;
            width: 100%;
            box-sizing: border-box;
            overflow: visible;
            max-width: none; /* 移除最大宽度限制 */
            min-width: 0; /* 允许收缩 */
        }
        
        .copy-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            color: var(--primary-color);
            font-size: 1.2rem;
            transition: all 0.3s;
        }
        
        .copy-icon:hover {
            color: #2980b9;
            transform: scale(1.1);
        }
        
        .steps {
            margin-top: 20px;
        }
        
        .step {
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .step-title {
            font-weight: 600;
            color: var(--text-color);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .example-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            margin-bottom: 30px;
        }
        
        .examples {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .example {
            padding: 15px;
            background: var(--bg-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            border-left: 4px solid var(--primary-color);
        }
        
        .example:hover {
            background: #e9ecef;
            transform: translateY(-3px);
        }
        
        .example-title {
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--text-color);
        }
        
        .example-expression {
            font-family: monospace;
            color: var(--danger-color);
            word-break: break-all;
            white-space: normal;
        }
        
        .function-reference {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .function-categories {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .function-category {
            background: var(--bg-color);
            border-radius: 8px;
            padding: 15px;
        }
        
        .category-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--text-color);
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }
        
        .function-list {
            list-style-type: none;
        }
        
        .function-list li {
            padding: 5px 0;
            border-bottom: 1px dashed #ddd;
        }
        
        .function-list li:last-child {
            border-bottom: none;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            color: white;
            opacity: 0.8;
        }
        
        .error {
            color: var(--danger-color);
            background: #fadbd8;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        
        .success-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--success-color);
            color: white;
            padding: 15px 20px;
            border-radius: 5px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: fadeInOut 2s ease-in-out;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translateY(-20px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-20px); }
        }
        
        .result-text {
            font-family: 'Courier New', monospace;
            background: var(--bg-color);
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0 0 0;
            border-left: 4px solid var(--primary-color);
            font-size: 1.3rem;
            line-height: 1.6;
            font-weight: bold;
            word-break: break-word; /* 确保长单词或表达式可以断开 */
            white-space: pre-wrap; /* 确保换行和空格被保留 */
            overflow-wrap: break-word;
            width: 100%; /* 确保宽度占满容器 */
            box-sizing: border-box; /* 确保padding不会导致溢出 */
            overflow: visible; /* 确保内容可见 */
            max-width: none; /* 移除最大宽度限制 */
            text-overflow: clip; /* 防止文本被省略号截断 */
        }

        .approximation-text {
            font-size: 0.9em; 
            color: #6c757d; 
            margin-top: 5px;
            padding: 5px 15px;
            text-align: left;
            border-top: 1px dashed #ddd;
        }
        
        .exponential {
            color: var(--danger-color);
            font-weight: bold;
        }
        
        .result-title {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 10px;
        }
        
        .evaluation-input {
            margin-top: 10px;
            padding: 10px;
            background: #e8f4fc;
            border-radius: 5px;
        }
        
        .evaluation-input input {
            margin: 5px;
            padding: 8px;
            width: 80px;
        }
        
        .infinity-warning {
            color: var(--danger-color);
            background: #fdeaea;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            border-left: 4px solid var(--danger-color);
        }
        
        @media (max-width: 768px) {
            .calculator {
                flex-direction: column;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .function-categories {
                grid-template-columns: 1fr;
            }
            
            .result-text {
                font-size: 1.1rem;
            }
            
            textarea, .example-expression, .result-text {
                word-break: break-word;
                white-space: pre-wrap;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-calculator"></i> 专业数学计算器</h1>
        </header>
        
        <div class="calculator">
            <div class="input-section">
                <h2 class="section-title"><i class="fas fa-edit"></i> 输入表达式</h2>
                
                <div class="input-group">
                    <label for="expression"><i class="fas fa-square-root-alt"></i> 数学表达式</label>
                    <textarea id="expression" placeholder="例如: e + pi + sqrt(3)"></textarea>
                </div>
                
                <div class="input-group">
                    <label for="operation"><i class="fas fa-tasks"></i> 计算类型</label>
                    <select id="operation">
                        <option value="derivative">求导 (d/dx)</option>
                        <option value="integral">不定积分 (∫ dx)</option>
                        <option value="definite_integral">定积分 (∫[a,b] dx)</option>
                        <option value="double_integral">二重不定积分 (∬ dxdy)</option>
                        <option value="double_definite_integral">二重定积分 (∬[a,b][c,d] dxdy)</option>
                        <option value="n_definite_integral">n重定积分 (∫...∫ dx₁...dxₙ)</option>
                        <option value="second_derivative">二阶导数 (d²/dx²)</option>
                        <option value="nth_derivative">n阶导数 (dⁿ/dxⁿ)</option>
                        <option value="simplify">表达式化简</option>
                        <option value="evaluate">表达式求值</option>
                    </select>
                </div>
                
                <div class="input-group" id="nth-derivative-group" style="display: none;">
                    <label for="nth-order"><i class="fas fa-sort-numeric-up"></i> 导数阶数 (n)</label>
                    <input type="number" id="nth-order" min="1" max="10" value="3">
                </div>
                
                <div class="input-group" id="definite-integral-group" style="display: none;">
                    <label><i class="fas fa-arrows-alt-h"></i> 积分区间</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div style="flex: 1;">
                            <label for="lower-limit" style="font-size: 0.9em; margin-bottom: 5px;">下限 (a)</label>
                            <input type="text" id="lower-limit" placeholder="例如: 0, pi, -1" value="0">
                        </div>
                        <div style="flex: 1;">
                            <label for="upper-limit" style="font-size: 0.9em; margin-bottom: 5px;">上限 (b)</label>
                            <input type="text" id="upper-limit" placeholder="例如: 1, pi, e" value="1">
                        </div>
                    </div>
                </div>
                
                <div class="input-group" id="double-integral-group" style="display: none;">
                    <label><i class="fas fa-th"></i> 二重积分变量</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <label for="variable2" style="font-size: 0.9em; margin-bottom: 5px;">第二个变量</label>
                            <input type="text" id="variable2" placeholder="例如: y" value="y">
                        </div>
                    </div>
                </div>
                
                <div class="input-group" id="double-definite-integral-group" style="display: none;">
                    <label><i class="fas fa-th"></i> 二重积分变量与区间</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <label for="variable2-definite" style="font-size: 0.9em; margin-bottom: 5px;">第二个变量</label>
                            <input type="text" id="variable2-definite" placeholder="例如: y" value="y">
                        </div>
                    </div>
                    <label style="margin-top: 10px;">对第一个变量的积分区间 (x)</label>
                    <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <label for="x-lower" style="font-size: 0.9em; margin-bottom: 5px;">x下限</label>
                            <input type="text" id="x-lower" placeholder="0" value="0">
                        </div>
                        <div style="flex: 1;">
                            <label for="x-upper" style="font-size: 0.9em; margin-bottom: 5px;">x上限</label>
                            <input type="text" id="x-upper" placeholder="1" value="1">
                        </div>
                    </div>
                    <label>对第二个变量的积分区间 (y)</label>
                    <div style="display: flex; gap: 10px;">
                        <div style="flex: 1;">
                            <label for="y-lower" style="font-size: 0.9em; margin-bottom: 5px;">y下限</label>
                            <input type="text" id="y-lower" placeholder="0" value="0">
                        </div>
                        <div style="flex: 1;">
                            <label for="y-upper" style="font-size: 0.9em; margin-bottom: 5px;">y上限</label>
                            <input type="text" id="y-upper" placeholder="1" value="1">
                        </div>
                    </div>
                </div>
                
                <div class="input-group" id="n-definite-integral-group" style="display: none;">
                    <label><i class="fas fa-layer-group"></i> n重定积分设置</label>
                    <div style="margin-bottom: 10px;">
                        <label for="n-variables" style="font-size: 0.9em; margin-bottom: 5px;">变量列表 (逗号分隔,支持任意个数)</label>
                        <input type="text" id="n-variables" placeholder="例如: x,y,z 或 x,y,z,w,v..." value="x,y,z">
                        <p style="font-size: 0.85em; color: #666; margin-top: 5px;">提示: 变量个数决定积分重数</p>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label for="n-limits" style="font-size: 0.9em; margin-bottom: 5px;">积分区间 (格式: 下1,上1;下2,上2;...)</label>
                        <textarea id="n-limits" placeholder="例如: 0,1;0,1;0,1 (区间数量必须与变量数量一致)" style="min-height: 60px;">0,1;0,1;0,1</textarea>
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label for="n-samples" style="font-size: 0.9em; margin-bottom: 5px;">采样数 (6维及以上使用)</label>
                        <input type="number" id="n-samples" placeholder="默认: 10000000" value="1000000" min="1000" step="1000">
                        <p style="font-size: 0.85em; color: #666; margin-top: 5px;">提示: 采样数越大精度越高但速度越慢,建议1万-1000万</p>
                    </div>
                </div>
                
                <div class="input-group">
                    <label for="variable"><i class="fas fa-font"></i> 变量</label>
                    <input type="text" id="variable" value="x" placeholder="例如: x, y, t...">
                </div>
                
                <div class="input-group" id="evaluation-inputs" style="display: none;">
                    <label><i class="fas fa-keyboard"></i> 变量赋值</label>
                    <div class="evaluation-input">
                        <div id="variable-inputs">
                            </div>
                        <p style="font-size: 0.9rem; color: #666; margin-top: 5px;">为表达式中的变量输入具体数值</p>
                    </div>
                </div>
                
                <div class="btn-group">
                    <button class="calculate-btn" id="calculate">
                        <i class="fas fa-calculator"></i> 计算
                    </button>
                    <button class="paste-btn" id="paste">
                        <i class="fas fa-paste"></i> 粘贴
                    </button>
                    <button class="clear-btn" id="clear">
                        <i class="fas fa-broom"></i> 清除
                    </button>
                </div>
            </div>
            
            <div class="output-section">
                <h2 class="section-title"><i class="fas fa-chart-line"></i> 计算结果 </h2>
                <div class="output" id="output">
                    <p style="text-align: center; color: #7f8c8d; padding: 30px;">
                        计算结果将显示在这里...
                    </p>
                </div>
                
                <div class="steps" id="steps">
                    </div>
            </div>
        </div>
        
        <div class="example-section">
            <h2 class="section-title"><i class="fas fa-lightbulb"></i> 示例表达式</h2>
            <p>点击以下示例快速尝试计算器功能：</p>
            
            <div class="examples">
                <div class="example" data-expr="3+2-ln0+cot0-tan90°">
                    <div class="example-title">无穷大统一处理示例</div>
                    <div class="example-expression">3+2-ln0+cot0-tan90°</div>
                </div>
                
                <div class="example" data-expr="e + pi + sqrt(3)">
                    <div class="example-title">常数项数值合并/符号保留测试</div>
                    <div class="example-expression">e + pi + sqrt(3)</div>
                </div>
                
                <div class="example" data-expr="(x+y)^3">
                    <div class="example-title">多项式展开/积分</div>
                    <div class="example-expression">(x+y)^3</div>
                </div>
                
                <div class="example" data-expr="425+163+225+60+24+25+50+51+495+24*x+40+98+570+91+112+190+15*x+271+110+119+200+165+240+100+435+415+920+405+104+269+640+133+124+120+133+227+207+354+240+240+128+261+60+144+129+169+88+700+519+94+637+466+613+475+15">
                    <div class="example-title">积分/求导优化测试 (长表达式)</div>
                    <div class="example-expression">425+163+...+15*x+...+15</div>
                </div>
                
                <div class="example" data-expr="exp(x) * log(x)">
                    <div class="example-title">非初等函数积分 (e^x ln(x))</div>
                    <div class="example-expression">exp(x) * log(x)</div>
                </div>
                
                <div class="example" data-expr="tan(pi/2) + x + 1/x">
                    <div class="example-title">化简/求值 无穷大测试</div>
                    <div class="example-expression">tan(pi/2) + x + 1/x</div>
                </div>
                
                <div class="example" data-expr="ln(x) + cos(0)">
                    <div class="example-title">化简/求值 0点对数测试</div>
                    <div class="example-expression">ln(x) + cos(0)</div>
                </div>
                
                <div class="example" data-expr="x^4 + 3*x^2 - 6*x + x + 1">
                    <div class="example-title">多项式求导</div>
                    <div class="example-expression">x^4 + 3*x^2 - 6*x + x + 1</div>
                </div>
                
                <div class="example" data-expr="log3(27) + log5(1) + log(x) + pi/2">
                    <div class="example-title">任意底对数 + π 显示测试</div>
                    <div class="example-expression">log3(27) + log5(1) + log(x) + pi/2</div>
                </div>
                
                <div class="example" data-expr="log(3.14)(3.14) + log(1/2)(pi) + log(e)(pi*e)">
                    <div class="example-title">小数分数底数对数测试</div>
                    <div class="example-expression">log(3.14)(3.14) + log(1/2)(π) + log(e)(π*e)</div>
                </div>
                
                <div class="example" data-expr="3x2 + 5y3">
                    <div class="example-title">X乘法测试 (3x2=3*2)</div>
                    <div class="example-expression">3x2 + 5y3</div>
                </div>
                
                <div class="example" data-expr="ln(x)x5">
                    <div class="example-title">X乘法测试 (ln(x)x5=ln(x)*5)</div>
                    <div class="example-expression">ln(x)x5</div>
                </div>
                
                <div class="example" data-expr="3* (3+6)x9+ln(x)x5 x 6">
                    <div class="example-title">X乘法测试 (带空格的x乘法)</div>
                    <div class="example-expression">3* (3+6)x9+ln(x)x5 x 6</div>
                </div>
                
                <div class="example" data-expr="3i + 1-5i">
                    <div class="example-title">虚数支持测试</div>
                    <div class="example-expression">3i + 1-5i</div>
                </div>
                
                <div class="example" data-expr="π + 2π/3 - π/6">
                    <div class="example-title">π符号常数运算测试</div>
                    <div class="example-expression">π + 2π/3 - π/6</div>
                </div>
                
                <div class="example" data-expr="10 ÷ 2 + 3 ÷ 4">
                    <div class="example-title">÷符号除法测试</div>
                    <div class="example-expression">10 ÷ 2 + 3 ÷ 4</div>
                </div>
                
                <div class="example" data-expr="x^2" data-operation="definite_integral" data-lower="0" data-upper="1">
                    <div class="example-title">定积分示例: ∫[0,1] x² dx</div>
                    <div class="example-expression">x^2 (定积分 0到1)</div>
                </div>
                
                <div class="example" data-expr="sin(x)" data-operation="definite_integral" data-lower="0" data-upper="pi">
                    <div class="example-title">定积分示例: ∫[0,π] sin(x) dx</div>
                    <div class="example-expression">sin(x) (定积分 0到π)</div>
                </div>
                
                <div class="example" data-expr="exp(x)" data-operation="definite_integral" data-lower="0" data-upper="1">
                    <div class="example-title">定积分示例: ∫[0,1] e^x dx</div>
                    <div class="example-expression">exp(x) (定积分 0到1)</div>
                </div>
                
                <div class="example" data-expr="1/x" data-operation="definite_integral" data-lower="1" data-upper="e">
                    <div class="example-title">定积分示例: ∫[1,e] 1/x dx</div>
                    <div class="example-expression">1/x (定积分 1到e)</div>
                </div>
                
                <div class="example" data-expr="cos(x)" data-operation="definite_integral" data-lower="0" data-upper="pi/2">
                    <div class="example-title">定积分示例: ∫[0,π/2] cos(x) dx</div>
                    <div class="example-expression">cos(x) (定积分 0到π/2)</div>
                </div>
                
                <div class="example" data-expr="x*y" data-operation="double_integral">
                    <div class="example-title">二重不定积分: ∬ xy dxdy</div>
                    <div class="example-expression">x*y (二重不定积分)</div>
                </div>
                
                <div class="example" data-expr="x^2 + y^2" data-operation="double_integral">
                    <div class="example-title">二重不定积分: ∬ (x²+y²) dxdy</div>
                    <div class="example-expression">x^2 + y^2 (二重不定积分)</div>
                </div>
                
                <div class="example" data-expr="x*y" data-operation="double_definite_integral" data-x-lower="0" data-x-upper="1" data-y-lower="0" data-y-upper="1">
                    <div class="example-title">二重定积分: ∬[0,1][0,1] xy dxdy</div>
                    <div class="example-expression">x*y (二重定积分 x:0到1, y:0到1)</div>
                </div>
                
                <div class="example" data-expr="sin(x)*cos(y)" data-operation="double_definite_integral" data-x-lower="0" data-x-upper="pi" data-y-lower="0" data-y-upper="pi">
                    <div class="example-title">二重定积分: ∬[0,π][0,π] sin(x)cos(y) dxdy</div>
                    <div class="example-expression">sin(x)*cos(y) (二重定积分)</div>
                </div>
                
                <div class="example" data-expr="exp(x+y)" data-operation="double_definite_integral" data-x-lower="0" data-x-upper="1" data-y-lower="0" data-y-upper="1">
                    <div class="example-title">二重定积分: ∬[0,1][0,1] e^(x+y) dxdy</div>
                    <div class="example-expression">exp(x+y) (二重定积分)</div>
                </div>
                
                <div class="example" data-expr="x*y*z" data-operation="n_definite_integral" data-n-variables="x,y,z" data-n-limits="0,1;0,1;0,1">
                    <div class="example-title">三重定积分: ∫[0,1][0,1][0,1] xyz dxdydz</div>
                    <div class="example-expression">x*y*z (三重定积分)</div>
                </div>
                
                <div class="example" data-expr="x^2+y^2+z^2" data-operation="n_definite_integral" data-n-variables="x,y,z" data-n-limits="0,1;0,1;0,1">
                    <div class="example-title">三重定积分: ∫[0,1]³ (x²+y²+z²) dxdydz</div>
                    <div class="example-expression">x^2+y^2+z^2 (三重定积分)</div>
                </div>
                
                <div class="example" data-expr="sin(x)*cos(y)*exp(z)" data-operation="n_definite_integral" data-n-variables="x,y,z" data-n-limits="0,pi;0,pi;0,1">
                    <div class="example-title">三重定积分: sin(x)cos(y)e^z</div>
                    <div class="example-expression">sin(x)*cos(y)*exp(z)</div>
                </div>
            </div>
        </div>
        
        <div class="function-reference">
            <h2 class="section-title"><i class="fas fa-book"></i> 支持的函数与符号</h2>
            
            <div class="function-categories">
                <div class="function-category">
                    <div class="category-title">基本运算</div>
                    <ul class="function-list">
                        <li>+ (加法)</li>
                        <li>- (减法)</li>
                        <li>* (乘法)</li>
                        <li>÷ (除法) <i class="fas fa-check-circle"></i></li>
                        <li>^ (幂运算)</li>
                        <li>() (括号)</li>
                        <li>sqrt(x) - 平方根 ($\sqrt{x}$) <i class="fas fa-check-circle"></i></li>
                        <li>x乘法 (3x2=3*2) <i class="fas fa-check-circle"></i></li>
                    </ul>
                </div>
                
                <div class="function-category">
                    <div class="category-title">三角函数</div>
                    <ul class="function-list">
                        <li>sin(x) - 正弦</li>
                        <li>cos(x) - 余弦</li>
                        <li>tan(x) - 正切</li>
                        <li>cot(x) - 余切</li>
                        <li>sec(x) - 正割</li>
                        <li>csc(x) - 余割</li>
                    </ul>
                </div>
                
                <div class="function-category">
                    <div class="category-title">反三角函数</div>
                    <ul class="function-list">
                        <li>asin(x) - 反正弦</li>
                        <li>acos(x) - 反余弦</li>
                        <li>atan(x) - 反正切</li>
                        <li>acot(x) - 反余切</li>
                        <li>asec(x) - 反正割</li>
                        <li>acsc(x) - 反余割</li>
                    </ul>
                </div>
                
                <div class="function-category">
                    <div class="category-title">双曲函数</div>
                    <ul class="function-list">
                        <li>sinh(x) - 双曲正弦</li>
                        <li>cosh(x) - 双曲余弦</li>
                        <li>tanh(x) - 双曲正切</li>
                        <li>asinh(x) - 反双曲正弦</li>
                        <li>acosh(x) - 反双曲余弦</li>
                        <li>atanh(x) - 反双曲正切</li>
                    </ul>
                </div>
                
                <div class="function-category">
                    <div class="category-title">指数与对数 <i class="fas fa-magic"></i></div>
                    <ul class="function-list">
                        <li>exp(x) - 指数函数 ($e^x$)</li>
                        <li>log(x) 或 ln(x) - **自然对数** ($\ln(x)$)</li>
                        <li>log10(x) 或 lg(x) - **以10为底**对数 ($\lg(x)$)</li>
                        <li>logN(v) (例如 log3(5)) - **任意底**对数 ($\log_N(v)$) <i class="fas fa-check-circle"></i></li>
                        <li>log(底数)(真数) (例如 log(3.14)(3.14)) - **任意底**对数，支持小数、分数等底数 <i class="fas fa-check-circle"></i></li>
                    </ul>
                </div>
                
                <div class="function-category">
                    <div class="category-title">特殊函数与积分</div>
                    <ul class="function-list">
                        <li>abs(x) - 绝对值</li>
                        <li>factorial(n) - 阶乘</li>
                        <li>gamma(x) - 伽马函数</li>
                        <li>∫(e^x/x)dx - 指数积分 (非初等函数) <i class="fas fa-check-circle"></i></li>
                    </ul>
                </div>
                
                <div class="function-category">
                    <div class="category-title">常数</div>
                    <ul class="function-list">
                        <li>pi - 圆周率 $\pi$ <i class="fas fa-check-circle"></i></li>
                        <li>e - 自然常数</li>
                        <li>i - 虚数单位 <i class="fas fa-check-circle"></i></li>
                        <li>inf - 无穷大</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <footer>
            <p>专业数学计算器 ProMax (增强版) &copy; 2023</p>
        </footer>
    </div>

    <script>
        // 缓存DOM元素和计算结果
        const Calculator = {
            elements: {},
            cache: new Map(),
            
            init() {
                this.tolerance = 1e-10; // 新增：定义容忍度
                this.cacheDOM();
                this.bindEvents();
                this.setupPasteHandler();
            },
            
            cacheDOM() {
                this.elements = {
                    expressionInput: document.getElementById('expression'),
                    operationSelect: document.getElementById('operation'),
                    variableInput: document.getElementById('variable'),
                    nthDerivativeGroup: document.getElementById('nth-derivative-group'),
                    nthOrderInput: document.getElementById('nth-order'),
                    definiteIntegralGroup: document.getElementById('definite-integral-group'),
                    lowerLimitInput: document.getElementById('lower-limit'),
                    upperLimitInput: document.getElementById('upper-limit'),
                    doubleIntegralGroup: document.getElementById('double-integral-group'),
                    variable2Input: document.getElementById('variable2'),
                    doubleDefiniteIntegralGroup: document.getElementById('double-definite-integral-group'),
                    variable2DefiniteInput: document.getElementById('variable2-definite'),
                    xLowerInput: document.getElementById('x-lower'),
                    xUpperInput: document.getElementById('x-upper'),
                    yLowerInput: document.getElementById('y-lower'),
                    yUpperInput: document.getElementById('y-upper'),
                    nDefiniteIntegralGroup: document.getElementById('n-definite-integral-group'),
                    nVariablesInput: document.getElementById('n-variables'),
                    nLimitsInput: document.getElementById('n-limits'),
                    nSamplesInput: document.getElementById('n-samples'),
                    evaluationInputs: document.getElementById('evaluation-inputs'),
                    variableInputs: document.getElementById('variable-inputs'),
                    calculateBtn: document.getElementById('calculate'),
                    pasteBtn: document.getElementById('paste'),
                    clearBtn: document.getElementById('clear'),
                    outputDiv: document.getElementById('output'),
                    stepsDiv: document.getElementById('steps'),
                    examples: document.querySelectorAll('.example')
                };
            },
            
            bindEvents() {
                const { operationSelect, calculateBtn, clearBtn, examples, expressionInput } = this.elements;
                
                operationSelect.addEventListener('change', () => this.handleOperationChange());
                calculateBtn.addEventListener('click', () => this.handleCalculate());
                clearBtn.addEventListener('click', () => this.handleClear());
                
                examples.forEach(example => {
                    example.addEventListener('click', (e) => {
                        const expression = e.currentTarget.getAttribute('data-expr');
                        const operation = e.currentTarget.getAttribute('data-operation');
                        const lower = e.currentTarget.getAttribute('data-lower');
                        const upper = e.currentTarget.getAttribute('data-upper');
                        const xLower = e.currentTarget.getAttribute('data-x-lower');
                        const xUpper = e.currentTarget.getAttribute('data-x-upper');
                        const yLower = e.currentTarget.getAttribute('data-y-lower');
                        const yUpper = e.currentTarget.getAttribute('data-y-upper');
                        const nVariables = e.currentTarget.getAttribute('data-n-variables');
                        const nLimits = e.currentTarget.getAttribute('data-n-limits');
                        
                        expressionInput.value = expression;
                        
                        // 如果示例指定了操作类型,切换到对应操作
                        if (operation) {
                            operationSelect.value = operation;
                            this.handleOperationChange();
                            
                            // 如果是定积分,设置上下限
                            if (operation === 'definite_integral' && lower && upper) {
                                this.elements.lowerLimitInput.value = lower;
                                this.elements.upperLimitInput.value = upper;
                            }
                            
                            // 如果是二重定积分,设置上下限
                            if (operation === 'double_definite_integral' && xLower && xUpper && yLower && yUpper) {
                                this.elements.xLowerInput.value = xLower;
                                this.elements.xUpperInput.value = xUpper;
                                this.elements.yLowerInput.value = yLower;
                                this.elements.yUpperInput.value = yUpper;
                            }
                            
                            // 如果是n重定积分,设置变量和区间
                            if (operation === 'n_definite_integral' && nVariables && nLimits) {
                                this.elements.nVariablesInput.value = nVariables;
                                this.elements.nLimitsInput.value = nLimits;
                            }
                        }
                        
                        if (operationSelect.value === 'evaluate') {
                            this.updateVariableInputs();
                        }
                    });
                });
                
                expressionInput.addEventListener('input', () => {
                    if (operationSelect.value === 'evaluate') {
                        this.updateVariableInputs();
                    }
                    
                    // 当选择n重定积分时，自动更新变量列表
                    if (operationSelect.value === 'n_definite_integral') {
                        this.updateNDefiniteIntegralVariables();
                    }
                });
            },
            
            setupPasteHandler() {
                const { pasteBtn, expressionInput } = this.elements;
                
                pasteBtn.addEventListener('click', async () => {
                    try {
                        if (navigator.clipboard && navigator.clipboard.readText) {
                            const pastedText = await navigator.clipboard.readText();
                            if (pastedText) {
                                expressionInput.value = pastedText;
                                if (this.elements.operationSelect.value === 'evaluate') {
                                    this.updateVariableInputs();
                                }
                                this.showSuccessMessage('内容已粘贴！');
                                return;
                            }
                        }
                        
                        const tempTextarea = document.createElement('textarea');
                        tempTextarea.style.position = 'fixed';
                        tempTextarea.style.left = '0';
                        tempTextarea.style.top = '0';
                        tempTextarea.style.opacity = '0';
                        document.body.appendChild(tempTextarea);
                        tempTextarea.focus();
                        
                        setTimeout(() => {
                            if (tempTextarea.value) {
                                expressionInput.value = tempTextarea.value;
                                if (this.elements.operationSelect.value === 'evaluate') {
                                    this.updateVariableInputs();
                                }
                                this.showSuccessMessage('内容已粘贴！');
                            } else {
                                this.showSuccessMessage('请手动在输入框中粘贴内容 (Ctrl+V)');
                                expressionInput.focus();
                            }
                            document.body.removeChild(tempTextarea);
                        }, 100);
                        
                    } catch (error) {
                        this.showSuccessMessage('请手动在输入框中粘贴内容 (Ctrl+V)');
                        expressionInput.focus();
                    }
                });
            },
            
            handleOperationChange() {
                const { operationSelect, nthDerivativeGroup, definiteIntegralGroup, doubleIntegralGroup, 
                        doubleDefiniteIntegralGroup, nDefiniteIntegralGroup, evaluationInputs } = this.elements;
                
                // 先隐藏所有特殊输入组
                nthDerivativeGroup.style.display = 'none';
                definiteIntegralGroup.style.display = 'none';
                doubleIntegralGroup.style.display = 'none';
                doubleDefiniteIntegralGroup.style.display = 'none';
                nDefiniteIntegralGroup.style.display = 'none';
                evaluationInputs.style.display = 'none';
                
                // 根据选择显示对应的输入组
                if (operationSelect.value === 'nth_derivative') {
                    nthDerivativeGroup.style.display = 'block';
                } else if (operationSelect.value === 'definite_integral') {
                    definiteIntegralGroup.style.display = 'block';
                } else if (operationSelect.value === 'double_integral') {
                    doubleIntegralGroup.style.display = 'block';
                } else if (operationSelect.value === 'double_definite_integral') {
                    doubleDefiniteIntegralGroup.style.display = 'block';
                } else if (operationSelect.value === 'n_definite_integral') {
                    nDefiniteIntegralGroup.style.display = 'block';
                    // 当选择n重定积分时，自动更新变量列表
                    this.updateNDefiniteIntegralVariables();
                } else if (operationSelect.value === 'evaluate') {
                    evaluationInputs.style.display = 'block';
                    this.updateVariableInputs();
                }
            },
            
            updateVariableInputs() {
                const { expressionInput, variableInputs } = this.elements;
                const expression = expressionInput.value.trim();
                
                if (!expression) {
                    variableInputs.innerHTML = '';
                    return;
                }
                
                const cacheKey = `variables_${expression}`;
                if (this.cache.has(cacheKey)) {
                    variableInputs.innerHTML = this.cache.get(cacheKey);
                    return;
                }
                
                try {
                    const node = math.parse(expression);
                    const variables = this.extractVariables(node);
                    
                    let html = '';
                    variables.forEach(variable => {
                        html += `
                            <div>
                                <label for="var-${variable}">${variable} = </label>
                                <input type="number" id="var-${variable}" value="1" step="any">
                            </div>
                        `;
                    });
                    
                    variableInputs.innerHTML = html;
                    this.cache.set(cacheKey, html);
                    
                } catch (error) {
                    variableInputs.innerHTML = '<p style="color: #e74c3c;">无法解析表达式</p>';
                }
            },
            
            // 新增：自动更新n重积分的变量列表
            updateNDefiniteIntegralVariables() {
                const { expressionInput, nVariablesInput } = this.elements;
                const expression = expressionInput.value.trim();
                
                if (!expression) {
                    nVariablesInput.value = 'x';
                    return;
                }
                
                try {
                    // 自动检测表达式中的变量
                    const detectedVars = this.detectVariables(expression);
                    
                    // 如果没有检测到变量，使用默认变量x
                    const variables = detectedVars.length > 0 ? detectedVars : ['x'];
                    
                    // 更新变量列表
                    nVariablesInput.value = variables.join(',');
                    
                    // 更新积分阶数显示
                    const integralOrderDisplay = document.querySelector('#n-definite-integral-group .fa-layer-group').nextSibling;
                    if (integralOrderDisplay) {
                        integralOrderDisplay.textContent = ` n重定积分设置 (当前: ${variables.length}重, 自动检测变量: ${variables.join(', ')})`;
                    }
                    
                    // 自动调整积分区间数量以匹配变量数量
                    const currentLimits = this.elements.nLimitsInput.value.trim().split(';').map(limit => {
                        const [lower, upper] = limit.split(',').map(v => v.trim());
                        return { lower, upper };
                    });
                    
                    // 如果区间数量不足，使用默认区间[0,1]补充
                    if (currentLimits.length < variables.length) {
                        let newLimits = currentLimits.map(l => `${l.lower},${l.upper}`).join(';');
                        for (let i = currentLimits.length; i < variables.length; i++) {
                            newLimits += (newLimits ? ';' : '') + '0,1';
                        }
                        this.elements.nLimitsInput.value = newLimits;
                    }
                    // 区间数量多于变量数量时，保持不变，正常计算即可
                    
                } catch (error) {
                    console.error('变量检测失败:', error);
                    nVariablesInput.value = 'x';
                }
            },
            
            extractVariables(node) {
                const variables = new Set();
                
                const traverse = (node) => {
                    if (node.type === 'SymbolNode') {
                        if (!['pi', 'e', 'i'].includes(node.name)) {
                            variables.add(node.name);
                        }
                    } else if (node.type === 'FunctionNode') {
                        node.args.forEach(traverse);
                    } else if (node.type === 'OperatorNode') {
                        node.args.forEach(traverse);
                    } else if (node.type === 'ParenthesisNode') {
                        traverse(node.content);
                    }
                };
                
                traverse(node);
                return Array.from(variables);
            },
            
            handleCalculate() {
                const { expressionInput, operationSelect, variableInput, nthOrderInput, lowerLimitInput, upperLimitInput, 
                        variable2Input, variable2DefiniteInput, xLowerInput, xUpperInput, yLowerInput, yUpperInput, 
                        outputDiv, stepsDiv } = this.elements;
                const expression = expressionInput.value.trim();
                const operation = operationSelect.value;
                const variable = variableInput.value.trim() || 'x';
                const nthOrder = nthOrderInput.value;
                
                // 获取定积分的上下限
                const lowerLimit = lowerLimitInput ? lowerLimitInput.value.trim() : '';
                const upperLimit = upperLimitInput ? upperLimitInput.value.trim() : '';
                
                // 获取二重积分的参数
                const var2 = variable2Input ? variable2Input.value.trim() : '';
                const var2Def = variable2DefiniteInput ? variable2DefiniteInput.value.trim() : '';
                const xLower = xLowerInput ? xLowerInput.value.trim() : '';
                const xUpper = xUpperInput ? xUpperInput.value.trim() : '';
                const yLower = yLowerInput ? yLowerInput.value.trim() : '';
                const yUpper = yUpperInput ? yUpperInput.value.trim() : '';
                
                // 获取n重定积分的参数
                const nVariables = this.elements.nVariablesInput ? this.elements.nVariablesInput.value.trim() : '';
                const nLimits = this.elements.nLimitsInput ? this.elements.nLimitsInput.value.trim() : '';
                const nSamples = this.elements.nSamplesInput ? this.elements.nSamplesInput.value : '';
                
                // 调试信息
                console.log('=== handleCalculate 调试信息 ===');
                console.log('nSamples值:', nSamples);
                console.log('nSamples类型:', typeof nSamples);
                
                if (!expression) {
                    alert('请输入数学表达式！');
                    return;
                }
                
                stepsDiv.innerHTML = '';
                outputDiv.innerHTML = '';
                
                try {
                    // 缓存键包含所有相关参数(包括n重积分的采样数)
                    const cacheKey = `${operation}_${expression}_${variable}_${nthOrder}_${lowerLimit}_${upperLimit}_${var2}_${var2Def}_${xLower}_${xUpper}_${yLower}_${yUpper}_${nVariables}_${nLimits}_${nSamples}`;
                    console.log('缓存键:', cacheKey);
                    console.log('缓存中是否存在:', this.cache.has(cacheKey));
                    if (this.cache.has(cacheKey)) {
                        console.log('使用缓存结果');
                        this.displayResult(this.cache.get(cacheKey));
                        return;
                    }
                    console.log('计算新结果');
                    
                    const processedExpression = this.preprocessExpression(expression);
                    
                    const result = this.calculate(processedExpression, operation, variable, nthOrder, nSamples);
                    result.originalExpression = expression; // 保存原始表达式
                    result.displayExpression = this.formatOriginalExpression(expression); // 保存用于显示的原始表达式
                    this.cache.set(cacheKey, result);
                    this.displayResult(result);
                    
                } catch (error) {
                    this.displayError(error.message, expression);
                }
            },
            
            // 预处理表达式 - 增强了对数无括号支持和 logN(v) 转换
            preprocessExpression(expr) {
                let processed = expr;
                
                // 1. 处理√符号
                processed = processed.replace(/√\s*\(([^)]+)\)/g, 'sqrt($1)');
                processed = processed.replace(/√\s*([a-zA-Z0-9.]+)/g, 'sqrt($1)');
                
                // 2. 处理角度符号 - 保留原始形式用于显示
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d*\.?\d+)\s*°\s*\)/g, '$1($2*pi/180)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d*\.?\d+)\s*°/g, '$1($2*pi/180)');
                
                // 3. 关键修复：处理三角函数中单个π或e的情况 - 保留原始形式
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*π\s*\)/g, '$1(3.141592653589793)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*e\s*\)/g, '$1(2.718281828459045)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*pi\s*\)/g, '$1(3.141592653589793)');
                
                // 4. 处理其他π表达式 - 增强支持更多格式
                // 4.1 处理带括号的π表达式
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d*\.?\d*)\s*\*\s*π\s*\)/g, '$1($2*3.141592653589793)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d*\.?\d*)\s*π\s*\)/g, '$1($2*3.141592653589793)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*π\s*\/\s*(\d+)\s*\)/g, '$1(3.141592653589793/$2)');
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d+)\s*\*\s*π\s*\/\s*(\d+)\s*\)/g, '$1($2*3.141592653589793/$3)');
                
                // 4.2 处理不带括号的π表达式 (如 sin2π, cos3π)
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d*\.?\d*)π/g, (match, func, num) => {
                    const number = num === '' || num === '-' ? '1' : num;
                    const sign = num.startsWith('-') ? '-' : '';
                    return `${func}(${sign}${number.replace('-', '')}*3.141592653589793)`;
                });
                
                // 4.3 处理更复杂的π表达式 (如 sin(2π/3), cos(3π/2))
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d+)\s*π\s*\/\s*(\d+)\s*\)/g, '$1($2*3.141592653589793/$3)');
                
                // 4.4 处理π在分子的情况 (如 sin(π/2), cos(π/3))
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*π\s*\/\s*(\d+)\s*\)/g, '$1(3.141592653589793/$2)');
                
                // 4.5 处理π的分数形式 (如 sin(π/6), cos(π/4))
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*π\s*\/\s*(\d+)\s*\)/g, '$1(3.141592653589793/$2)');
                
                // 5. 处理一般数字参数
                processed = processed.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d*\.?\d+)(?![a-zA-Z0-9.(])/g, '$1($2)');
                
                // 6. 处理反三角函数
                processed = processed.replace(/arc(sin|cos|tan|cot|sec|csc)/g, 'a$1');
                
                // 7. 关键修复：先处理 log(底数)(真数) 格式，避免与其他格式冲突
                // 匹配 log(底数)(真数) 格式，支持各种底数形式
                // 例如：log(3.14)(3.14), log(1/2)(π), log(e)(π*e)
                // 使用更严格的匹配，确保括号正确匹配
                processed = processed.replace(/\blog\s*\(\s*([^()]+)\s*\)\s*\(\s*([^()]+)\s*\)/g, 'log($2, $1)');
                
                // 7.5. 增强: 任意底对数支持 logN(v) -> log(v, N)
                // 匹配 log 紧跟一个或多个数字 (底数)，然后是括号内的参数 (值)
                // 修复：支持log和数字之间有空格的情况
                processed = processed.replace(/\blog([0-9]+)\s*\(([^)]+)\)/g, 'log($2, $1)');
                processed = processed.replace(/\blog\s+([0-9]+)\s*\(([^)]+)\)/g, 'log($2, $1)');

                // 8. 增强的对数无括号支持 (仅对 ln, lg)
                processed = this.processLogarithmWithoutParentheses(processed);
                
                // 8.5. 新增：处理三角函数无括号情况 (如 sinx, cosi, tan30°)
                processed = this.processTrigonometricWithoutParentheses(processed);
                
                // 9. 将 ln(x) 替换为 math.js 的 log(x) (自然对数)
                processed = processed.replace(/ln\(/g, 'log('); 
                
                // 10. 将 lg(x) 替换为 math.js 的 log10(x) (以10为底)
                processed = processed.replace(/lg\(/g, 'log10('); 
                
                // 11. 新增：处理÷符号为除法
                processed = processed.replace(/÷/g, '/');
                
                // 12. 新增：处理表达式化简中的X乘法（仅在化简模式）
                if (this.elements.operationSelect.value === 'simplify') {
                    processed = this.processXMultiplication(processed);
                }
                
                // 13. 处理π符号为pi
                // 调试信息
                console.log('=== 预处理表达式调试 ===');
                console.log('处理π符号前:', processed);
                processed = processed.replace(/π/g, 'pi');
                console.log('处理π符号后:', processed);
                
                // 14. 修复虚数处理 - 移除之前的处理，让math.js自然处理
                // 不再进行i^2=-1的预转换，让math.js自然处理
                
                console.log('最终预处理结果:', processed);
                return processed;
            },
            
            // 新增：处理X乘法 (仅在表达式化简模式) - 修复为只有x和X代表乘法，排除exp(x)等函数
            processXMultiplication(expr) {
                // 在表达式化简中，只要x和X的前后不是运算符，都应该把x看成乘法
                // 例如：ln(x)x5 应该变成 ln(x)*5
                // 例如：3x2 应该变成 3*2
                // 例如：xsin(x) 应该变成 *sin(x)（如果x在开头）
                // 例如：ln(x)x 6 应该变成 ln(x)*6
                // 排除：exp(x) 不应该被处理为 e*p(x)
                
                let processed = expr;
                
                // 先保护函数名，避免被误处理
                const functionNames = ['exp', 'sin', 'cos', 'tan', 'cot', 'sec', 'csc', 'asin', 'acos', 'atan', 'acot', 'asec', 'acsc', 
                                     'sinh', 'cosh', 'tanh', 'asinh', 'acosh', 'atanh', 'log', 'ln', 'lg', 'sqrt', 'abs', 'factorial', 'gamma'];
                
                // 创建函数名保护的正则表达式
                const functionNamePattern = new RegExp(`\\b(${functionNames.join('|')})\\b`, 'g');
                
                // 使用占位符保护函数名
                const functionPlaceholders = [];
                let placeholderIndex = 0;
                processed = processed.replace(functionNamePattern, (match) => {
                    const placeholder = `__FUNC_PLACEHOLDER_${placeholderIndex++}__`;
                    functionPlaceholders.push(match);
                    return placeholder;
                });
                
                // 先移除x/X前后的多余空格，但保留必要的空格
                processed = processed.replace(/\s*([xX])\s*/g, '$1');
                
                // 处理各种x/X乘法情况
                
                // 1. 数字后跟x/X再跟数字: 3x2 -> 3*2
                processed = processed.replace(/(\d+)([xX])(\d+)/g, (match, num1, letter, num2) => {
                    return `${num1}*${num2}`;
                });
                
                // 2. 数字后跟x/X再跟字母/函数: 3xsin(x) -> 3*sin(x)
                processed = processed.replace(/(\d+)([xX])([a-zA-Z])/g, (match, num1, letter, nextChar) => {
                    return `${num1}*${nextChar}`;
                });
                
                // 3. 字母/变量/函数后跟x/X再跟数字: sin(x)x5 -> sin(x)*5
                processed = processed.replace(/([a-zA-Z\)\]}])([xX])(\d+)/g, (match, prevChar, letter, num2) => {
                    return `${prevChar}*${num2}`;
                });
                
                // 4. 字母/变量/函数后跟x/X再跟字母/函数: sin(x)xcos(x) -> sin(x)*cos(x)
                processed = processed.replace(/([a-zA-Z\)\]}])([xX])([a-zA-Z\(])/g, (match, prevChar, letter, nextChar) => {
                    return `${prevChar}*${nextChar}`;
                });
                
                // 5. 处理开头的x/X: x5 -> *5, xsin(x) -> *sin(x)
                processed = processed.replace(/^([xX])(\d+)/g, (match, letter, num2) => {
                    return `*${num2}`;
                });
                processed = processed.replace(/^([xX])([a-zA-Z\(])/g, (match, letter, nextChar) => {
                    return `*${nextChar}`;
                });
                
                // 6. 处理运算符后的x/X: +x5 -> +*5, -xsin(x) -> -*-sin(x)
                processed = processed.replace(/([+\-*/÷^=,!\s\[\{])([xX])(\d+)/g, (match, op, letter, num2) => {
                    return `${op}*${num2}`;
                });
                processed = processed.replace(/([+\-*/÷^=,!\s\[\{])([xX])([a-zA-Z\(])/g, (match, op, letter, nextChar) => {
                    return `${op}*${nextChar}`;
                });
                
                // 7. 处理括号后的x/X: )x5 -> )*5
                processed = processed.replace(/(\))([xX])(\d+)/g, (match, paren, letter, num2) => {
                    return `${paren}*${num2}`;
                });
                processed = processed.replace(/(\))([xX])([a-zA-Z\(])/g, (match, paren, letter, nextChar) => {
                    return `${paren}*${nextChar}`;
                });
                
                // 恢复函数名
                for (let i = 0; i < functionPlaceholders.length; i++) {
                    processed = processed.replace(`__FUNC_PLACEHOLDER_${i}__`, functionPlaceholders[i]);
                }
                
                return processed;
            },
            
            // 新增：预处理表达式用于显示（包含X乘法处理）
            preprocessExpressionForDisplay(expr) {
                let processed = expr;
                
                // 处理X乘法，用于显示
                processed = processed.replace(/(\d+)([xX])(\d+)/g, (match, num1, letter, num2) => {
                    // 将 3x2 转换为 3*2 用于显示，而不是 3*x*2
                    return `${num1}*${num2}`;
                });
                
                return processed;
            },
            
            // 增强的对数无括号支持处理 (已移除 log2)
            processLogarithmWithoutParentheses(expr) {
                let processed = expr;
                
                // 处理 ln, lg 后紧跟数字、e、pi 或它们的组合
                const logPatterns = [
                    { regex: /(ln|lg)\s*(-?[0-9]+(?:\.[0-9]+)?)(?=\W|$)/g, handler: this.processSimpleNumberLog },
                    { regex: /(ln|lg)\s*([a-zA-Z\u03c0]+)(?=\W|$)/g, handler: this.processSimpleSymbolLog },
                    { regex: /(ln|lg)\s*(-?[0-9]+(?:\.[0-9]+)?[a-zA-Z\u03c0]+)(?=\W|$)/g, handler: this.processNumberSymbolLog },
                    { regex: /(ln|lg)\s*([a-zA-Z\u03c0]+-?[0-9]+(?:\.[0-9]+)?)(?=\W|$)/g, handler: this.processSymbolNumberLog },
                    { regex: /(ln|lg)\s*(-?[0-9]+(?:\.[0-9]+)?[a-zA-Z\u03c0]+-?[0-9]*(?:\.[0-9]+)?)(?=\W|$)/g, handler: this.processComplexLog },
                    // 新增：处理带括号的负数 ln(-e), lg(-3) 等
                    { regex: /(ln|lg)\s*\(\s*(-[0-9]+(?:\.[0-9]+)?)\s*\)/g, handler: this.processNegativeNumberLog },
                    { regex: /(ln|lg)\s*\(\s*(-[a-zA-Z\u03c0]+)\s*\)/g, handler: this.processNegativeSymbolLog }
                ];
                
                logPatterns.forEach(pattern => {
                    processed = processed.replace(pattern.regex, (match, func, arg) => {
                        return pattern.handler.call(this, func, arg);
                    });
                });
                
                // 处理 logN 无括号的情况 (例如 log39 -> log3(9))
                // 注意: 这必须在 logN(...) 转换之后执行
                const logNDigitPattern = /\blog([0-9]+)\s*(-?[0-9]+)(?=\W|$)/g;
                processed = processed.replace(logNDigitPattern, (match, base, arg) => {
                    return `log${base}(${arg})`;
                });

                return processed;
            },
            
            processSimpleNumberLog(func, arg) {
                // 处理 ln100, lg1000 等
                return `${func}(${arg})`;
            },
            
            processSimpleSymbolLog(func, arg) {
                // 处理 lne, lnπ, lge, lni 等
                let processedArg = arg;
                if (arg === 'π') processedArg = 'pi';
                // 保持i不变，math.js会自动处理
                return `${func}(${processedArg})`;
            },
            
            processNumberSymbolLog(func, arg) {
                // 处理 ln2e, lg10π 等
                let processedArg = arg.replace(/([0-9\.]+)([a-zA-Z\u03c0])/g, '$1*$2');
                processedArg = processedArg.replace(/π/g, 'pi');
                return `${func}(${processedArg})`;
            },
            
            processSymbolNumberLog(func, arg) {
                // 处理 lne2, lnπ3 等
                let processedArg = arg.replace(/([a-zA-Z\u03c0])([0-9\.]+)/g, '$1*$2');
                processedArg = processedArg.replace(/π/g, 'pi');
                return `${func}(${processedArg})`;
            },
            
            processComplexLog(func, arg) {
                // 处理更复杂的组合 ln2e3π, lg10π2 等
                let processedArg = arg
                    .replace(/(-?[0-9\.]+)([a-zA-Z\u03c0])/g, '$1*$2')
                    .replace(/([a-zA-Z\u03c0])(-?[0-9\.]+)/g, '$1*$2')
                    .replace(/([e\u03c0])([e\u03c0])/g, '$1*$2');
                processedArg = processedArg.replace(/π/g, 'pi');
                return `${func}(${processedArg})`;
            },
            
            // 新增：处理带负号的数字 ln(-3), lg(-2.5) 等
            processNegativeNumberLog(func, arg) {
                // 直接使用负数作为参数
                return `${func}(${arg})`;
            },
            
            // 新增：处理带负号的符号 ln(-e), lg(-π) 等
            processNegativeSymbolLog(func, arg) {
                let processedArg = arg;
                if (arg === '-π') processedArg = '-pi';
                // 保持-i不变，math.js会自动处理
                return `${func}(${processedArg})`;
            },
            
            // 新增：处理三角函数无括号情况 (如 sinx, cosi, tan30°)
            processTrigonometricWithoutParentheses(expr) {
                // 调试信息
                console.log('=== processTrigonometricWithoutParentheses 函数调试 ===');
                console.log('输入表达式:', expr);
                
                let processed = expr;
                
                // 处理三角函数后紧跟数字、变量、e、pi 或它们的组合
                const trigPatterns = [
                    // 处理 sinx, cosi, tanx 等简单情况（包括负数）
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*([a-zA-Z\u03c0])(?=\W|$)/g, handler: this.processSimpleTrig },
                    // 处理 sin30°, cos45°, tan60° 等角度情况（包括负数）
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d+\.?\d*)\s*°/g, handler: this.processTrigWithDegrees },
                    // 处理 sin30, cos45, tan60 等数字情况（默认为弧度，包括负数）
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d+\.?\d*)(?=\W|$)/g, handler: this.processTrigWithRadians },
                    // 处理 sin2x, cos3y, tan4z 等数字变量组合（包括负数）
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d+\.?\d*)([a-zA-Z\u03c0])/g, handler: this.processTrigNumberVariable },
                    // 处理 sin2π, cos3π 等数字π组合（包括负数）
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*(-?\d+\.?\d*)π/g, handler: this.processTrigNumberPi },
                    // 新增：处理 sin(-x), cos(-i) 等带负号的变量
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*-([a-zA-Z\u03c0])\s*\)/g, handler: this.processNegativeVariableTrig },
                    // 新增：处理 sin(-30°), cos(-45°) 等带负号的角度
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d+\.?\d+)\s*°\s*\)/g, handler: this.processNegativeDegreeTrig },
                    // 新增：处理 sin(-30), cos(-45) 等带负号的弧度
                    { regex: /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\s*\(\s*(-?\d+\.?\d+)\s*\)/g, handler: this.processNegativeRadianTrig }
                ];
                
                trigPatterns.forEach(pattern => {
                    const beforeReplace = processed;
                    processed = processed.replace(pattern.regex, (match, func, ...args) => {
                        console.log('匹配到模式:', pattern.regex);
                        console.log('匹配内容:', match);
                        console.log('函数名:', func);
                        console.log('参数:', args);
                        
                        const result = pattern.handler.call(this, func, ...args);
                        console.log('处理结果:', result);
                        return result;
                    });
                    
                    if (beforeReplace !== processed) {
                        console.log('表达式已改变:', beforeReplace, '->', processed);
                    }
                });

                console.log('最终处理结果:', processed);
                return processed;
            },
            
            // 处理简单三角函数 sinx, cosi 等
            processSimpleTrig(func, arg) {
                // 调试信息
                console.log('=== processSimpleTrig 函数调试 ===');
                console.log('函数名:', func);
                console.log('参数:', arg);
                
                // 处理特殊情况：sinx -> sin(x), cosi -> cos(i)
                let processedArg = arg;
                if (arg === 'π') processedArg = 'pi';
                // 保持i不变，math.js会自动处理
                
                const result = `${func}(${processedArg})`;
                console.log('处理结果:', result);
                return result;
            },
            
            // 处理带角度的三角函数 sin30°, cos45° 等
            processTrigWithDegrees(func, arg) {
                // 将角度转换为弧度：30° -> 30*pi/180
                return `${func}(${arg}*pi/180)`;
            },
            
            // 处理带弧度数字的三角函数 sin30, cos45 等
            processTrigWithRadians(func, arg) {
                // 直接使用数字作为弧度值
                return `${func}(${arg})`;
            },
            
            // 处理数字变量组合 sin2x, cos3y 等
            processTrigNumberVariable(func, num, variable) {
                // 将 sin2x 转换为 sin(2*x)
                let processedVariable = variable;
                if (variable === 'π') processedVariable = 'pi';
                return `${func}(${num}*${processedVariable})`;
            },
            
            // 处理数字π组合 sin2π, cos3π 等
            processTrigNumberPi(func, num) {
                // 将 sin2π 转换为 sin(2*pi)
                return `${func}(${num}*pi)`;
            },
            
            // 新增：处理带负号的变量 sin(-x), cos(-i) 等
            processNegativeVariableTrig(func, variable) {
                let processedVariable = variable;
                if (variable === 'π') processedVariable = 'pi';
                // 保持i不变，math.js会自动处理
                return `${func}(-${processedVariable})`;
            },
            
            // 新增：处理带负号的角度 sin(-30°), cos(-45°) 等
            processNegativeDegreeTrig(func, degrees) {
                // 将 sin(-30°) 转换为 sin(-30*pi/180)
                return `${func}(${degrees}*pi/180)`;
            },
            
            // 新增：处理带负号的弧度 sin(-30), cos(-45) 等
            processNegativeRadianTrig(func, radians) {
                // 直接使用负数作为弧度值
                return `${func}(${radians})`;
            },

            // 检查无穷大情况 (用于求导/积分)
            checkForInfinity(expr, operation, variable) {
                if (operation === 'simplify' || operation === 'evaluate') {
                    // For simplify/evaluate, we use the granular getInfiniteTerms method
                    return { isInfinity: false };
                }
                
                const infinityPatterns = [
                    { pattern: /(tan|sec|atan|asec)\s*\(\s*3\.141592653589793\s*\/\s*2\s*\)/, message: '函数在π/2处为无穷大' },
                    { pattern: /(tan|sec|atan|asec)\s*\(\s*90\s*\*\s*3\.141592653589793\s*\/\s*180\s*\)/, message: '函数在90°处为无穷大' },
                    { pattern: /(tan|sec|atan|asec)\s*\(\s*270\s*\*\s*3\.141592653589793\s*\/\s*180\s*\)/, message: '函数在270°处为无穷大' },
                    { pattern: /(cot|csc|acot|acsc)\s*\(\s*0\s*\)/, message: '函数在0处为无穷大' },
                    { pattern: /(cot|csc|acot|acsc)\s*\(\s*3\.141592653589793\s*\)/, message: '函数在π处为无穷大' },
                    // Log(0) check
                    { pattern: /log\s*\(\s*0\s*\)/, message: 'ln(0) 为无穷大' },
                    { pattern: /log10\s*\(\s*0\s*\)/, message: 'lg(0) 为无穷大' },
                ];
                
                for (const { pattern, message } of infinityPatterns) {
                    if (pattern.test(expr)) {
                        return { isInfinity: true, message };
                    }
                }
                
                return { isInfinity: false };
            },

            // 检查无穷大项 (用于化简/求值，提取出项)
            getInfiniteTerms(expr, varName) {
                const tolerance = this.tolerance;
                let scope = { [varName]: 1, pi: math.pi, e: math.e, i: math.i }; // 新增：支持虚数单位
                
                // For evaluation mode, use the assigned variable values
                if (this.elements.operationSelect.value === 'evaluate') {
                    this.elements.variableInputs.querySelectorAll('input').forEach(input => {
                        const vName = input.id.replace('var-', '');
                        scope[vName] = parseFloat(input.value) || 0;
                    });
                }
                
                const allTerms = [];
                try {
                    this.extractTerms(math.parse(expr), allTerms);
                } catch (e) {
                    // Cannot parse, return all as finite (or let the main calc fail)
                    return { finiteTerms: allTerms, infiniteTerms: [] };
                }

                let finiteTerms = [];
                let infiniteTerms = [];
                
                allTerms.forEach(term => {
                    const termStr = term.node.toString();
                    let isInfinite = false;
                    let infinitySign = 1; // 1 for positive infinity, -1 for negative infinity

                    // 1. Logarithmic check (ln(x) where x <= 0 or 1/ln(x) where x=1)
                    // 匹配 log(x) 或 log(v, N)
                    const logPattern = /log\(([^)]+)\)/g; 
                    let match;
                    let tempStr = termStr;
                    while ((match = logPattern.exec(tempStr)) !== null) {
                        const arg = match[1];
                        
                        let base = 'e';
                        let value = arg;

                        // 检查是否是 log(v, N) 形式
                        if (arg.includes(',')) {
                            const parts = arg.split(',').map(s => s.trim());
                            value = parts[0];
                            base = parts[1];
                        }
                        
                        try {
                            const argValue = math.evaluate(value, scope);
                            const baseValue = math.evaluate(base, scope);
                            
                            // 修改：对于 log(负数) 或 log(底数为负数) 或 log(底数为1)，改为NaN而不是无穷大
                            if (argValue < 0) { // 真数为负数
                                isInfinite = true;
                                infinitySign = 'NaN'; // 标记为NaN
                                break;
                            }
                            
                            if (argValue === 0) { // 真数为0，保持原来的负无穷大处理
                                isInfinite = true;
                                infinitySign = -1;
                                break;
                            }
                            
                            // 检查底数是否为 1 或负数
                            if (baseValue === 1) {
                                isInfinite = true;
                                infinitySign = 'NaN'; // 标记为NaN
                                break;
                            }
                            
                            if (baseValue < 0) { // 底数为负数
                                isInfinite = true;
                                infinitySign = 'NaN'; // 标记为NaN
                                break;
                            }
                        } catch (e) {
                            // If it contains the variable and evaluation fails, assume it might be problematic
                            if (value.includes(varName)) isInfinite = true;
                        }
                    }
                    
                    // 2. Trigonometric singularities (tan(pi/2), cot(0) etc.)
                    // 首先检查特殊情况
                    if (termStr.includes('cot(0)') || termStr.includes('csc(0)')) {
                        isInfinite = true;
                    }
                    // 检查 tan(pi/2) 和 sec(pi/2)
                    else if (termStr.includes('tan(3.141592653589793/2)') || termStr.includes('tan(90*pi/180)') || 
                             termStr.includes('sec(3.141592653589793/2)') || termStr.includes('sec(90*pi/180)')) {
                        isInfinite = true;
                    }
                    // 检查 tan(-pi/2) 和 sec(-pi/2) - 修复：这些是负无穷大
                    else if (termStr.includes('tan(-3.141592653589793/2)') || termStr.includes('tan(-90*pi/180)') || 
                             termStr.includes('sec(-3.141592653589793/2)') || termStr.includes('sec(-90*pi/180)')) {
                        isInfinite = true;
                        infinitySign = -1; // 负无穷大
                    }
                    // 检查 tan(3pi/2) 和 sec(3pi/2) - 修复：这些是负无穷大
                    else if (termStr.includes('tan(3*3.141592653589793/2)') || termStr.includes('tan(270*pi/180)') || 
                             termStr.includes('sec(3*3.141592653589793/2)') || termStr.includes('sec(270*pi/180)')) {
                        isInfinite = true;
                        infinitySign = -1; // 负无穷大
                    }
                    // 检查 tan(-3pi/2) 和 sec(-3pi/2) - 修复：这些是正无穷大
                    else if (termStr.includes('tan(-3*3.141592653589793/2)') || termStr.includes('tan(-270*pi/180)') || 
                             termStr.includes('sec(-3*3.141592653589793/2)') || termStr.includes('sec(-270*pi/180)')) {
                        isInfinite = true;
                        // infinitySign = 1 (正无穷大，保持默认值)
                    }
                    // 一般三角函数检查
                    else {
                        const trigPattern = /(tan|cot|sec|csc)\(([^)]+)\)/g;
                        tempStr = termStr;
                        while ((match = trigPattern.exec(tempStr)) !== null) {
                            const func = match[1];
                            const arg = match[2];
                            try {
                                const argValue = math.evaluate(arg, { pi: math.pi });
                                const val = argValue / math.pi;
                                
                                if (func === 'tan' || func === 'sec') {
                                    // Singularities at (n + 1/2) * pi
                                    const n = Math.round(val - 0.5);
                                    if (Math.abs(val - (n + 0.5)) < tolerance) {
                                        isInfinite = true;
                                        // 确定无穷大的符号：tan和sec在奇数倍π/2处符号交替变化
                                        // tan(π/2) = +∞, tan(3π/2) = -∞, tan(5π/2) = +∞, ...
                                        // tan(-π/2) = -∞, tan(-3π/2) = +∞, tan(-5π/2) = -∞, ...
                                        if (n % 2 === 0) {
                                            // n为偶数时，如π/2, 5π/2, -3π/2等
                                            infinitySign = Math.sign(Math.cos(argValue)) > 0 ? 1 : -1;
                                        } else {
                                            // n为奇数时，如3π/2, 7π/2, -π/2等
                                            infinitySign = Math.sign(Math.cos(argValue)) > 0 ? -1 : 1;
                                        }
                                        break;
                                    }
                                }
                                if (func === 'cot' || func === 'csc') {
                                    // Singularities at n * pi
                                    const n = Math.round(val);
                                    if (Math.abs(val - n) < tolerance) {
                                        isInfinite = true;
                                        break;
                                    }
                                }
                            } catch (e) {
                                // Ignore
                            }
                        }
                    }

                    // 3. General 1/0 check
                    if (!isInfinite) {
                        try {
                            const evaluatedValue = math.evaluate(termStr, scope);
                            // 特殊处理：单个虚数i不是无穷大
                            if (termStr === 'i' || termStr === '-i') {
                                isInfinite = false;
                            } else if (!isFinite(evaluatedValue)) {
                                // 检查是否是虚数结果
                                if (evaluatedValue.toString().includes('i') || 
                                    (typeof evaluatedValue === 'object' && evaluatedValue !== null && 're' in evaluatedValue && 'im' in evaluatedValue)) {
                                    // 虚数不是无穷大
                                    isInfinite = false;
                                } else {
                                    // 修复：不覆盖原始符号，无穷大项的值不影响项前面的符号
                                    isInfinite = true;
                                }
                            }
                        } catch (e) {
                            // Ignore for now.
                        }
                    }

                    if (isInfinite) {
                        // Keep the original node, but format the display string
                        const displayStr = this.formatExpressionForDisplay(termStr.replace(/^\s*\+/, '').replace(/^\s*\-/, '-'));
                        // 修复：保留原始表达式中的符号，不受无穷大值的影响
                        const sign = term.sign || 1;
                        infiniteTerms.push({ display: displayStr, node: term.node, sign: sign, infinitySign: infinitySign });
                    } else {
                        finiteTerms.push(term);
                    }
                });
                
                return { finiteTerms, infiniteTerms };
            },

            // **修正 Issue 2 (丢失 +-号) 和 Issue 1 (多余 1) 的核心函数**
            reconstructExpression(terms) {
                if (terms.length === 0) return '0';
                
                // 1. 合并同类项
                const mergedTerms = this.mergeTerms(terms, this.elements.variableInput.value.trim() || 'x');
                
                let result = '';
                
                mergedTerms.forEach((term, index) => {
                    if (Math.abs(term.coefficient) < this.tolerance) return;

                    const isPositive = term.coefficient >= 0;
                    const absCoeff = Math.abs(term.coefficient);
                    
                    // 确定符号前缀
                    let signPrefix = '';
                    if (index > 0) {
                        signPrefix = isPositive ? ' + ' : ' - ';
                    } else if (!isPositive) {
                        signPrefix = '-';
                    }
                    
                    let termStr = '';
                    
                    // 特殊处理：如果是数值常数项（在 mergeTerms 中被标记为 '_NUMERICAL_CONSTANT_'）
                    if (term.variablePart === '_NUMERICAL_CONSTANT_') {
                         termStr = this.formatCoefficient(absCoeff, true); // 强制格式化为数字
                    } 
                    // 常数项（符号常数或纯常数）
                    else if (term.variablePart === '') {
                        // 常数项: 获取系数的格式化结果（不带符号，符号由 signPrefix 或第一个项的负号处理）
                        termStr = this.formatCoefficient(absCoeff, true); 
                    } else {
                        // 变量项 / 符号常数项 (e, pi, i, sqrt(3)等)
                        const formattedCoeff = this.formatCoefficient(absCoeff); // Magnitude-only, returns '' for 1
                        
                        // **修正: 积分结果中常数项的系数为 1 时，不显示 1***
                        const isConstantIntegralTerm = this.elements.operationSelect.value === 'integral' && 
                                                       (term.variablePart.endsWith(this.elements.variableInput.value.trim() || 'x')) && 
                                                       Math.abs(absCoeff - 1) < this.tolerance;

                        if (isConstantIntegralTerm && formattedCoeff === '') {
                             // 检查是否是 x, 如果是，直接用 term.variablePart
                             if (term.variablePart === this.elements.variableInput.value.trim() || 'x') {
                                termStr = term.variablePart;
                             } else {
                                // 如果是 y*x 这样的，保留乘号
                                termStr = term.variablePart.replace(/^(.*)\*?x$/, '$1*x');
                             }
                        } else {
                            // 特殊处理虚数单位 i
                            if (term.variablePart === 'i') {
                                termStr = formattedCoeff === '' ? 'i' : `${formattedCoeff}i`;
                            } else {
                                termStr = formattedCoeff === '' ? term.variablePart : `${formattedCoeff}*${term.variablePart}`;
                            }
                        }
                    }

                    // 附加项
                    result += signPrefix + termStr;
                });
                
                // 最终清理
                result = result.replace(/\s+\-\s+/g, ' - ') // 规范化减法间距
                             .replace(/\s+\+\s+/g, ' + ') // 规范化加法间距
                             .replace(/^\s*\+\s*/, '') // 移除前导 '+ '
                             .replace(/^\s*/, ''); // 移除任何剩余的前导空格
                
                // 最终清理：移除任何多余的 1*，以防格式化失败
                result = result.replace(/\b1\*(e|pi|sqrt|log|lg|ln)/g, '$1');
                // 特殊处理：移除 1*i 中的 1
                result = result.replace(/\b1\*i/g, 'i');
                
                return result || '0';
            },

            // **修正 Issue 2 (丢失 +-号) 的核心函数**
            appendInfiniteTerms(finiteResult, infiniteTerms) {
                if (infiniteTerms.length === 0) {
                    return { expression: finiteResult, copyText: finiteResult };
                }

                // 对有限部分进行智能求值
                let displayResult = finiteResult;
                let copyText = displayResult;
                
                // 如果有限部分不为空，尝试进行智能求值
                if (displayResult.trim() !== '' && displayResult.trim() !== '0') {
                    console.log('=== appendInfiniteTerms 中的智能求值调试 ===');
                    console.log('有限部分输入:', displayResult);
                    const scope = { pi: math.pi, e: math.e, i: math.i };
                    displayResult = this.intelligentEvaluate(displayResult, scope);
                    console.log('智能求值结果:', displayResult);
                    copyText = displayResult;
                } else {
                    // 使用 cleanMathJSText 进行格式化
                    displayResult = this.cleanMathJSText(finiteResult);
                    copyText = displayResult;
                }
                
                // 移除有限部分的 '0'
                if (displayResult.trim() === '0' || displayResult.trim() === '') {
                    displayResult = '';
                    copyText = '';
                }

                // 按照用户要求处理无穷大项：原始表达式 = 有限计算结果-无穷大项+无穷大项【项1=±∞/NaN，项2=±∞/NaN，...】
                const infiniteTermsList = infiniteTerms.map((term, index) => {
                    // 获取原始表达式并格式化为显示形式
                    const originalTermStr = term.node.toString();
                    const displayTerm = this.formatOriginalExpressionForInfiniteTerm(originalTermStr);
                    
                    // 使用预先计算的infinitySign属性来判断无穷大的符号或NaN
                    let actualInfinityType;
                    
                    // 检查是否为NaN情况
                    if (term.infinitySign === 'NaN') {
                        actualInfinityType = 'NaN';
                    } else {
                        // 正常的无穷大处理
                        actualInfinityType = term.infinitySign === -1 ? '-∞' : '∞';
                    }
                    
                    // 如果没有infinitySign属性，则尝试计算
                    if (term.infinitySign === undefined) {
                        try {
                            const scope = { pi: math.pi, e: math.e, i: math.i };
                            const evaluatedValue = math.evaluate(originalTermStr, scope);
                            if (!isFinite(evaluatedValue) && evaluatedValue < 0) {
                                actualInfinityType = '-∞';
                            }
                        } catch (e) {
                            // 如果无法求值，使用特殊判断
                            if (originalTermStr.includes('log(0)') || originalTermStr.includes('ln(0)')) {
                                actualInfinityType = '-∞'; // ln(0) 是负无穷大
                            } else if (originalTermStr.includes('tan(90*pi/180)') || originalTermStr.includes('tan(3.141592653589793/2)')) {
                                actualInfinityType = '∞'; // tan(90°) 是正无穷大
                            } else if (originalTermStr.includes('tan(-90*pi/180)') || originalTermStr.includes('tan(-3.141592653589793/2)')) {
                                actualInfinityType = '-∞'; // tan(-90°) 是负无穷大
                            } else if (originalTermStr.includes('tan(270*pi/180)') || originalTermStr.includes('tan(3*3.141592653589793/2)')) {
                                actualInfinityType = '-∞'; // tan(270°) 是负无穷大
                            } else if (originalTermStr.includes('tan(-270*pi/180)') || originalTermStr.includes('tan(-3*3.141592653589793/2)')) {
                                actualInfinityType = '∞'; // tan(-270°) 是正无穷大
                            }
                        }
                    }
                    
                    // 确定符号前缀
                    let signPrefix = '';
                    if (index > 0) {
                        signPrefix = '，';
                    }
                    
                    // 使用新格式：项=±∞
                    return `${signPrefix}${displayTerm}=${actualInfinityType}`;
                });
                
                // 将所有无穷大项合并到一个列表中
                const infiniteTermsStr = infiniteTermsList.join('');
                
                // 构建带有无穷大项的表达式部分
                const infiniteExpressionPart = infiniteTerms.map(term => {
                    const originalTermStr = term.node.toString();
                    const displayTerm = this.formatOriginalExpressionForInfiniteTerm(originalTermStr);
                    // 修复：保留原始表达式中的符号，不受无穷大值的影响
                    const originalSign = term.sign || 1;
                    const signPrefix = originalSign === -1 ? '-' : '+';
                    return `${signPrefix}${displayTerm}`;
                }).join('');
                
                // 构建最终结果
                let finalResult;
                let finalCopyText;
                
                if (displayResult !== '') {
                    // 如果有有限部分，构建完整表达式
                    finalResult = `${displayResult}${infiniteExpressionPart}【${infiniteTermsStr}】`;
                    finalCopyText = `${copyText}${infiniteExpressionPart}【${infiniteTermsStr}】`;
                } else {
                    // 如果没有有限部分，只显示无穷大项
                    finalResult = `${infiniteExpressionPart}【${infiniteTermsStr}】`;
                    finalCopyText = `${infiniteExpressionPart}【${infiniteTermsStr}】`;
                }
                
                // 最终清理: 移除可能的前导符号和空格
                finalResult = finalResult.replace(/^\s*\+\s*/, '').replace(/^\s*\-\s*/, '-');
                finalCopyText = finalCopyText.replace(/^\s*\+\s*/, '').replace(/^\s*\-\s*/, '-');
                
                return { expression: finalResult, copyText: finalCopyText.replace(/\s+/g, ' ') };
            },
            
            // 新增：为无穷大项格式化原始表达式
            formatOriginalExpressionForInfiniteTerm(termStr) {
                // 特殊处理 tan(pi/2) 等无穷大项，保留原始形式
                let formatted = termStr;
                
                // 将 tan(3.141592653589793/2) 转换为 tan(π/2)
                formatted = formatted.replace(/(tan|cot|sec|csc|atan|acot|asec|acsc)\s*\(\s*3\.141592653589793\s*\/\s*2\s*\)/g, '$1(π/2)');
                
                // 将 tan(90*pi/180) 转换为 tan(90°)
                formatted = formatted.replace(/(tan|cot|sec|csc|atan|acot|asec|acsc)\s*\(\s*90\s*\*\s*pi\s*\/\s*180\s*\)/g, '$1(90°)');
                
                // 将 cot(0) 转换为 cot(0)
                formatted = formatted.replace(/(tan|cot|sec|csc|atan|acot|asec|acsc)\s*\(\s*0\s*\)/g, '$1(0)');
                
                // 将 log(0) 转换为 ln(0)
                formatted = formatted.replace(/log\s*\(\s*0\s*\)/g, 'ln(0)');
                
                // 将 log10(0) 转换为 lg(0)
                formatted = formatted.replace(/log10\s*\(\s*0\s*\)/g, 'lg(0)');
                
                // 处理对数函数，保留原始格式以便识别NaN情况
                // 将 log(a, b) 格式转换为 log_b(a)
                formatted = formatted.replace(/log\s*\(\s*([^,]+)\s*,\s*([^)]+)\s*\)/g, 'log<sub>$2</sub>($1)');
                
                // 修复：保留数字之间的乘法符号，移除其他情况下的乘号符号
                // 保留数字之间的乘法：3*2 -> 3*2
                // 移除函数和变量之间的乘法：sin(x)*y -> sin(x)y
                // 移除常数和变量之间的乘法：3*x -> 3x
                // 注意：这里不再移除所有乘号，而是只移除特定情况下的乘号
                formatted = formatted.replace(/([a-zA-Z\)\)])\*([a-zA-Z\(])/g, '$1$2'); // 函数/变量与函数/变量之间的乘号
                formatted = formatted.replace(/(\d)\*([a-zA-Z\(])/g, '$1$2'); // 数字与函数/变量之间的乘号
                formatted = formatted.replace(/([a-zA-Z\)\)])\*(\d)/g, '$1$2'); // 函数/变量与数字之间的乘号
                formatted = formatted.replace(/([a-zA-Z])\*(\d)/g, '$1$2'); // 单个变量与数字之间的乘号
                
                // 去除多余的空格
                formatted = formatted.replace(/\s+/g, ' '); // 将多个连续空格替换为单个空格
                formatted = formatted.replace(/\s*\(\s*/g, '('); // 去除括号前后的空格
                formatted = formatted.replace(/\s*\)\s*/g, ')'); // 去除右括号前后的空格
                formatted = formatted.replace(/\s*\+\s*/g, '+'); // 去除加号前后的空格
                formatted = formatted.replace(/\s*-\s*/g, '-'); // 去除减号前后的空格
                formatted = formatted.replace(/\s*\/\s*/g, '/'); // 去除除号前后的空格
                formatted = formatted.replace(/\s*\^\s*/g, '^'); // 去除幂号前后的空格
                formatted = formatted.replace(/\s*=\s*/g, '='); // 去除等号前后的空格
                formatted = formatted.replace(/^\s+|\s+$/g, ''); // 去除首尾空格
                
                return formatted;
            },
            
            // 清理和转换 math.js 输出，以方便显示 (用于步骤)
            cleanMathJSText(text) {
                let cleaned = text;
                
                // 0. 特殊处理对数导数格式，如 1/xln2【最终计算值/x】
                cleaned = cleaned.replace(/(\d+)\/(\w+)ln(\d+(?:\.\d+)?)【([^】]+)】/g, (match, numerator, variable, base, calc) => {
                    return `${numerator}/${variable}ln${base}【${calc}】`;
                });
                cleaned = cleaned.replace(/(\d+)\/(\w+)ln\(([^)]+)\)【([^】]+)】/g, (match, numerator, variable, base, calc) => {
                    return `${numerator}/${variable}ln(${base})【${calc}】`;
                });
                
                // 1. log(v, b) 转换为 logbase(b, v) 占位符（底数，真数）
                cleaned = cleaned.replace(/log\(([^,]+),([^)]+)\)/g, 'logbase($2, $1)'); 
                
                // 2. log10(v) 转换为 lg(v)
                cleaned = cleaned.replace(/log10\(([^)]+)\)/g, 'lg($1)');
                
                // 3. log(v) (自然对数) 转换为 ln(v)
                // 修复：使用负向预查避免匹配 logbase 和 log(底数)(真数) 格式
                cleaned = cleaned.replace(/\blog\(([^,]+)\)(?!\s*,)(?!\s*\()(?!\s*\()/g, 'ln($1)'); 

                // 修复：保留数字之间的乘法符号，移除其他情况下的乘号符号
                // 保留数字之间的乘法：3*2 -> 3*2
                // 移除函数和变量之间的乘法：sin(x)*y -> sin(x)y
                // 移除常数和变量之间的乘法：3*x -> 3x
                // 注意：这里不再移除所有乘号，而是只移除特定情况下的乘号
                cleaned = cleaned.replace(/([a-zA-Z\)\)])\*([a-zA-Z\(])/g, '$1$2'); // 函数/变量与函数/变量之间的乘号
                cleaned = cleaned.replace(/(\d)\*([a-zA-Z\(])/g, '$1$2'); // 数字与函数/变量之间的乘号
                cleaned = cleaned.replace(/([a-zA-Z\)\)])\*(\d)/g, '$1$2'); // 函数/变量与数字之间的乘号
                cleaned = cleaned.replace(/([a-zA-Z])\*(\d)/g, '$1$2'); // 单个变量与数字之间的乘号
                
                // 修复: 在步骤中显示 π 和 √ 
                cleaned = cleaned.replace(/pi/g, 'π');
                cleaned = cleaned.replace(/sqrt\(([^)]+)\)/g, '√($1)');
                
                // 新增：将π的数值表示替换为π符号
                cleaned = cleaned.replace(/3\.141592653589793/g, 'π');
                
                // 新增：将e的数值表示替换为e符号
                cleaned = cleaned.replace(/2\.718281828459045/g, 'e');
                
                // 新增：处理π的常见分数形式
                cleaned = cleaned.replace(/π\/2/g, 'π/2');
                cleaned = cleaned.replace(/π\/3/g, 'π/3');
                cleaned = cleaned.replace(/π\/4/g, 'π/4');
                cleaned = cleaned.replace(/π\/6/g, 'π/6');
                cleaned = cleaned.replace(/2\*π/g, '2π');
                cleaned = cleaned.replace(/3\*π/g, '3π');
                cleaned = cleaned.replace(/π\*2/g, '2π');
                cleaned = cleaned.replace(/π\*3/g, '3π');
                
                // 去除多余的空格，但保留乘号前后的空格
                cleaned = cleaned.replace(/\s+/g, ' '); // 将多个连续空格替换为单个空格
                cleaned = cleaned.replace(/\s*\(\s*/g, '('); // 去除括号前后的空格
                cleaned = cleaned.replace(/\s*\)\s*/g, ')'); // 去除右括号前后的空格
                cleaned = cleaned.replace(/\s*\+\s*/g, '+'); // 去除加号前后的空格
                cleaned = cleaned.replace(/\s*-\s*/g, '-'); // 去除减号前后的空格
                // 修复：不再移除乘号前后的空格，保留乘号
                // cleaned = cleaned.replace(/\s*\*\s*/g, ''); // 去除乘号前后的空格
                cleaned = cleaned.replace(/\s*\/\s*/g, '/'); // 去除除号前后的空格
                cleaned = cleaned.replace(/\s*\^\s*/g, '^'); // 去除幂号前后的空格
                cleaned = cleaned.replace(/\s*=\s*/g, '='); // 去除等号前后的空格
                cleaned = cleaned.replace(/^\s+|\s+$/g, ''); // 去除首尾空格
                
                return cleaned;
            },
            
            // **修正 Issue 1 (多余 1) 和 Issue 1 (分数转换) 的核心函数**
            formatCoefficient(coeff, isConstant = false) {
                const tolerance = this.tolerance;
                
                if (Math.abs(coeff) < tolerance) return '0';
                
                // 1. 尝试用 math.js 格式化为分数
                try {
                    const fraction = math.fraction(coeff);
                    // 仅当分母不是 1 时显示分数形式, 且分母不能大于 100 (防止将 1.732... 转换为大分数)
                    if (fraction.d !== 1 && fraction.d < 100 && math.abs(math.subtract(coeff, fraction.valueOf())) < tolerance) {
                        const n = fraction.n * (fraction.d < 0 ? -1 : 1);
                        const d = Math.abs(fraction.d);
                        return `${n}/${d}`;
                    }
                } catch (e) {
                    // 忽略错误
                }
                
                const absValue = Math.abs(coeff);

                // 2. 如果是变量系数 (isConstant=false)
                if (!isConstant) {
                    // 如果系数的绝对值接近 1，返回空字符串 (修复多余的 1)
                    if (Math.abs(absValue - 1) < tolerance) return ''; 
                    
                    // 否则返回绝对值
                    if (Math.abs(absValue - Math.round(absValue)) < tolerance) {
                        return Math.round(absValue).toString();
                    }
                }
                
                // 3. 最终回退 (常数项或非整数系数)
                if (Math.abs(coeff - Math.round(coeff)) < tolerance) {
                    return Math.round(coeff).toString();
                }
                
                // 最终回退到小数格式
                return coeff.toFixed(6).replace(/\.?0+$/, '');
            },
            
            // ... [其他辅助函数保持不变] ...
            evaluateTrigonometricExpression(expr) {
                // 调试信息
                console.log('=== evaluateTrigonometricExpression 函数调试 ===');
                console.log('输入表达式:', expr);
                
                let result = expr;
                let changed = true;
                const tolerance = this.tolerance;
                
                const safeTrigPattern = /(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(([^)]+)\)/g;
                let match;
                while ((match = safeTrigPattern.exec(expr)) !== null) {
                    const originalMatch = match[0];
                    const func = match[1];
                    let arg = match[2];
                    
                    console.log('处理三角函数:', originalMatch);
                    console.log('函数名:', func);
                    console.log('参数:', arg);
                    
                    try {
                        // 使用包含π和e的scope计算参数值
                        const scope = { pi: 3.141592653589793, e: 2.718281828459045, i: math.i }; // 新增：支持虚数单位
                        const argValue = math.evaluate(arg, scope);
                        
                        console.log('参数计算值:', argValue);
                        console.log('参数值类型:', typeof argValue);
                        
                        // 检查是否包含虚数（更严格的检查，排除含有i的单词如pi）
                        const argStr = arg.toString();
                        console.log('参数字符串:', argStr);
                        
                        // 更严格的检查：确保i前后不是字母，排除函数名中的i
                        const hasImaginaryI = /(^|\W|[-+*\/])(\d*\.*\d*)\s*i\s*($|\W|[-+*\/])(?![a-zA-Z])/.test(argStr);
                        console.log('hasImaginaryI 正则匹配结果:', hasImaginaryI);
                        
                        const isImaginary = hasImaginaryI || 
                                         (typeof argValue === 'object' && argValue !== null && 'im' in argValue && argValue.im !== 0);
                        
                        console.log('isImaginary:', isImaginary);
                        
                        // 如果是虚数参数，不进行计算，保持原样
                        if (isImaginary) {
                            console.log('跳过虚数参数的计算，保持原样');
                            // 跳过虚数参数的计算，保持原样
                            continue;
                        }
                        
                        // 获取精确值
                        const exactValue = this.getExactTrigValue(func, argValue);
                        
                        if (exactValue && exactValue !== '∞' && exactValue !== '-∞') {
                            result = result.replace(originalMatch, exactValue);
                            changed = true;
                            // 由于替换，表达式长度可能改变，需要重新从头开始搜索
                            safeTrigPattern.lastIndex = 0;
                            expr = result;
                            continue;
                        } else if (exactValue && (exactValue === '∞' || exactValue === '-∞')) {
                            // 遇到无穷大，停止替换
                        } else {
                            // Fallback to numerical evaluation for all cases
                            let funcValue;
                            switch(func) {
                                case 'sin': funcValue = Math.sin(argValue); break;
                                case 'cos': funcValue = Math.cos(argValue); break;
                                case 'tan': funcValue = Math.tan(argValue); break;
                                case 'cot': funcValue = 1 / Math.tan(argValue); break;
                                case 'sec': funcValue = 1 / Math.cos(argValue); break;
                                case 'csc': funcValue = 1 / Math.sin(argValue); break;
                                case 'asin': funcValue = Math.asin(argValue); break;
                                case 'acos': funcValue = Math.acos(argValue); break;
                                case 'atan': funcValue = Math.atan(argValue); break;
                                default: continue;
                            }
                            
                            // 检查是否是有限值
                            if (!isFinite(funcValue)) {
                                // 无穷大情况，替换为∞或-∞
                                // 特殊处理：确保tan(-90°)和tan(-3π/2)显示为-∞
                                let infinityValue = funcValue > 0 ? '∞' : '-∞';
                                
                                // 额外检查特殊情况
                                if (func === 'tan') {
                                    // 检查是否是-90°或-π/2
                                    if ((Math.abs(argValue + Math.PI/2) < tolerance) || 
                                        (Math.abs(argValue + 90*Math.PI/180) < tolerance)) {
                                        infinityValue = '-∞';
                                    }
                                    // 检查是否是3π/2或270°
                                    else if ((Math.abs(argValue - 3*Math.PI/2) < tolerance) || 
                                            (Math.abs(argValue - 270*Math.PI/180) < tolerance)) {
                                        infinityValue = '-∞';
                                    }
                                    // 检查是否是-3π/2或-270°
                                    else if ((Math.abs(argValue + 3*Math.PI/2) < tolerance) || 
                                            (Math.abs(argValue + 270*Math.PI/180) < tolerance)) {
                                        infinityValue = '∞';
                                    }
                                }
                                
                                result = result.replace(originalMatch, infinityValue);
                                // 由于替换，表达式长度可能改变，需要重新从头开始搜索
                                safeTrigPattern.lastIndex = 0;
                                expr = result;
                                changed = true;
                                continue;
                            }
                            
                            let replacement = null;
                            
                            // 检查常见精确值
                            if (Math.abs(funcValue) < tolerance) {
                                replacement = '0';
                            } else if (Math.abs(funcValue - 1) < tolerance) {
                                replacement = '1';
                            } else if (Math.abs(funcValue + 1) < tolerance) {
                                replacement = '-1';
                            } else if (Math.abs(funcValue - 0.5) < tolerance) {
                                replacement = '1/2';
                            } else if (Math.abs(funcValue + 0.5) < tolerance) {
                                replacement = '-1/2';
                            } else if (Math.abs(funcValue - Math.sqrt(2)/2) < tolerance) {
                                replacement = '√2/2';
                            } else if (Math.abs(funcValue + Math.sqrt(2)/2) < tolerance) {
                                replacement = '-√2/2';
                            } else if (Math.abs(funcValue - Math.sqrt(3)/2) < tolerance) {
                                replacement = '√3/2';
                            } else if (Math.abs(funcValue + Math.sqrt(3)/2) < tolerance) {
                                replacement = '-√3/2';
                            } else if (Math.abs(funcValue - 1/Math.sqrt(2)) < tolerance) {
                                replacement = '1/√2';
                            } else if (Math.abs(funcValue + 1/Math.sqrt(2)) < tolerance) {
                                replacement = '-1/√2';
                            } else if (Math.abs(funcValue - 1/Math.sqrt(3)) < tolerance) {
                                replacement = '1/√3';
                            } else if (Math.abs(funcValue + 1/Math.sqrt(3)) < tolerance) {
                                replacement = '-1/√3';
                            } else if (Math.abs(funcValue - Math.sqrt(3)) < tolerance) {
                                replacement = '√3';
                            } else if (Math.abs(funcValue + Math.sqrt(3)) < tolerance) {
                                replacement = '-√3';
                            } else if (Math.abs(funcValue - Math.sqrt(2)) < tolerance) {
                                replacement = '√2';
                            } else if (Math.abs(funcValue + Math.sqrt(2)) < tolerance) {
                                replacement = '-√2';
                            } else {
                                // 对于其他值，使用数值近似
                                replacement = funcValue.toFixed(6).replace(/\.?0+$/, '');
                            }
                            
                            if (replacement !== null) {
                                result = result.replace(originalMatch, replacement);
                                safeTrigPattern.lastIndex = 0;
                                expr = result;
                                changed = true;
                                continue;
                            }
                        }
                    } catch (e) {
                        // 忽略解析错误
                    }
                }
                return result;
            },
            
            // 简化数值表达式
            evaluateMathematicalExpression(expr) {
                try {
                    // 如果表达式只包含常数，则直接计算
                    if (this.isConstantExpression(expr)) {
                        // 针对 pi 和 e 的特殊处理
                        if (expr === 'pi') { return 'π'; }
                        if (expr === 'e') { return 'e'; }
                        if (expr === 'i') { return 'i'; }
                        
                        // 创建包含π、e和i的scope
                        const scope = { pi: 3.141592653589793, e: 2.718281828459045, i: math.i }; // 支持虚数单位
                        const result = math.evaluate(expr, scope);
                        
                        // 检查是否为无穷大
                        if (!isFinite(result)) {
                            // 检查是否是虚数结果
                            if (result.toString().includes('i') || 
                                (typeof result === 'object' && result !== null && 're' in result && 'im' in result)) {
                                // 虚数不是无穷大，继续处理
                            } else {
                                // 返回∞或-∞
                                return result > 0 ? '∞' : '-∞';
                            }
                        }
                        
                        // 如果是特殊值，返回精确表示
                        const exactValue = this.getExactValue(result);
                        if (exactValue) {
                            return exactValue;
                        }
                        
                        // 检查结果是否为常见的π和e的组合
                        if (this.isPiOrECombination(result)) {
                            return this.formatPiOrECombination(result);
                        }
                        
                        // 处理虚数结果
                        if (this.containsImaginary(expr)) {
                            return this.formatComplexNumber(result);
                        }
                        
                        // 否则返回数值
                        if (Math.abs(result) < this.tolerance) return '0';
                        return Math.abs(result - Math.round(result)) < this.tolerance ? Math.round(result).toString() : result.toFixed(6).replace(/\.?0+$/, '');
                    }
                    return expr;
                } catch (error) {
                    return expr;
                }
            },
            
            // 新增：检查结果是否为π和e的组合
            isPiOrECombination(value) {
                const tolerance = this.tolerance;
                const pi = math.pi;
                const e = math.e;
                
                // 检查是否为π的倍数
                if (Math.abs(value / pi - Math.round(value / pi)) < tolerance) {
                    return true;
                }
                
                // 检查是否为e的倍数
                if (Math.abs(value / e - Math.round(value / e)) < tolerance) {
                    return true;
                }
                
                // 检查是否为π+e的组合
                if (Math.abs(value - (pi + e)) < tolerance) {
                    return true;
                }
                
                // 检查是否为π-e的组合
                if (Math.abs(value - (pi - e)) < tolerance) {
                    return true;
                }
                
                // 检查是否为e-π的组合
                if (Math.abs(value - (e - pi)) < tolerance) {
                    return true;
                }
                
                return false;
            },
            
            // 新增：格式化π和e的组合
            formatPiOrECombination(value) {
                const tolerance = this.tolerance;
                const pi = math.pi;
                const e = math.e;
                
                // 检查是否为π的倍数
                const piMultiple = Math.round(value / pi);
                if (Math.abs(value / pi - piMultiple) < tolerance) {
                    if (piMultiple === 1) return 'π';
                    if (piMultiple === -1) return '-π';
                    if (piMultiple === 0) return '0';
                    return `${piMultiple}π`;
                }
                
                // 检查是否为e的倍数
                const eMultiple = Math.round(value / e);
                if (Math.abs(value / e - eMultiple) < tolerance) {
                    if (eMultiple === 1) return 'e';
                    if (eMultiple === -1) return '-e';
                    if (eMultiple === 0) return '0';
                    return `${eMultiple}e`;
                }
                
                // 检查是否为π+e的组合
                if (Math.abs(value - (pi + e)) < tolerance) {
                    return 'π + e';
                }
                
                // 检查是否为π-e的组合
                if (Math.abs(value - (pi - e)) < tolerance) {
                    return 'π - e';
                }
                
                // 检查是否为e-π的组合
                if (Math.abs(value - (e - pi)) < tolerance) {
                    return 'e - π';
                }
                
                // 如果都不是，返回数值
                return value.toFixed(6).replace(/\.?0+$/, '');
            },
            
            // 修改：检查表达式是否包含无理数（更严格的条件）
            containsIrrational(expr) {
                // 只有e和π等无理数参加的常数运算才使用≈
                // 三角函数及反三角函数，函数中含π的最终结果都应该化简到最简
                
                // 检查是否包含π和e的常数运算
                const hasPi = expr.includes('pi') || expr.includes('π');
                const hasE = expr.includes('e');
                
                // 检查是否包含sqrt
                const hasSqrt = expr.includes('sqrt') || expr.includes('√');
                
                // 检查是否包含对数
                const hasLog = expr.includes('log') || expr.includes('ln') || expr.includes('lg');
                
                // 只有当表达式包含π、e、sqrt或对数，并且不包含变量时，才认为是无理数运算
                const hasVariable = /[a-df-hj-np-qt-wyz]/i.test(expr.replace(/pi|e|π|3\.141592653589793|2\.718281828459045|i/g, ''));
                
                return (hasPi || hasE || hasSqrt || hasLog) && !hasVariable;
            },
            
            // 新增：格式化复数结果
            formatComplexNumber(result) {
                // 如果结果是复数对象
                if (typeof result === 'object' && result !== null && 're' in result && 'im' in result) {
                    const re = result.re;
                    const im = result.im;
                    const tolerance = this.tolerance;
                    
                    // 处理实部
                    let realPart = '';
                    if (Math.abs(re) > tolerance) {
                        if (Math.abs(re - Math.round(re)) < tolerance) {
                            realPart = Math.round(re).toString();
                        } else {
                            realPart = re.toFixed(6).replace(/\.?0+$/, '');
                        }
                    }
                    
                    // 处理虚部
                    let imagPart = '';
                    if (Math.abs(im) > tolerance) {
                        if (Math.abs(Math.abs(im) - 1) < tolerance) {
                            imagPart = im > 0 ? 'i' : '-i';
                        } else {
                            const absIm = Math.abs(im);
                            if (Math.abs(absIm - Math.round(absIm)) < tolerance) {
                                imagPart = (im > 0 ? '' : '-') + Math.round(absIm) + 'i';
                            } else {
                                imagPart = (im > 0 ? '' : '-') + absIm.toFixed(6).replace(/\.?0+$/, '') + 'i';
                            }
                        }
                    }
                    
                    // 组合结果
                    if (realPart && imagPart) {
                        return realPart + (imagPart.startsWith('-') ? imagPart : '+' + imagPart);
                    } else if (realPart) {
                        return realPart;
                    } else if (imagPart) {
                        return imagPart;
                    } else {
                        return '0';
                    }
                }
                
                // 如果结果是字符串形式的复数
                if (typeof result === 'string') {
                    // 直接返回字符串形式的结果
                    return result;
                }
                
                // 其他情况返回原始结果
                return result.toString();
            },
            
            // 新增：检查结果是否包含虚数
            containsImaginary(result) {
                // 调试信息
                console.log('=== containsImaginary 函数调试 ===');
                console.log('输入结果:', result);
                
                // 首先检查结果字符串是否包含i，但要排除函数名中的i
                // 例如：sin, cos, tan, asin, acos, atan等函数名中的i不应该被识别为虚数
                if (result.includes('i')) {
                    console.log('结果包含字母 i');
                    
                    // 修改：使用更精确的正则表达式匹配各种形式的虚数
                    // 匹配单独的i、数字+i、数字-i、i+数字、i-数字等形式
                    // 更严格的检查：确保i前后不是字母，排除函数名中的i
                    const hasImaginaryI = /(^|\W|[-+*\/])(\d*\.*\d*)\s*i\s*($|\W|[-+*\/])(?![a-zA-Z])/.test(result);
                    console.log('hasImaginaryI 正则匹配结果:', hasImaginaryI);
                    
                    if (hasImaginaryI) {
                        console.log('返回 true (hasImaginaryI)');
                        return true;
                    }
                    
                    // 检查是否在函数参数中有i，如 sin(i), cos(i) 等
                    // 修复：排除函数参数中的 pi，避免错误匹配
                    const hasImaginaryInFunction = /(sin|cos|tan|cot|sec|csc|asin|acos|atan|log|ln|lg|sqrt|exp)\s*\(\s*[^)]*i[^)]*\)/.test(result) && !/pi/i.test(result);
                    console.log('hasImaginaryInFunction 正则匹配结果:', hasImaginaryInFunction);
                    
                    if (hasImaginaryInFunction) {
                        console.log('返回 true (hasImaginaryInFunction)');
                        return true;
                    }
                    
                    // 检查是否在函数后有i，如 cosi, sini 等
                    const hasImaginaryAfterFunction = /(sin|cos|tan|cot|sec|csc|asin|acos|atan|log|ln|lg|sqrt|exp)i\b/.test(result);
                    console.log('hasImaginaryAfterFunction 正则匹配结果:', hasImaginaryAfterFunction);
                    
                    if (hasImaginaryAfterFunction) {
                        console.log('返回 true (hasImaginaryAfterFunction)');
                        return true;
                    }
                } else {
                    console.log('结果不包含字母 i');
                }
                
                // 检查结果是否是复数对象
                try {
                    const evaluated = math.evaluate(result, { i: math.i });
                    console.log('math.evaluate 结果:', evaluated);
                    console.log('evaluated 类型:', typeof evaluated);
                    
                    if (typeof evaluated === 'object' && evaluated !== null && 're' in evaluated && 'im' in result) {
                        console.log('evaluated.im:', evaluated.im);
                        const hasImaginaryPart = evaluated.im !== 0;
                        console.log('返回', hasImaginaryPart, '(复数对象虚部不为0)');
                        return hasImaginaryPart;
                    }
                } catch (e) {
                    console.log('math.evaluate 出错:', e.message);
                }
                
                console.log('返回 false (没有找到虚数)');
                return false;
            },
            
            // 新增：检查结果是否是复数结果（用于显示虚数提示）
            isComplexResult(expression) {
                // 如果表达式为空或无效，直接返回false
                if (!expression || expression.trim() === '') {
                    return false;
                }
                
                try {
                    // 尝试计算表达式，检查结果是否包含虚数部分
                    const scope = { pi: math.pi, e: math.e, i: math.i };
                    const result = math.evaluate(expression, scope);
                    
                    // 如果结果是复数对象且虚部不为0
                    if (typeof result === 'object' && result !== null && 're' in result && 'im' in result) {
                        return Math.abs(result.im) > this.tolerance;
                    }
                    
                    // 如果结果字符串包含i且不是函数名或pi中的i
                    if (typeof result === 'string' && result.includes('i')) {
                        // 检查是否是真正的虚数表达式
                        return /(^|\W)i($|\W)/.test(result) && !/sin|cos|tan|asin|acos|atan|pi/.test(result);
                    }
                    
                    return false;
                } catch (e) {
                    return false;
                }
            },
            
            // 新增：评估虚数表达式，化简虚数幂运算
            evaluateImaginaryExpression(expr) {
                console.log('=== evaluateImaginaryExpression 函数调试 ===');
                console.log('输入表达式:', expr);
                
                let processed = expr;
                
                // 化简虚数幂运算
                // i^1 = i, i^2 = -1, i^3 = -i, i^4 = 1, i^5 = i, ...
                processed = processed.replace(/\bi\^(\d+)\b/g, (match, power) => {
                    const n = parseInt(power);
                    const remainder = n % 4;
                    
                    switch (remainder) {
                        case 0: return '1';
                        case 1: return 'i';
                        case 2: return '-1';
                        case 3: return '-i';
                        default: return 'i^' + power;
                    }
                });
                
                // 合并同类项
                const scope = { i: math.i };
                try {
                    // 使用math.js进行化简，但保留虚数形式
                    const simplified = math.simplify(processed).toString();
                    console.log('math.simplify 结果:', simplified);
                    
                    // 如果结果包含复数，格式化为标准形式
                    if (simplified.includes('i')) {
                        return this.formatComplexNumber(math.evaluate(simplified, scope));
                    } else {
                        return simplified;
                    }
                } catch (e) {
                    console.log('math.simplify 出错:', e.message);
                    return processed;
                }
            },
            
            // 新增：检查值是否是精确值
            isExactValue(value) {
                const tolerance = this.tolerance;
                
                // 检查常见的精确值
                const exactValues = [
                    0, 1, -1, 2, -2, 3, -3, 4, -4, 5, -5, 6, -6, 7, -7, 8, -8, 9, -9, 10, -10,
                    0.5, -0.5, 0.25, -0.25, 0.75, -0.75,
                    Math.sqrt(2), -Math.sqrt(2), Math.sqrt(3), -Math.sqrt(3), Math.sqrt(5), -Math.sqrt(5),
                    Math.sqrt(2)/2, -Math.sqrt(2)/2, Math.sqrt(3)/2, -Math.sqrt(3)/2, Math.sqrt(3)/3, -Math.sqrt(3)/3,
                    1/Math.sqrt(2), -1/Math.sqrt(2), 1/Math.sqrt(3), -1/Math.sqrt(3),
                    math.pi, -math.pi, math.pi/2, -math.pi/2, math.pi/3, -math.pi/3, math.pi/4, -math.pi/4, math.pi/6, -math.pi/6,
                    2*math.pi, -2*math.pi, 3*math.pi, -3*math.pi,
                    math.e, -math.e, math.e/2, -math.e/2,
                    Math.log(2), -Math.log(2), Math.log(10), -Math.log(10)
                ];
                
                return exactValues.some(exact => Math.abs(value - exact) < tolerance);
            },
            
            // 新增：检查原始表达式中是否包含虚数操作
            hasImaginaryOperation(originalExpr, resultExpr) {
                // 调试信息
                console.log('=== hasImaginaryOperation 函数调试 ===');
                console.log('原始表达式:', originalExpr);
                console.log('结果表达式:', resultExpr);
                
                // 检查原始表达式中是否包含虚数单位i
                if (!originalExpr.includes('i')) {
                    console.log('原始表达式不包含字母 i，返回 false');
                    return false;
                }
                
                console.log('原始表达式包含字母 i');
                
                // 检查是否是真正的虚数表达式，排除函数名中的i
                // 更严格的检查：确保i前后不是字母，排除函数名中的i
                const hasImaginaryI = /(^|\W|[-+*\/])(\d*\.*\d*)\s*i\s*($|\W|[-+*\/])(?![a-zA-Z])/.test(originalExpr);
                console.log('hasImaginaryI 正则匹配结果:', hasImaginaryI);
                
                if (hasImaginaryI) {
                    console.log('返回 true (hasImaginaryI)');
                    return true;
                }
                
                // 检查是否在函数参数中有i，如 sin(i), cos(i) 等
                // 修复：排除函数参数中的 pi，避免错误匹配
                const hasImaginaryInFunction = /(sin|cos|tan|cot|sec|csc|asin|acos|atan|log|ln|lg|sqrt|exp)\s*\(\s*[^)]*i[^)]*\)/.test(originalExpr) && !/pi/i.test(originalExpr);
                console.log('hasImaginaryInFunction 正则匹配结果:', hasImaginaryInFunction);
                
                if (hasImaginaryInFunction) {
                    console.log('返回 true (hasImaginaryInFunction)');
                    return true;
                }
                
                // 检查是否在函数后有i，如 cosi, sini 等
                const hasImaginaryAfterFunction = /(sin|cos|tan|cot|sec|csc|asin|acos|atan|log|ln|lg|sqrt|exp)i\b/.test(originalExpr);
                console.log('hasImaginaryAfterFunction 正则匹配结果:', hasImaginaryAfterFunction);
                
                if (hasImaginaryAfterFunction) {
                    console.log('返回 true (hasImaginaryAfterFunction)');
                    return true;
                }
                
                console.log('返回 false (没有找到虚数操作)');
                return false;
            },
            
            // 检查是否是只包含常数的表达式 
            isConstantExpression(expr) {
                // 先移除函数名，再检查变量
                let exprWithoutFunctions = expr;
                
                // 移除常见的函数名，只保留参数部分
                const functionNames = ['sin', 'cos', 'tan', 'cot', 'sec', 'csc', 'asin', 'acos', 'atan', 'acot', 'asec', 'acsc', 
                                     'sinh', 'cosh', 'tanh', 'asinh', 'acosh', 'atanh',
                                     'log', 'ln', 'lg', 'log10', 'sqrt', 'exp', 'abs', 'factorial', 'gamma'];
                
                functionNames.forEach(funcName => {
                    const regex = new RegExp(funcName + '\\s*\\(', 'g');
                    exprWithoutFunctions = exprWithoutFunctions.replace(regex, '(');
                });
                
                // 检查是否包含变量（除了pi、e、i等常数）
                // 排除 π, e 和 i
                const variablePattern = /[a-df-hj-np-qt-wyz]/i;
                if (variablePattern.test(exprWithoutFunctions.replace(/pi|e|π|3\.141592653589793|2\.718281828459045|i/g, ''))) {
                    return false;
                }
                return true;
            },
            
            // 获取精确值表示 (不变)
            getExactValue(value) {
                const tolerance = this.tolerance;
                const pi = 3.141592653589793;
                const e = 2.718281828459045;
                
                // 检查常见精确值
                if (Math.abs(value - pi) < tolerance) return 'π';
                if (Math.abs(value + pi) < tolerance) return '-π';
                if (Math.abs(value - e) < tolerance) return 'e';
                if (Math.abs(value + e) < tolerance) return '-e';
                
                // 检查分数 π/n, nπ/m 等
                for (let i = 2; i <= 6; i++) {
                    if (Math.abs(value - pi/i) < tolerance) return `π/${i}`;
                    if (Math.abs(value + pi/i) < tolerance) return `-π/${i}`;
                }
                
                return null;
            },
            
            // 修改：获取精确三角函数值（增强化简，确保含π的三角函数化简到最简）
            getExactTrigValue(func, value) {
                const tolerance = this.tolerance;
                const pi = 3.141592653589793;
                
                // 常见角度值表（含π的三角函数的最简形式）
                const commonAngles = {
                    '0': { sin: '0', cos: '1', tan: '0', cot: '∞', sec: '1', csc: '∞', 
                           asin: '0', acos: 'π/2', atan: '0', acot: 'π/2', asec: '0', acsc: '∞' },
                    '0.5235987755982988': { sin: '1/2', cos: '√3/2', tan: '1/√3', cot: '√3', sec: '2/√3', csc: '2', // π/6
                                           asin: 'π/6', acos: 'π/3', atan: 'π/6', acot: 'π/3', asec: 'π/3', acsc: 'π/6' },
                    '0.7853981633974483': { sin: '√2/2', cos: '√2/2', tan: '1', cot: '1', sec: '√2', csc: '√2', // π/4
                                           asin: 'π/4', acos: 'π/4', atan: 'π/4', acot: 'π/4', asec: 'π/4', acsc: 'π/4' },
                    '1.0471975511965976': { sin: '√3/2', cos: '1/2', tan: '√3', cot: '1/√3', sec: '2', csc: '2/√3', // π/3
                                           asin: 'π/3', acos: 'π/6', atan: 'π/3', acot: 'π/6', asec: 'π/6', acsc: 'π/3' },
                    '1.5707963267948966': { sin: '1', cos: '0', tan: '∞', cot: '0', sec: '∞', csc: '1', // π/2
                                           asin: 'π/2', acos: '0', atan: 'π/2', acot: '0', asec: '∞', acsc: 'π/2' },
                    '3.141592653589793': { sin: '0', cos: '-1', tan: '0', cot: '∞', sec: '-1', csc: '∞', // π
                                          asin: '0', acos: 'π', atan: '0', acot: 'π', asec: 'π', acsc: '∞' }
                };
                
                // 检查 nπ 的情况
                if (Math.abs(value % pi) < tolerance) {
                    const n = Math.round(value / pi);
                    if (func === 'sin' || func === 'tan') return '0';
                    if (func === 'cos') return n % 2 === 0 ? '1' : '-1';
                    if (func === 'cot' || func === 'csc') {
                        // 检查是否为负无穷大
                        if (func === 'cot' && n % 2 !== 0) return '-∞';
                        return '∞';
                    }
                }
                
                // 检查 nπ + π/2 的情况
                if (Math.abs((value - pi/2) % pi) < tolerance) {
                    const n = Math.round((value - pi/2) / pi);
                    if (func === 'cos' || func === 'cot') return '0';
                    if (func === 'sin') return n % 2 === 0 ? '1' : '-1';
                    if (func === 'tan' || func === 'sec') {
                        // 正确处理tan和sec的无穷大符号
                        // tan(π/2) = +∞, tan(3π/2) = -∞, tan(5π/2) = +∞, ...
                        // tan(-π/2) = -∞, tan(-3π/2) = +∞, tan(-5π/2) = -∞, ...
                        if (n % 2 === 0) {
                            // n为偶数时，如π/2, 5π/2, -3π/2等
                            return (value > 0) ? '∞' : '-∞';
                        } else {
                            // n为奇数时，如3π/2, 7π/2, -π/2等
                            return (value > 0) ? '-∞' : '∞';
                        }
                    }
                }
                
                // 检查常见角度
                for (const [angle, values] of Object.entries(commonAngles)) {
                    const angleNum = parseFloat(angle);
                    
                    // 检查正角度
                    if (Math.abs(value - angleNum) < tolerance) {
                        return values[func];
                    }
                    
                    // 检查负角度
                    if (Math.abs(value + angleNum) < tolerance) {
                        const negativeValues = {
                            'sin': values.sin === '0' || values.sin === '∞' ? values.sin : `-${values.sin}`,
                            'cos': values.cos,
                            'tan': values.tan === '0' || values.tan === '∞' ? values.tan : `-${values.tan}`,
                            'cot': values.cot === '0' || values.cot === '∞' ? values.cot : `-${values.cot}`,
                            'sec': values.sec,
                            'csc': values.csc === '0' || values.csc === '∞' ? values.csc : `-${values.csc}`
                        };
                        return negativeValues[func].replace(/--/g, ''); // 确保不是双重负号
                    }
                }
                
                return null;
            },

            // **新增或修改:** 提取并生成常数近似值注解
            generateApproximationNote(originalExpr, finalValue) {
                const scope = { pi: math.pi, e: math.e, i: math.i }; // 新增：支持虚数单位
                const approximations = [];
                const uniqueSymbols = new Set();
                
                // 检查是否包含无理数
                let hasIrrational = false;
                
                // 1. 扫描 e 和 pi
                if (originalExpr.includes('e')) {
                    uniqueSymbols.add('e');
                    hasIrrational = true;
                }
                if (originalExpr.includes('pi') || originalExpr.includes('π')) {
                    uniqueSymbols.add('π');
                    hasIrrational = true;
                }
                
                // 2. 扫描 sqrt(N) 和 √N
                const sqrtPatterns = [
                    /sqrt\(([^)]+)\)/g,  // sqrt(N) 形式
                    /√\(([^)]+)\)/g,     // √(N) 形式
                    /√(\d+)/g           // √N 形式 (如 √2, √3)
                ];
                
                sqrtPatterns.forEach(sqrtPattern => {
                    let match;
                    while ((match = sqrtPattern.exec(originalExpr)) !== null) {
                        try {
                            const arg = match[1];
                            const value = math.evaluate(arg, scope);
                            // 考虑所有正数参数
                            if (Number.isFinite(value) && value > 0 && value !== 1) {
                                // 如果是 √N 形式，显示为 √N 而不是 √(N)
                                const displaySymbol = match[0].startsWith('√(') ? `√${value}` : `√(${value})`;
                                uniqueSymbols.add(displaySymbol);
                                hasIrrational = true;
                            }
                        } catch (e) { /* 忽略复杂的 sqrt */ }
                    }
                });
                
                // 3. 扫描 ln/lg/logN
                // 转换后的形式: log(v, N), log10(v), log(v) (自然对数)
                const logPattern = /(log\(([^,]+)\)|log10\(([^)]+)\)|log\(([^,]+),([^)]+)\))/g;
                let normalizedExpr = originalExpr.replace(/ln\(/g, 'log(').replace(/lg\(/g, 'log10(');
                normalizedExpr = normalizedExpr.replace(/\blog([0-9]+)\s*\(([^)]+)\)/g, 'log($2, $1)');
                // 新增：转换 log(底数)(真数) 格式为 log(真数, 底数)
                normalizedExpr = normalizedExpr.replace(/\blog\s*\(\s*([^()]+)\s*\)\s*\(\s*([^()]+)\s*\)/g, 'log($2, $1)');

                normalizedExpr.match(logPattern)?.forEach(logTerm => {
                     uniqueSymbols.add(logTerm);
                     hasIrrational = true;
                });
                
                // 4. 新增：扫描常见无理数组合，如 π/2, π/3, π/4, π/6 等
                const piPatterns = [
                    { pattern: /pi\/2/, symbol: 'π/2' },
                    { pattern: /pi\/3/, symbol: 'π/3' },
                    { pattern: /pi\/4/, symbol: 'π/4' },
                    { pattern: /pi\/6/, symbol: 'π/6' },
                    { pattern: /2\*pi/, symbol: '2π' },
                    { pattern: /3\*pi/, symbol: '3π' },
                    { pattern: /pi\*2/, symbol: '2π' },
                    { pattern: /pi\*3/, symbol: '3π' }
                ];
                
                piPatterns.forEach(({ pattern, symbol }) => {
                    if (pattern.test(originalExpr)) {
                        uniqueSymbols.add(symbol);
                        hasIrrational = true;
                    }
                });
                
                // 5. 格式化列表
                uniqueSymbols.forEach(symbol => {
                    let value;
                    let displaySymbol;
                    
                    if (symbol === 'e') {
                        value = math.e;
                        displaySymbol = 'e';
                    } else if (symbol === 'π') {
                        value = math.pi;
                        displaySymbol = 'π';
                    } else if (symbol.startsWith('√(')) {
                        const num = parseFloat(symbol.substring(2, symbol.length - 1));
                        value = Math.sqrt(num);
                        displaySymbol = `√${num}`;
                    } else if (symbol.startsWith('π/')) {
                        // 处理 π/n 形式
                        const denominator = parseFloat(symbol.substring(2));
                        value = math.pi / denominator;
                        displaySymbol = `π/${denominator}`;
                    } else if (symbol.endsWith('π')) {
                        // 处理 nπ 形式
                        const multiplier = parseFloat(symbol.substring(0, symbol.length - 1));
                        value = multiplier * math.pi;
                        displaySymbol = `${multiplier}π`;
                    } else if (symbol.startsWith('log')) {
                        // For log/ln/lg terms, evaluate their value but display the function
                         try {
                            // 检查是否是log(底数)(真数)格式，如果是则转换为log(真数, 底数)进行计算
                            let evalSymbol = symbol;
                            const logBaseFormat = symbol.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                            if (logBaseFormat) {
                                evalSymbol = `log(${logBaseFormat[2]}, ${logBaseFormat[1]})`;
                            }
                            
                            value = math.evaluate(evalSymbol, scope);
                            // 转换回显示符号 (使用新的格式化逻辑)
                            if (symbol.startsWith('log10')) displaySymbol = symbol.replace(/log10\(([^)]+)\)/, 'lg($1)');
                            else if (symbol.includes(',')) displaySymbol = symbol.replace(/log\(([^,]+),([^)]+)\)/, 'log<sub>$2</sub>($1)');
                            else if (logBaseFormat) {
                                displaySymbol = `log<sub>${logBaseFormat[1]}</sub>(${logBaseFormat[2]})`;
                            } else {
                                displaySymbol = symbol.replace(/log\(([^)]+)\)/, 'ln($1)');
                            }
                            
                            // 调试信息
                            console.log('=== generateApproximationNote 中的log处理 ===');
                            console.log('原始symbol:', symbol);
                            console.log('计算用的evalSymbol:', evalSymbol);
                            console.log('计算值:', value);
                            console.log('转换后的displaySymbol:', displaySymbol);
                         } catch (e) {
                            console.log('无法求值的对数项:', symbol, e.message);
                            return; // 无法求值的对数项
                         }
                    } else {
                        return;
                    }
                    
                    // 仅添加有限的、非零的近似值
                    if (isFinite(value) && Math.abs(value) > this.tolerance) {
                        // 检查是否是精确值（如 log2(2)=1）
                        const isExactValue = this.isExactValue(value);
                        const symbol = isExactValue ? '=' : '≈';
                        approximations.push(`${displaySymbol}${symbol}${value.toFixed(6).replace(/\.?0+$/, '')}`);
                    }
                });

                // 修正：判断最终结果是否是无理数
                let finalIsIrrational = false;
                try {
                    const numericalResult = parseFloat(finalValue);
                    if (!isNaN(numericalResult)) {
                        // 检查最终结果是否是常见的无理数值
                        const commonIrrationals = [
                            { value: Math.sqrt(2), tolerance: 1e-10 },
                            { value: Math.sqrt(3), tolerance: 1e-10 },
                            { value: Math.sqrt(5), tolerance: 1e-10 },
                            { value: math.pi, tolerance: 1e-10 },
                            { value: math.e, tolerance: 1e-10 },
                            { value: Math.sqrt(2)/2, tolerance: 1e-10 }, // √2/2
                            { value: Math.sqrt(3)/2, tolerance: 1e-10 }, // √3/2
                            { value: Math.sqrt(3)/3, tolerance: 1e-10 }, // √3/3
                            { value: 1/Math.sqrt(2), tolerance: 1e-10 }, // 1/√2
                            { value: 1/Math.sqrt(3), tolerance: 1e-10 }, // 1/√3
                        ];
                        
                        finalIsIrrational = commonIrrationals.some(irr => 
                            Math.abs(numericalResult - irr.value) < irr.tolerance
                        );
                    }
                } catch (e) {
                    // 如果无法解析为数值，假设不是无理数
                }

                // 修改：当表达式包含无理数时，总是显示近似值注释
                const note = approximations.length > 0 ? `【${approximations.join(', ')}】` : '';
                
                // 根据最终结果是否是无理数决定使用≈还是=
                const symbol = finalIsIrrational ? '≈' : '=';
                return `${symbol} ${finalValue} ${note}`;
            },
            
            displayResult(result) {
                const { outputDiv, stepsDiv } = this.elements;
                
                const integralConstant = (result.operation === 'integral') ? ' + C' : ''; // 只有不定积分才加C
                
                // 检查是否有无穷大项 - 对于所有操作类型都检查
                const hasInfiniteTerms = result.copyText && result.copyText.includes('【') && (result.copyText.includes('∞】') || result.copyText.includes('-∞】'));
                // 检查是否有NaN项但没有无穷大项
                const hasOnlyNaN = result.copyText && result.copyText.includes('log') && 
                                  (result.copyText.includes('log(-3)') || result.copyText.includes('log1(1)') || result.copyText.includes('log(-2)') || result.copyText.includes('=NaN')) &&
                                  !hasInfiniteTerms;
                
                let finalExpression = result.expression;
                let finalCopyText = result.copyText;
                
                // Set Title and Input Display
                let resultTitle = '';
                let inputDisplay = '';

                if (result.operation === 'integral') {
                    inputDisplay = `∫(${this.formatExpressionForDisplay(result.originalExpression)}) d${result.variable}`;
                    resultTitle = '不定积分结果:';
                } else if (result.operation === 'definite_integral') {
                    const lowerDisplay = this.formatExpressionForDisplay(result.lowerLimit || '0');
                    const upperDisplay = this.formatExpressionForDisplay(result.upperLimit || '1');
                    inputDisplay = `∫<sub>${lowerDisplay}</sub><sup>${upperDisplay}</sup>(${this.formatExpressionForDisplay(result.originalExpression)}) d${result.variable}`;
                    resultTitle = '定积分结果:';
                    finalExpression = result.expression;
                    finalCopyText = result.copyText || result.expression;
                } else if (result.operation === 'double_integral') {
                    inputDisplay = `∬(${this.formatExpressionForDisplay(result.originalExpression)}) d${result.variable}d${result.variable2}`;
                    resultTitle = '二重不定积分结果:';
                } else if (result.operation === 'double_definite_integral') {
                    const xLowerDisp = this.formatExpressionForDisplay(result.xLower || '0');
                    const xUpperDisp = this.formatExpressionForDisplay(result.xUpper || '1');
                    const yLowerDisp = this.formatExpressionForDisplay(result.yLower || '0');
                    const yUpperDisp = this.formatExpressionForDisplay(result.yUpper || '1');
                    inputDisplay = `∬<sub>${xLowerDisp}</sub><sup>${xUpperDisp}</sup><sub>${yLowerDisp}</sub><sup>${yUpperDisp}</sup>(${this.formatExpressionForDisplay(result.originalExpression)}) d${result.variable}d${result.variable2}`;
                    resultTitle = '二重定积分结果:';
                    finalExpression = result.expression;
                    finalCopyText = result.copyText || result.expression;
                } else if (result.operation === 'n_definite_integral') {
                    const limitsDisplay = result.limits.map(lim => `[${this.formatExpressionForDisplay(lim.lower)},${this.formatExpressionForDisplay(lim.upper)}]`).join('');
                    const varsDisplay = result.variables.map(v => `d${v}`).join('');
                    inputDisplay = `∫${limitsDisplay}(${this.formatExpressionForDisplay(result.originalExpression)}) ${varsDisplay}`;
                    resultTitle = `${result.integralOrder}重定积分结果:`;
                    finalExpression = result.expression;
                    finalCopyText = result.copyText || result.expression;
                } else if (result.operation === 'simplify') {
                    // **FIX 2: 为纯常数化简修改最终输出格式**
                    const isPureConstant = this.isConstantExpression(result.originalExpression) && !result.originalExpression.includes(result.variable);
                    
                    if (isPureConstant && !hasInfiniteTerms) {
                        inputDisplay = this.formatExpressionForDisplay(result.originalExpression);
                        resultTitle = '数值化简结果:';
                    } else {
                        // 对于化简操作，不在这里预先添加符号，符号将在generateApproximationNote中处理
                        inputDisplay = `${this.formatExpressionForDisplay(result.originalExpression)} `;
                        resultTitle = '化简结果:';
                    }
                } else if (result.operation === 'evaluate') {
                    // inputDisplay for evaluate is handled by appendInfiniteTerms for clarity
                    resultTitle = '求值结果:';
                } else {
                    resultTitle = '计算结果:';
                }
                
                // 定积分、二重定积分和n重定积分直接显示,不需要进一步处理
                if (result.operation === 'definite_integral' || result.operation === 'double_definite_integral' || result.operation === 'n_definite_integral') {
                    // 跳过后续处理,直接显示结果
                } else if (!hasInfiniteTerms) {
                    // 检查表达式是否包含虚数
                    const hasImaginaryInExpression = this.containsImaginary(result.expression) || 
                                                   this.hasImaginaryOperation(result.originalExpression, result.expression);
                    
                    // 调试信息
                    console.log('=== displayResult 中的虚数检查 ===');
                    console.log('result.expression:', result.expression);
                    console.log('hasImaginaryInExpression:', hasImaginaryInExpression);
                    
                    // 只有在不包含虚数时才进行三角函数和数值简化
                    if (!hasImaginaryInExpression) {
                        console.log('表达式不包含虚数，进行三角函数和数值简化');
                        const trigEvaluated = this.evaluateTrigonometricExpression(result.expression);
                        if (trigEvaluated !== result.expression) {
                            finalExpression = trigEvaluated;
                            finalCopyText = finalCopyText.replace(result.expression, trigEvaluated);
                        }
                        
                        const fullyEvaluated = this.evaluateMathematicalExpression(finalExpression);
                        if (fullyEvaluated !== finalExpression) {
                            finalExpression = fullyEvaluated;
                            finalCopyText = finalCopyText.replace(trigEvaluated, fullyEvaluated);
                        }
                        
                        // 确保所有Infinity和-Infinity都被替换为∞和-∞
                        finalExpression = finalExpression.replace(/Infinity/g, '∞').replace(/-Infinity/g, '-∞');
                        finalCopyText = finalCopyText.replace(/Infinity/g, '∞').replace(/-Infinity/g, '-∞');
                        
                        // 确保所有NaN都被保留
                        finalExpression = finalExpression.replace(/NaN/g, 'NaN');
                        finalCopyText = finalCopyText.replace(/NaN/g, 'NaN');
                    } else {
                        console.log('表达式包含虚数，进行虚数特殊处理');
                        // 对虚数表达式进行特殊处理，化简虚数幂运算
                        const imaginaryEvaluated = this.evaluateImaginaryExpression(result.expression);
                        if (imaginaryEvaluated !== result.expression) {
                            finalExpression = imaginaryEvaluated;
                            finalCopyText = finalCopyText.replace(result.expression, imaginaryEvaluated);
                        }
                    }
                }
                
                // **关键点: 确保最终显示和 CopyText 都经过 formatExpressionForDisplay 处理**
                const displayExpression = this.formatExpressionForDisplay(finalExpression);
                // 清理displayExpression中的HTML标签，用于原始表达式显示
                const cleanDisplayExpression = this.stripHtmlTags(displayExpression);

                let constantApproximationHTML = '';

                // **FIX 2: 最终结果注解**
                if (result.operation === 'simplify' && !hasInfiniteTerms && resultTitle.startsWith('数值化简结果')) {
                    // 保存finalExpression的值，用于虚数检查
                    const savedFinalExpression = finalExpression;
                    
                    // 对于数值化简，需要显示处理后的原始表达式（包含乘法符号）
                    const processedOriginalExpr = result.displayExpression || this.formatOriginalExpression(result.originalExpression);
                    const approximationNote = this.generateApproximationNote(
                        result.originalExpression, 
                        finalExpression // 已经是最终数值
                    );
                    
                    // 在这里进行虚数检查
                    const hasImaginary = this.containsImaginary(savedFinalExpression);
                    // 只有在原始表达式中真正包含i时才检查虚数操作
                    const hasImaginaryOp = result.originalExpression.includes('i') ? this.hasImaginaryOperation(result.originalExpression, savedFinalExpression) : false;
                    
                    // 调试信息
                    console.log('=== 数值化简情况下的虚数检查 ===');
                    console.log('原始表达式:', result.originalExpression);
                    console.log('savedFinalExpression:', savedFinalExpression);
                    console.log('hasImaginary:', hasImaginary);
                    console.log('result.originalExpression.includes("i"):', result.originalExpression.includes('i'));
                    console.log('hasImaginaryOp:', hasImaginaryOp);
                    
                    const imaginaryNote = (hasImaginary || hasImaginaryOp) ? '<span style="color: #9b59b6; font-size: 0.9em;">【i为虚数】</span>' : '';
                    
                    constantApproximationHTML = `
                        <div class="approximation-text">
                            ${processedOriginalExpr} ${approximationNote} ${imaginaryNote}
                        </div>
                    `;
                    // 最终显示结果不再重复显示原表达式和近似值
                    finalExpression = ''; 
                }
                
                let outputHTML = '';
                
                // 对于化简和求值操作，需要添加适当的等于/约等于符号
                let finalOutputText;
                let finalCopyValue;
                
                if (hasInfiniteTerms) {
                    // 如果有无穷大项，显示原始表达式等于结果
                    const originalExpr = result.displayExpression || this.formatOriginalExpression(result.originalExpression);
                    finalOutputText = `${originalExpr} = ${finalCopyText}`;
                    finalCopyValue = `${this.stripHtmlTags(originalExpr)} = ${finalCopyText}`;
                } else if (hasOnlyNaN) {
                    // 如果只有NaN项而没有真正的无穷大项，也显示原始表达式等于结果
                    const originalExpr = result.displayExpression || this.formatOriginalExpression(result.originalExpression);
                    finalOutputText = `${originalExpr} = ${finalCopyText}`;
                    finalCopyValue = `${this.stripHtmlTags(originalExpr)} = ${finalCopyText}`;
                } else if (constantApproximationHTML) {
                    // 数值化简情况，已经在constantApproximationHTML中处理了符号
                    finalOutputText = '';
                    finalCopyValue = finalExpression;
                } else if (result.operation === 'definite_integral' || result.operation === 'double_definite_integral' || result.operation === 'n_definite_integral') {
                    // 定积分、二重定积分和n重定积分特殊处理: 直接显示积分符号 = 结果
                    finalOutputText = `${inputDisplay} = ${displayExpression}`;
                    finalCopyValue = `${this.stripHtmlTags(inputDisplay)} = ${this.stripHtmlTags(displayExpression)}`;
                } else if (result.operation === 'evaluate' || result.operation === 'simplify') {
                    // 对于求值和化简，使用generateApproximationNote确定符号
                    const approximationNote = this.generateApproximationNote(
                        result.originalExpression, 
                        cleanDisplayExpression
                    );
                    
                    // 从approximationNote中提取符号和结果
                    const symbolMatch = approximationNote.match(/^(=|≈)\s+(.+?)(?:\s*\【|$)/);
                    if (symbolMatch) {
                        const symbol = symbolMatch[1];
                        const resultValue = symbolMatch[2];
                        const displayExpr = result.displayExpression || this.formatOriginalExpression(result.originalExpression);
                        finalOutputText = `${displayExpr} ${symbol} ${resultValue}${integralConstant}`;
                        finalCopyValue = `${this.stripHtmlTags(displayExpr)} ${symbol} ${resultValue}${integralConstant}`;
                    } else {
                        // 备用方案
                        finalOutputText = `${inputDisplay}${displayExpression}${integralConstant}`;
                        finalCopyValue = `${this.stripHtmlTags(inputDisplay)}${this.stripHtmlTags(displayExpression)}${integralConstant}`;
                    }
                    
                    // 添加近似值注释到最终输出
                    const approximationNoteMatch = approximationNote.match(/【(.+?)】$/);
                    if (approximationNoteMatch) {
                        const approximationText = approximationNoteMatch[1];
                        finalOutputText += ` 【${approximationText}】`;
                        finalCopyValue += ` 【${approximationText}】`;
                    }
                } else {
                    // 其他操作类型
                    finalOutputText = `${inputDisplay}${displayExpression}${integralConstant}`;
                    finalCopyValue = `${this.stripHtmlTags(inputDisplay)}${this.stripHtmlTags(displayExpression)}${integralConstant}`;
                }

                // 检查是否包含虚数 - 只有在结果中真正包含虚数时才显示提示
                // 修复：当finalExpression为空时（数值化简情况），不检查虚数
                let hasImaginary = false;
                let imaginaryNote = '';
                
                if (finalExpression && finalExpression.trim() !== '') {
                    hasImaginary = this.containsImaginary(finalExpression);
                    imaginaryNote = hasImaginary && (finalExpression.includes('i') || this.isComplexResult(finalExpression)) ? '<span style="color: #9b59b6; font-size: 0.9em;">【i为虚数】</span>' : '';
                }

                outputHTML += `
                    <div class="math-expression">
                        <div class="result-title">${resultTitle}</div>
                        ${constantApproximationHTML ? constantApproximationHTML : `<div class="result-text">${finalOutputText} ${imaginaryNote}</div>`}
                        <i class="fas fa-copy copy-icon" title="复制结果" data-text="${finalCopyValue}"></i>
                    </div>
                `;
                
                outputDiv.innerHTML = outputHTML;
                
                if (result.steps && result.steps.length > 0 && !hasInfiniteTerms) {
                    const stepsTitle = document.createElement('h3');
                    stepsTitle.innerHTML = '<i class="fas fa-list-ol"></i> 计算步骤';
                    stepsDiv.appendChild(stepsTitle);
                    
                    // Display steps with formatting
                    result.steps.forEach((step, index) => {
                        const stepElement = document.createElement('div');
                        stepElement.className = 'step';
                        
                        // 使用 cleanMathJSText 确保步骤中的 pi 和 sqrt 被正确格式化
                        let displayStep = this.cleanMathJSText(step);
                        
                        // 对于第一个步骤（原函数），使用原始表达式形式
                        if (index === 0) {
                            displayStep = displayStep.replace(this.formatExpressionForDisplay(result.originalExpression), 
                                                          result.displayExpression || this.formatOriginalExpression(result.originalExpression));
                        }
                        
                        displayStep = this.formatExpressionForDisplay(displayStep);
                            
                        stepElement.innerHTML = `
                            <div class="step-title">
                                <i class="fas fa-arrow-right"></i> 步骤 ${index + 1} 
                            </div>
                            <div class="result-text">${displayStep}</div>
                        `;
                        stepsDiv.appendChild(stepElement);
                    });
                }
                
                this.addCopyFunctionality();
            },
            
            displayError(message, expression) {
                const { outputDiv } = this.elements;
                outputDiv.innerHTML = `
                    <div class="error">
                        <strong>计算错误:</strong> ${message} 
                    </div>
                    <div class="math-expression">
                        <div class="result-title">输入表达式:</div>
                        <div class="result-text">${this.formatExpressionForDisplay(expression)}</div>
                    </div>
                `;
            },
            
            handleClear() {
                const { expressionInput, outputDiv, stepsDiv, variableInputs } = this.elements;
                expressionInput.value = '';
                outputDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d; padding: 30px;">计算结果将显示在这里...</p>';
                stepsDiv.innerHTML = '';
                variableInputs.innerHTML = '';
                this.cache.clear();
            },
            
            calculate(expression, operation, variable, nthOrder, nSamples) {
                const lowerLimit = this.elements.lowerLimitInput?.value || '0';
                const upperLimit = this.elements.upperLimitInput?.value || '1';
                const var2 = this.elements.variable2Input?.value || 'y';
                const var2Def = this.elements.variable2DefiniteInput?.value || 'y';
                
                const nIntegralOrder = this.elements.nVariablesInput?.value.split(',').length || 'n';
                
                const operationNames = {
                    'derivative': '一阶导数 (d/dx)',
                    'integral': '积分 (∫ dx)',
                    'definite_integral': `定积分 (∫[${lowerLimit},${upperLimit}] dx)`,
                    'double_integral': `二重不定积分 (∬ d${variable}d${var2})`,
                    'double_definite_integral': `二重定积分 (∬ d${variable}d${var2Def})`,
                    'n_definite_integral': `${nIntegralOrder}重定积分`,
                    'second_derivative': '二阶导数 (d²/dx²)',
                    'nth_derivative': `n阶导数 (d^${nthOrder}/d${variable}^${nthOrder})`,
                    'simplify': '表达式化简',
                    'evaluate': '表达式求值'
                };
                
                let result;
                
                switch (operation) {
                    case 'derivative':
                        result = this.calculateDerivative(expression, variable);
                        break;
                    case 'integral':
                        result = this.calculateIntegral(expression, variable);
                        break;
                    case 'definite_integral':
                        result = this.calculateDefiniteIntegral(expression, variable, lowerLimit, upperLimit);
                        break;
                    case 'double_integral':
                        const var2 = this.elements.variable2Input.value.trim() || 'y';
                        result = this.calculateDoubleIntegral(expression, variable, var2);
                        break;
                    case 'double_definite_integral':
                        const var2Def = this.elements.variable2DefiniteInput.value.trim() || 'y';
                        const xLower = this.elements.xLowerInput.value.trim();
                        const xUpper = this.elements.xUpperInput.value.trim();
                        const yLower = this.elements.yLowerInput.value.trim();
                        const yUpper = this.elements.yUpperInput.value.trim();
                        result = this.calculateDoubleDefiniteIntegral(expression, variable, var2Def, xLower, xUpper, yLower, yUpper);
                        break;
                    case 'n_definite_integral':
                        // 自动检测表达式中的变量，而不是使用用户输入的变量列表
                        const detectedVars = this.detectVariables(expression);
                        
                        // 如果没有检测到变量，使用默认变量x
                        const nVariables = detectedVars.length > 0 ? detectedVars : ['x'];
                        
                        // 获取用户输入的积分区间
                        const nLimits = this.elements.nLimitsInput.value.trim().split(';').map(limit => {
                            const [lower, upper] = limit.split(',').map(v => v.trim());
                            return { lower, upper };
                        });
                        
                        // 如果用户输入的区间数量与检测到的变量数量不匹配，调整区间数量
                        if (nLimits.length < nVariables.length) {
                            // 如果区间数量不足，使用默认区间[0,1]补充
                            while (nLimits.length < nVariables.length) {
                                nLimits.push({ lower: '0', upper: '1' });
                            }
                        }
                        // 区间数量多于变量数量时，保持不变，正常计算即可
                        
                        const userSamples = parseInt(nSamples) || 10000000;
                        result = this.calculateNDefiniteIntegral(expression, nVariables, nLimits, userSamples);
                        break;
                    case 'second_derivative':
                        result = this.calculateNthDerivative(expression, variable, 2);
                        break;
                    case 'nth_derivative':
                        result = this.calculateNthDerivative(expression, variable, nthOrder);
                        break;
                    case 'simplify':
                        result = this.calculateSimplify(expression, variable);
                        break;
                    case 'evaluate':
                        result = this.evaluateExpression(expression);
                        break;
                    default:
                        throw new Error('不支持的计算类型');
                }
                
                result.operation = operation;
                result.variable = variable;
                result.name = operationNames[operation];
                result.originalExpression = expression;
                
                return result;
            },
            
            // 增强的求导函数，包含合并同类项逻辑和任意对数求导支持
            calculateDerivative(expr, varName) {
                const steps = [`原函数: ${this.formatExpressionForDisplay(expr)}`];
                try {
                    // 对于包含对数函数的表达式，直接使用特殊处理，不进行合并同类项
                    if (this.containsLogarithm(expr)) {
                        steps.push(`检测到对数函数，使用特殊求导规则`);
                        const logDerivative = this.calculateLogarithmDerivative(expr, varName);
                        if (logDerivative) {
                            steps.push(`对数求导结果: ${this.cleanMathJSText(logDerivative)}`);
                            const copyText = `d/d${varName}(${this.cleanMathJSText(expr)}) = ${this.cleanMathJSText(logDerivative)}`;
                            return { expression: this.cleanMathJSText(logDerivative), steps, copyText };
                        }
                    }
                    
                    // 增强: 先合并同类项，解决常数项过多导致求导卡死的问题
                    const mergedExpr = this.mergeLikeTerms(expr, varName);
                    if (mergedExpr !== expr) {
                        steps.push(`预处理 (合并同类项): ${this.cleanMathJSText(mergedExpr)}`);
                    }
                    
                    // math.derivative 内部会自动尝试 simplify，这里直接使用合并后的表达式
                    const result = math.derivative(mergedExpr, varName).toString();
                    
                    // 确保结果的常数部分也被简化
                    const finalResult = this.mergeLikeTerms(result, varName);

                    const copyText = `d/d${varName}(${this.cleanMathJSText(expr)}) = ${this.cleanMathJSText(finalResult)}`;
                    return { expression: this.cleanMathJSText(finalResult), steps, copyText };
                } catch (error) {
                    const copyText = `d/d${varName}(${this.cleanMathJSText(expr)}) = 无法计算该导数`;
                    return { expression: "无法计算该导数", steps: [`发生错误: ${error.message}`], copyText, error: error.message };
                }
            },
            
            // 增强的 n 阶求导函数，包含合并同类项逻辑和对数求导支持
            calculateNthDerivative(expr, varName, order) {
                const steps = [`原函数: ${this.formatExpressionForDisplay(expr)}`, `计算 ${order} 阶导数`];
                const orderNum = parseInt(order);
                if (isNaN(orderNum) || orderNum < 1) {
                    throw new Error('阶数必须是一个大于等于 1 的整数');
                }
                
                // 增强: 先合并同类项，解决常数项过多导致求导卡死的问题
                let currentExpr = this.mergeLikeTerms(expr, varName);
                if (currentExpr !== expr) {
                    steps.push(`预处理 (合并同类项): ${this.cleanMathJSText(currentExpr)}`);
                }
                
                for (let i = 1; i <= orderNum; i++) {
                    // 确保每一阶导数都是从简化后的表达式开始
                    currentExpr = this.mergeLikeTerms(currentExpr, varName);
                    
                    // 检查是否包含对数函数，进行特殊处理
                    if (this.containsLogarithm(currentExpr)) {
                        steps.push(`第 ${i} 阶导数: 检测到对数函数，使用特殊求导规则`);
                        const logDerivative = this.calculateLogarithmDerivative(currentExpr, varName);
                        if (logDerivative) {
                            currentExpr = logDerivative;
                        } else {
                            // 如果对数求导失败，使用默认方法
                            currentExpr = math.derivative(currentExpr, varName).toString();
                        }
                    } else {
                        currentExpr = math.derivative(currentExpr, varName).toString();
                    }
                    
                    steps.push(`第 ${i} 阶导数: ${this.cleanMathJSText(currentExpr)}`);
                }
                
                // 确保最终结果被简化
                const finalResult = this.mergeLikeTerms(currentExpr, varName);
                
                const copyText = `d^${order}/d${varName}^${order}(${this.cleanMathJSText(expr)}) = ${this.cleanMathJSText(finalResult)}`;
                return { expression: this.cleanMathJSText(finalResult), steps, copyText };
            },
            
            // 积分函数 (已修改：移除 math.simplify, 确保分数显示)
            calculateIntegral(expr, varName) {
                const steps = [`被积函数: ${this.formatExpressionForDisplay(expr)}`];
                try {
                    // 1. 优化：先合并同类项
                    const mergedExpr = this.mergeLikeTerms(expr, varName);
                    if (mergedExpr !== expr) {
                        steps.push(`步骤1: 合并同类项: ${this.cleanMathJSText(mergedExpr)}`);
                    }
                    
                    // 2. 展开多项式
                    const expanded = this.expandPolynomial(mergedExpr, varName);
                    if (expanded !== mergedExpr) {
                        steps.push(`步骤2: 展开多项式: ${this.cleanMathJSText(expanded)}`);
                    }
                    
                    // 3. 将表达式拆分为项并逐项积分
                    const node = math.parse(expanded);
                    const terms = [];
                    this.extractTerms(node, terms);
                    
                    let integratedTerms = [];
                    terms.forEach(term => {
                        const integral = this.integrateTerm(term.node, varName, term.sign);
                        integratedTerms.push(integral);
                    });
                    
                    // 4. 重新组合结果
                    let resultText = integratedTerms.join(' ').trim();
                    
                    // 清理开头的符号
                    resultText = resultText.replace(/^\+\s*/, '');
                    
                    // 清理多余的符号
                    resultText = resultText
                        .replace(/\+\s*\-/g, '- ')
                        .replace(/\-\s*\-/g, '+ ')
                        .replace(/\s+/g, ' ')
                        .replace(/\* /g, '*')
                        .replace(/ \*/g, '*');
                        
                    steps.push(`步骤3: 逐项积分并组合: ${this.cleanMathJSText(resultText)}`);
                    
                    if (!resultText) {
                        resultText = '无法计算该积分';
                    }
                    
                    // 保存原始math.js格式用于定积分计算
                    const rawCopyText = resultText;
                    const copyText = `${this.cleanMathJSText(resultText)}`;
                    return { expression: this.cleanMathJSText(resultText), steps, copyText, rawResult: rawCopyText };
                } catch (error) {
                    const copyText = `无法计算该积分`;
                    return { expression: "无法计算该积分", steps: [`发生错误: ${error.message}`], copyText, error: error.message };
                }
            },
            
            // 定积分计算函数 - 全新简化版本
            calculateDefiniteIntegral(expr, varName, lower, upper) {
                const steps = [];
                
                try {
                    // 步骤1: 显示原始积分
                    steps.push(`原始积分: ∫[${lower}, ${upper}] ${expr} d${varName}`);
                    
                    // 步骤2: 预处理
                    const processedExpr = this.preprocessExpression(expr);
                    const processedLower = this.preprocessExpression(lower);
                    const processedUpper = this.preprocessExpression(upper);
                    
                    // 步骤3: 计算上下限数值
                    const scope = { pi: math.pi, e: math.e };
                    const a = math.evaluate(processedLower, scope);
                    const b = math.evaluate(processedUpper, scope);
                    
                    if (!isFinite(a) || !isFinite(b)) {
                        throw new Error('上下限必须是有限数值');
                    }
                    
                    steps.push(`上下限数值: a=${a}, b=${b}`);
                    
                    // 步骤4: 数值积分 - 使用简单的矩形法
                    const n = 5000; // 分割数
                    const dx = (b - a) / n;
                    let sum = 0;
                    
                    for (let i = 0; i < n; i++) {
                        const x = a + (i + 0.5) * dx; // 中点
                        const evalScope = { ...scope, [varName]: x };
                        const y = math.evaluate(processedExpr, evalScope);
                        
                        if (!isFinite(y)) {
                            throw new Error(`函数在x=${x}处值为${y}`);
                        }
                        
                        sum += y;
                    }
                    
                    const result = sum * dx;
                    
                    steps.push(`使用中点矩形法(n=${n})`);
                    steps.push(`结果: ${result}`);
                    
                    // 格式化结果
                    let finalResult = result.toFixed(8).replace(/\.?0+$/, '');
                    
                    // 接近整数时显示为整数
                    if (Math.abs(result - Math.round(result)) < 1e-6) {
                        finalResult = Math.round(result).toString();
                    }
                    
                    return {
                        expression: finalResult,
                        copyText: finalResult,
                        steps: steps,
                        operation: 'definite_integral',
                        variable: varName,
                        originalExpression: expr,
                        lowerLimit: lower,
                        upperLimit: upper
                    };
                    
                } catch (error) {
                    return {
                        expression: '计算失败',
                        copyText: '计算失败',
                        steps: [`错误: ${error.message}`],
                        error: error.message,
                        operation: 'definite_integral',
                        variable: varName,
                        originalExpression: expr,
                        lowerLimit: lower,
                        upperLimit: upper
                    };
                }
            },
            
            // 二重不定积分计算函数
            calculateDoubleIntegral(expr, var1, var2) {
                const steps = [];
                
                try {
                    steps.push(`计算二重不定积分: ∬ ${expr} d${var1}d${var2}`);
                    
                    // 步骤1: 对第一个变量积分
                    steps.push(`步骤1: 先对${var1}积分`);
                    const firstIntegral = this.calculateIntegral(expr, var1);
                    
                    if (firstIntegral.error) {
                        throw new Error(`对${var1}积分失败: ${firstIntegral.error}`);
                    }
                    
                    // 获取第一次积分的结果(移除+C)
                    let firstResult = firstIntegral.copyText || firstIntegral.expression;
                    firstResult = firstResult.replace(/\s*\+\s*C\s*$/i, '');
                    
                    steps.push(`对${var1}积分结果: ${this.formatExpressionForDisplay(firstResult)}`);
                    
                    // 步骤2: 对第二个变量积分
                    steps.push(`步骤2: 再对${var2}积分`);
                    const secondIntegral = this.calculateIntegral(firstResult, var2);
                    
                    if (secondIntegral.error) {
                        throw new Error(`对${var2}积分失败: ${secondIntegral.error}`);
                    }
                    
                    // 获取最终结果
                    let finalResult = secondIntegral.expression;
                    let copyText = secondIntegral.copyText || finalResult;
                    
                    // 二重积分的积分常数为 C1*x + C2 或 C
                    finalResult = finalResult.replace(/\s*\+\s*C\s*$/i, ' + C');
                    copyText = copyText.replace(/\s*\+\s*C\s*$/i, ' + C');
                    
                    steps.push(`最终结果: ${this.formatExpressionForDisplay(finalResult)}`);
                    
                    return {
                        expression: finalResult,
                        copyText: copyText,
                        steps: steps,
                        operation: 'double_integral',
                        variable: var1,
                        variable2: var2,
                        originalExpression: expr
                    };
                    
                } catch (error) {
                    return {
                        expression: '计算失败',
                        copyText: '计算失败',
                        steps: [`错误: ${error.message}`],
                        error: error.message,
                        operation: 'double_integral',
                        variable: var1,
                        variable2: var2,
                        originalExpression: expr
                    };
                }
            },
            
            // 二重定积分计算函数
            calculateDoubleDefiniteIntegral(expr, var1, var2, x1, x2, y1, y2) {
                const steps = [];
                
                try {
                    steps.push(`计算二重定积分: ∬[${x1},${x2}][${y1},${y2}] ${expr} d${var1}d${var2}`);
                    
                    // 预处理
                    const processedExpr = this.preprocessExpression(expr);
                    const scope = { pi: math.pi, e: math.e };
                    
                    // 计算积分区间
                    const xLower = math.evaluate(this.preprocessExpression(x1), scope);
                    const xUpper = math.evaluate(this.preprocessExpression(x2), scope);
                    const yLower = math.evaluate(this.preprocessExpression(y1), scope);
                    const yUpper = math.evaluate(this.preprocessExpression(y2), scope);
                    
                    steps.push(`积分区间: ${var1}∈[${xLower}, ${xUpper}], ${var2}∈[${yLower}, ${yUpper}]`);
                    
                    // 使用二重数值积分
                    const nx = 100; // x方向分割数
                    const ny = 100; // y方向分割数
                    const dx = (xUpper - xLower) / nx;
                    const dy = (yUpper - yLower) / ny;
                    
                    let sum = 0;
                    
                    for (let i = 0; i < nx; i++) {
                        for (let j = 0; j < ny; j++) {
                            const x = xLower + (i + 0.5) * dx;
                            const y = yLower + (j + 0.5) * dy;
                            
                            const evalScope = { ...scope, [var1]: x, [var2]: y };
                            const fxy = math.evaluate(processedExpr, evalScope);
                            
                            if (!isFinite(fxy)) {
                                throw new Error(`函数在(${x}, ${y})处值为${fxy}`);
                            }
                            
                            sum += fxy;
                        }
                    }
                    
                    const result = sum * dx * dy;
                    
                    steps.push(`使用中点矩形法(nx=${nx}, ny=${ny})`);
                    steps.push(`结果: ${result}`);
                    
                    // 格式化结果
                    let finalResult = result.toFixed(8).replace(/\.?0+$/, '');
                    if (Math.abs(result - Math.round(result)) < 1e-6) {
                        finalResult = Math.round(result).toString();
                    }
                    
                    return {
                        expression: finalResult,
                        copyText: finalResult,
                        steps: steps,
                        operation: 'double_definite_integral',
                        variable: var1,
                        variable2: var2,
                        originalExpression: expr,
                        xLower: x1,
                        xUpper: x2,
                        yLower: y1,
                        yUpper: y2
                    };
                    
                } catch (error) {
                    return {
                        expression: '计算失败',
                        copyText: '计算失败',
                        steps: [`错误: ${error.message}`],
                        error: error.message,
                        operation: 'double_definite_integral',
                        variable: var1,
                        variable2: var2,
                        originalExpression: expr,
                        xLower: x1,
                        xUpper: x2,
                        yLower: y1,
                        yUpper: y2
                    };
                }
            },
            
            // 自动检测表达式中的变量
            detectVariables(expr) {
                try {
                    // 使用math.js解析表达式
                    const node = math.parse(expr);
                    const variables = new Set();
                    
                    // 递归遍历表达式树，收集所有变量
                    const traverse = (node) => {
                        if (node.type === 'SymbolNode' && node.name !== 'pi' && node.name !== 'e') {
                            variables.add(node.name);
                        }
                        if (node.args) {
                            node.args.forEach(traverse);
                        }
                        if (node.content) {
                            traverse(node.content);
                        }
                    };
                    
                    traverse(node);
                    
                    // 转换为数组并保持原始顺序（按出现顺序）
                    const variableList = Array.from(variables);
                    
                    return variableList;
                } catch (error) {
                    console.error('变量检测失败:', error);
                    return [];
                }
            },

            // n重定积分计算 - 三层优化策略
            calculateNDefiniteIntegral(expr, variables, limits, userSamples = 10000000) {
                const steps = [];
                
                try {
                    // 如果没有提供变量列表，尝试从表达式中自动检测
                    let detectedVariables = variables;
                    if (!detectedVariables || detectedVariables.length === 0) {
                        detectedVariables = this.detectVariables(expr);
                        steps.push(`自动检测到变量: ${detectedVariables.join(', ')}`);
                        
                        // 如果没有检测到变量，使用默认变量x
                        if (detectedVariables.length === 0) {
                            detectedVariables = ['x'];
                            steps.push(`未检测到变量，使用默认变量: x`);
                        }
                    }
                    
                    const n = detectedVariables.length;
                    
                    // 参数验证
                    if (n < 1) throw new Error('至少需要1个变量');
                    if (limits.length !== n) throw new Error(`需要${n}个积分区间,但只提供了${limits.length}个`);
                    
                    // 显示积分信息
                    const limitsStr = limits.map((lim, i) => `[${lim.lower},${lim.upper}]`).join('');
                    const varsStr = variables.join('d');
                    steps.push(`计算${n}重定积分: ∫${limitsStr} ${expr} d${varsStr}`);
                    
                    // 预处理与初始化
                    const processedExpr = this.preprocessExpression(expr);
                    const scope = { pi: math.pi, e: math.e };
                    
                    // 计算数值积分区间
                    const numericLimits = limits.map((lim, i) => ({
                        lower: math.evaluate(this.preprocessExpression(lim.lower), scope),
                        upper: math.evaluate(this.preprocessExpression(lim.upper), scope),
                        variable: variables[i]
                    }));
                    
                    steps.push(`积分区间: ${numericLimits.map(lim => `${lim.variable}∈[${lim.lower.toFixed(4)},${lim.upper.toFixed(4)}]`).join(', ')}`);
                    
                    // 终极策略选择
                    const strategy = n <= 2 ? 'romberg' : (n <= 5 ? 'clenshaw' : 'halton');
                    
                    // === 策略1: 高维改进Halton序列 (6维+) ===
                    if (strategy === 'halton') {
                        steps.push(`策略: 改进Halton序列 (准蒙特卡洛+Faure置换, 收敛O(1/N))`);
                        
                        const samples = Math.max(1000, Math.min(100000000, userSamples));
                        const volume = numericLimits.reduce((prod, lim) => prod * (lim.upper - lim.lower), 1);
                        
                        steps.push(`采样数: ${samples.toLocaleString()}, 体积: ${volume.toFixed(6)}`);
                        
                        // 改进的Halton序列 (打乱以减少相关性)
                        const primes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97];
                        
                        const halton = (index, dim) => {
                            const base = primes[dim % primes.length];
                            let result = 0;
                            let f = 1;
                            let i = index + 1; // 从1开始避免0点
                            
                            while (i > 0) {
                                f = f / base;
                                result += f * (i % base);
                                i = Math.floor(i / base);
                            }
                            
                            // 添加Faure置换减少相关性
                            return (result + 0.5 * (dim * 0.618033988749895 % 1)) % 1;
                        };
                        
                        // 分批并行计算
                        const batchSize = 100000;
                        let sum = 0;
                        
                        for (let batch = 0; batch < samples; batch += batchSize) {
                            const end = Math.min(batch + batchSize, samples);
                            let batchSum = 0;
                            
                            for (let i = batch; i < end; i++) {
                                const evalScope = { ...scope };
                                
                                numericLimits.forEach((lim, d) => {
                                    const u = halton(i, d);
                                    evalScope[lim.variable] = lim.lower + u * (lim.upper - lim.lower);
                                });
                                
                                batchSum += math.evaluate(processedExpr, evalScope);
                            }
                            
                            sum += batchSum;
                        }
                        
                        const result = volume * sum / samples;
                        const finalResult = Math.abs(result - Math.round(result)) < 1e-9 ? 
                            Math.round(result).toString() : result.toFixed(14).replace(/\.?0+$/, '');
                        
                        steps.push(`结果: ${finalResult}`);
                        steps.push(`注: Halton+Faure置换减少相关性, 精度优于纯Halton`);
                        
                        return {
                            expression: finalResult, copyText: finalResult, steps,
                            operation: 'n_definite_integral', variables, limits,
                            originalExpression: expr, integralOrder: n
                        };
                    }
                    
                    // === 策略2: 中维Clenshaw-Curtis求积 (3-5维) ===
                    if (strategy === 'clenshaw') {
                        const m = n <= 3 ? 16 : (n === 4 ? 12 : 10); // 每维节点数
                        steps.push(`策略: ${n}重Clenshaw-Curtis求积 (${m}点, 接近最优)`);
                        
                        // Chebyshev节点和权重 (Clenshaw-Curtis)
                        const getNodesWeights = (N) => {
                            const nodes = [], weights = [];
                            for (let j = 0; j <= N; j++) {
                                nodes.push(Math.cos(Math.PI * j / N));
                                
                                let w = 0;
                                for (let k = 0; k <= Math.floor(N/2); k++) {
                                    const c = 2 * k;
                                    if (c === 0 || c === N) {
                                        w += 0.5 / (1 - c * c) * Math.cos(c * Math.PI * j / N);
                                    } else if (1 - c * c !== 0) {
                                        w += 1 / (1 - c * c) * Math.cos(c * Math.PI * j / N);
                                    }
                                }
                                
                                // 端点权重减半
                                const endpointFactor = (j === 0 || j === N) ? 0.5 : 1;
                                weights.push(2 * w / N * endpointFactor);
                            }
                            return { nodes, weights };
                        };
                        
                        const { nodes, weights } = getNodesWeights(m);
                        
                        const integrate = (depth, currentScope) => {
                            if (depth === n) return math.evaluate(processedExpr, currentScope);
                            
                            const { lower, upper, variable } = numericLimits[depth];
                            const mid = (upper + lower) / 2;
                            const half = (upper - lower) / 2;
                            let sum = 0;
                            
                            for (let i = 0; i <= m; i++) {
                                const x = mid + half * nodes[i];
                                const newScope = { ...currentScope, [variable]: x };
                                sum += weights[i] * integrate(depth + 1, newScope);
                            }
                            
                            return sum * half;
                        };
                        
                        const result = integrate(0, scope);
                        const finalResult = Math.abs(result - Math.round(result)) < 1e-9 ? 
                            Math.round(result).toString() : result.toFixed(14).replace(/\.?0+$/, '');
                        
                        steps.push(`计算点数: ${Math.pow(m+1, n).toLocaleString()}`);
                        steps.push(`结果: ${finalResult}`);
                        steps.push(`注: Clenshaw-Curtis精度接近Gauss, 但数值稳定性更好`);
                        
                        return {
                            expression: finalResult, copyText: finalResult, steps,
                            operation: 'n_definite_integral', variables, limits,
                            originalExpression: expr, integralOrder: n
                        };
                    }
                    
                    // === 策略3: 低维Romberg积分 (1-2维) ===
                    steps.push(`策略: ${n}重Romberg积分 (Richardson外推, 精度O(h^2k))`);
                    
                    // Romberg积分 - 梯形法则 + Richardson外推
                    const romberg = (f, a, b, maxK, scope, varName, depth) => {
                        const R = Array(maxK + 1).fill(0).map(() => Array(maxK + 1).fill(0));
                        
                        // R[0][0]: 梯形公式
                        let h = b - a;
                        R[0][0] = 0.5 * h * (f(a, scope, varName, depth) + f(b, scope, varName, depth));
                        
                        // 逐步细分
                        for (let i = 1; i <= maxK; i++) {
                            h /= 2;
                            let sum = 0;
                            const points = Math.pow(2, i - 1);
                            
                            for (let j = 1; j <= points; j++) {
                                const x = a + (2 * j - 1) * h;
                                sum += f(x, scope, varName, depth);
                            }
                            
                            R[i][0] = 0.5 * R[i-1][0] + h * sum;
                            
                            // Richardson外推
                            for (let k = 1; k <= i; k++) {
                                const factor = Math.pow(4, k);
                                R[i][k] = (factor * R[i][k-1] - R[i-1][k-1]) / (factor - 1);
                            }
                            
                            // 检查收敛
                            if (i > 1 && Math.abs(R[i][i] - R[i-1][i-1]) < 1e-12) {
                                return R[i][i];
                            }
                        }
                        
                        return R[maxK][maxK];
                    };
                    
                    // 多重积分递归
                    const integrate = (depth, currentScope) => {
                        if (depth === n) return math.evaluate(processedExpr, currentScope);
                        
                        const { lower, upper, variable } = numericLimits[depth];
                        const f = (x, s, v, d) => integrate(d + 1, { ...s, [v]: x });
                        
                        return romberg(f, lower, upper, 10, currentScope, variable, depth);
                    };
                    
                    const result = integrate(0, scope);
                    const finalResult = Math.abs(result - Math.round(result)) < 1e-9 ? 
                        Math.round(result).toString() : result.toFixed(14).replace(/\.?0+$/, '');
                    
                    steps.push(`结果: ${finalResult}`);
                    steps.push(`注: Romberg积分精度可达1e-12, 是外推法的巅峰`)
                    
                    return {
                        expression: finalResult,
                        copyText: finalResult,
                        steps: steps,
                        operation: 'n_definite_integral',
                        variables: variables,
                        limits: limits,
                        originalExpression: expr,
                        integralOrder: n
                    };
                    
                } catch (error) {
                    return {
                        expression: '计算失败',
                        copyText: '计算失败',
                        steps: [`错误: ${error.message}`],
                        error: error.message,
                        operation: 'n_definite_integral',
                        variables: variables || [],
                        limits: limits || [],
                        originalExpression: expr
                    };
                }
            },
            
            // 积分项处理函数 (已修改：增强分数/整数显示，增加 exp(x)ln(x) 规则)
            integrateTerm(term, varName, sign = 1) {
                const parsedTerm = math.parse(term.toString());
                let nodeToIntegrate = parsedTerm;
                let coefficientNode = new math.ConstantNode(sign);
                let variableFound = false;

                // 1. 尝试将 term 拆分为 Coefficient * FunctionOf(varName)
                if (parsedTerm.type === 'OperatorNode' && parsedTerm.op === '*') {
                    let varParts = [];
                    let constParts = [];
                    parsedTerm.args.forEach(arg => {
                        // Includes variable parts OR symbolic constants that are NOT pi or e
                        if (arg.toString().includes(varName) || (arg.type === 'SymbolNode' && arg.name !== 'pi' && arg.name !== 'e')) {
                            varParts.push(arg);
                            variableFound = true;
                        } else {
                            constParts.push(arg);
                        }
                    });
                    
                    if (varParts.length > 0) {
                        nodeToIntegrate = varParts.length === 1 ? varParts[0] : new math.OperatorNode('*', 'multiply', varParts);
                        variableFound = true;
                        coefficientNode = constParts.length > 1 ? new math.OperatorNode('*', 'multiply', constParts) : (constParts.length === 1 ? constParts[0] : new math.ConstantNode(1));
                    } else {
                        variableFound = false;
                        nodeToIntegrate = parsedTerm;
                        coefficientNode = new math.ConstantNode(1);
                    }
                } else if (parsedTerm.toString().includes(varName)) {
                    variableFound = true;
                } else if (parsedTerm.type === 'ConstantNode' || (parsedTerm.type === 'SymbolNode' && parsedTerm.name !== varName)) {
                    variableFound = false;
                }
                
                // 提取系数（包含初始 sign）
                const initialCoeff = math.evaluate(coefficientNode.toString()) * sign;
                
                // Rule 4: Special Case: ∫ e^x * ln(x) dx (非初等函数积分)
                if (nodeToIntegrate.type === 'OperatorNode' && nodeToIntegrate.op === '*' && nodeToIntegrate.args.length === 2) {
                    const args = nodeToIntegrate.args.map(a => a.toString());
                    // 预处理中 ln(x) 变成了 log(x)
                    const hasExpX = args.includes(`exp(${varName})`); 
                    const hasLogX = args.includes(`log(${varName})`); 

                    if (hasExpX && hasLogX) {
                        // Result: Coeff * ( exp(x) * log(x) - ∫ (exp(x)/x) dx )
                        
                        const absCoeffFormatted = this.formatCoefficient(Math.abs(initialCoeff));
                        const signStr = initialCoeff >= 0 ? '+' : '-';
                        
                        let result = `${signStr} ${absCoeffFormatted}*(exp(${varName})*log(${varName}) - integral_exp_over_x(${varName}))`;
                        
                        // Clean up: 1*(...) -> (...)
                        result = result.replace(/^(\+|-)\s*1\*(.*)$/, '$1 $2').replace(/\s+/g, ' ');
                        
                        return result;
                    }
                }

                // Rule 1: 常数积分
                if (!variableFound) {
                    let termPart = nodeToIntegrate.toString(); // e.g. '13288' or 'y'
                    
                    // **修复: 积分常数项系数为1时的显示问题**
                    let absCoeffFormatted;
                    if (Math.abs(initialCoeff - 1) < this.tolerance) {
                         absCoeffFormatted = ''; // 系数为 1，显示空
                    } else if (Math.abs(initialCoeff + 1) < this.tolerance) {
                         absCoeffFormatted = ''; // 系数为 -1，显示空 (符号在 signStr 中处理)
                    } else {
                         absCoeffFormatted = this.formatCoefficient(Math.abs(initialCoeff), true);
                    }
                    
                    const signStr = initialCoeff >= 0 ? '+' : '-';

                    // **修复: 如果 termPart 以数字结尾，保留完整的项**
                    // 例如 321 应该保留为 321x，而不是 32x
                    if (nodeToIntegrate.type === 'ConstantNode') {
                        // 对于纯数字常数，直接使用该数字
                        termPart = termPart;
                    } else if (termPart !== '1') {
                        // 符号常数 (e, pi, sqrt(3)) 或其他变量 (y)
                        termPart = `${termPart}*`;
                    }
                    
                    // 如果系数非空，则添加系数，否则只保留 termPart
                    let termContent = absCoeffFormatted === '' ? termPart : `${absCoeffFormatted}${termPart}`;
                    
                    let result = `${signStr} ${termContent}${varName}`;
                    result = result.replace(/1\*/g, '').replace(/\*1/g, '').replace(/\s+/g, ' '); // 清理 1*
                    
                    return result;
                }
                
                // Rule 2.1: 幂函数积分: ∫ u^n du = u^(n+1)/(n+1)
                if (nodeToIntegrate.type === 'SymbolNode' && nodeToIntegrate.name === varName) {
                    // x^1 积分
                    const n = 1;
                    const newExponent = n + 1;
                    const newCoeff = initialCoeff / newExponent;
                    
                    const signStr = newCoeff >= 0 ? '+' : '-';
                    const absFormattedCoeff = this.formatCoefficient(Math.abs(newCoeff));
                    
                    let finalTerm = `${absFormattedCoeff}*${varName}^${newExponent}`;
                    finalTerm = finalTerm.replace(/^1\*/, '').replace(/\*1/, '');
                    
                    return `${signStr} ${finalTerm}`;
                }
                
                if (nodeToIntegrate.type === 'OperatorNode' && nodeToIntegrate.op === '^' && nodeToIntegrate.args.length === 2) {
                    const base = nodeToIntegrate.args[0];
                    const exponent = nodeToIntegrate.args[1];
                    
                    if (base.type === 'SymbolNode' && base.name === varName && exponent.type === 'ConstantNode') {
                        const n = exponent.value;
                        if (n !== -1) {
                            const newExponent = n + 1;
                            const newCoeff = initialCoeff / newExponent;
                            
                            const signStr = newCoeff >= 0 ? '+' : '-';
                            const absFormattedCoeff = this.formatCoefficient(Math.abs(newCoeff));
                            
                            let finalTerm = `${absFormattedCoeff}*${varName}^${newExponent}`;
                            finalTerm = finalTerm.replace(/^1\*/, '').replace(/\*1/, '');
                            
                            return `${signStr} ${finalTerm}`;
                        }
                    }
                }
                
                // Rule 2.2: 1/u 形式积分 (ln): ∫ 1/u du = log|u| (增强的 ln 积分支持)
                if (nodeToIntegrate.type === 'OperatorNode' && nodeToIntegrate.op === '/' && nodeToIntegrate.args.length === 2) {
                    const numerator = nodeToIntegrate.args[0];
                    const denominator = nodeToIntegrate.args[1];
                    
                    if (denominator.toString().includes(varName) && (numerator.type === 'ConstantNode' || numerator.type === 'SymbolNode' && !numerator.toString().includes(varName))) {
                        const constPart = numerator.toString();
                        const finalCoeff = initialCoeff * math.evaluate(constPart);
                        
                        const signStr = finalCoeff >= 0 ? '+' : '-';
                        const absFormattedCoeff = this.formatCoefficient(Math.abs(finalCoeff));
                        
                        const denomString = denominator.toString().replace(/[\(\)]/g, '');
                        
                        let finalTerm = `${absFormattedCoeff}*log(abs(${denomString}))`;
                        finalTerm = finalTerm.replace(/^1\*/, '').replace(/\*1/, '');
                        
                        return `${signStr} ${finalTerm}`;
                    }
                }
                
                // Rule 2.3: 特殊函数积分
                if (nodeToIntegrate.type === 'FunctionNode' && nodeToIntegrate.args[0].type === 'SymbolNode' && nodeToIntegrate.args[0].name === varName) {
                    const funcName = nodeToIntegrate.name;
                    let integral = null;
                    let multiplier = 1;
                    switch(funcName) {
                        case 'sin': integral = `cos(${varName})`; multiplier = -1; break;
                        case 'cos': integral = `sin(${varName})`; break;
                        case 'exp': integral = `exp(${varName})`; break;
                        case 'log': // log(x) 积分是 x*ln(x) - x
                            integral = `${varName}*log(${varName}) - ${varName}`; 
                            break;
                    }
                    
                    if (integral) {
                        const finalCoeff = initialCoeff * multiplier;
                        const signStr = finalCoeff >= 0 ? '+' : '-';
                        const absFormattedCoeff = this.formatCoefficient(Math.abs(finalCoeff));
                        
                        let finalTerm = `${absFormattedCoeff}*(${integral})`;
                        finalTerm = finalTerm.replace(/^1\*/, '').replace(/\*1/, '');
                        
                        return `${signStr} ${finalTerm}`;
                    }
                }
                
                // Rule 3: 默认情况下，返回原始项 (如果无法积分)
                const signStr = initialCoeff >= 0 ? '+' : '-';
                const absCoeffFormatted = this.formatCoefficient(Math.abs(initialCoeff));
                
                let finalTerm = `${absCoeffFormatted}*${nodeToIntegrate.toString()}`;
                finalTerm = finalTerm.replace(/^1\*/, '').replace(/\*1/, '');
                
                return `${signStr} ${finalTerm}`;
            },
            
            // 表达式化简 (新增无穷大项分离逻辑)
            calculateSimplify(expr, varName) {
                // 调试信息
                console.log('=== calculateSimplify 函数调试 ===');
                console.log('输入表达式:', expr);
                
                // 使用预处理表达式用于显示（包含X乘法处理）
                const displayExpr = this.preprocessExpressionForDisplay(expr);
                const steps = [`原表达式: ${this.formatExpressionForDisplay(displayExpr)}`];
                
                // 1. 检查是否为纯常数表达式 (e, pi, sqrt(3) 都是常数)
                // 纯常数表达式：不包含变量且不包含虚数
                const isPureConstantExpression = this.isConstantExpression(expr) && !expr.includes(varName) && !this.containsImaginary(expr);
                console.log('isPureConstantExpression:', isPureConstantExpression);

                // 2. 分离无穷大项
                const allTerms = [];
                try {
                    this.extractTerms(math.parse(expr), allTerms);
                } catch (e) {
                    throw new Error(`无法解析表达式进行化简: ${e.message}`);
                }
                const { finiteTerms, infiniteTerms } = this.getInfiniteTerms(expr, varName);
                
                let simplified = '0';
                let finiteExpr = '';

                if (finiteTerms.length > 0) {
                    if (isPureConstantExpression && infiniteTerms.length === 0) {
                        
                        // **FIX 1: 纯常数表达式，步骤1保留符号形式**
                        // 使用 mergeLikeTerms 确保数字常数 (如 5+2) 被合并，但 e, pi, sqrt(3) 保持符号形式
                        finiteExpr = this.mergeLikeTerms(expr, varName);
                        simplified = finiteExpr; 
                        
                        steps.push(`步骤1: 分离无穷大项后的有限部分 (符号保留): ${this.cleanMathJSText(finiteExpr)}`);

                        // 步骤 2, 3, 4: 跳过复杂的符号化简，以保留 e/pi/sqrt 等形式
                        steps.push(`步骤2: 合并同类项: 跳过 (已在步骤1中合并数字常量)`);
                        steps.push(`步骤3: 符号运算简化: 跳过`);
                        steps.push(`步骤4: 展开多项式: 跳过`);

                        // **FIX 2: 最终数值合并**
                        // 使用math.js计算表达式，支持虚数和π符号
                        const scope = { pi: math.pi, e: math.e, i: math.i };
                        
                        // 调试信息
                        console.log('=== 纯常数表达式数值合并调试 ===');
                        console.log('finiteExpr:', finiteExpr);
                        
                        // 检查表达式是否包含虚数单位i
                        const containsImaginaryUnit = /(^|\W|[-+*\/])(\d*\.*\d*)\s*i\s*($|\W|[-+*\/])(?![a-zA-Z])/.test(finiteExpr) ||
                                                 /(sin|cos|tan|cot|sec|csc|asin|acos|atan|log|ln|lg|sqrt|exp)\s*\(\s*[^)]*i[^)]*\)/.test(finiteExpr);
                        
                        console.log('containsImaginaryUnit:', containsImaginaryUnit);
                        
                        // 如果表达式包含虚数单位i，不进行计算，保持符号形式
                        if (containsImaginaryUnit) {
                            console.log('表达式包含虚数单位，保持符号形式');
                            simplified = finiteExpr;
                        } else {
                            console.log('表达式不包含虚数单位，检查是否有无穷大项');
                            // 检查是否有无穷大项
                            const { infiniteTerms } = this.getInfiniteTerms(finiteExpr, varName);
                            
                            if (infiniteTerms.length > 0) {
                                console.log('表达式包含无穷大项，使用智能求值');
                                simplified = this.intelligentEvaluate(finiteExpr, scope);
                            } else {
                                console.log('表达式不包含无穷大项，进行数值计算');
                                const result = math.evaluate(finiteExpr, scope);
                                console.log('math.evaluate 结果:', result);
                                
                                // 检查结果是否是复数
                                if (typeof result === 'object' && result !== null && 're' in result && 'im' in result) {
                                    // 复数结果，使用formatComplexNumber格式化
                                    simplified = this.formatComplexNumber(result);
                                } else if (result.toString().includes('i')) {
                                    // 字符串形式的复数
                                    simplified = result.toString();
                                } else {
                                    // 实数结果，格式化为数值
                                    simplified = result.toFixed(6).replace(/\.?0+$/, '');
                                }
                            }
                        }
                        
                        steps.push(`步骤5: 最终数值合并: ${this.cleanMathJSText(simplified)}`);

                    } else {
                        // 包含变量或无穷大项，使用标准流程
                        finiteExpr = this.reconstructExpression(finiteTerms);
                        simplified = finiteExpr; 
                    
                        steps.push(`步骤1: 分离无穷大项后的有限部分: ${this.cleanMathJSText(finiteExpr)}`);
    
                        // 2.1. 简化有理函数
                        simplified = this.simplifyRationalFunction(simplified, varName);
                        
                        // 2.2. 合并同类项
                        const merged = this.mergeLikeTerms(simplified, varName);
                        if (merged !== simplified) {
                            steps.push(`步骤2: 合并同类项: ${this.cleanMathJSText(merged)}`);
                        } else if (simplified !== finiteExpr) {
                             steps.push(`步骤2: 合并同类项: ${this.cleanMathJSText(merged)}`);
                        } else {
                            steps.push(`步骤2: 合并同类项: ${this.cleanMathJSText(merged)}`);
                        }
                        simplified = merged;
                        
                        // 2.3. 尝试 math.js 自动简化
                        const originalSimplified = simplified;
                        // 如果有无穷大项，不调用 math.simplify，避免将表达式转换为 "Infinity"
                        if (infiniteTerms.length > 0) {
                            steps.push(`步骤3: 符号运算简化: 跳过 (存在无穷大项)`);
                        } else {
                            try {
                                const mathSimplified = math.simplify(simplified).toString();
                                if (mathSimplified !== originalSimplified) {
                                     steps.push(`步骤3: 符号运算简化: ${this.cleanMathJSText(mathSimplified)}`);
                                }
                                simplified = mathSimplified;
                            } catch (e) {
                                steps.push(`步骤3: 符号运算简化: 无法进行更深层简化。`);
                            }
                        }
                        
                        // 2.6. 新增：智能求值，分别处理包含虚数的项和纯常数项
                        if (infiniteTerms.length > 0 && this.isConstantExpression(simplified)) {
                            // 定义求值作用域
                            const scope = { pi: math.pi, e: math.e, i: math.i };
                            // 使用智能求值函数
                            simplified = this.intelligentEvaluate(simplified, scope);
                            steps.push(`步骤4: 有限项数值求值: ${this.cleanMathJSText(simplified)}`);
                        }
                        
                        // 2.4. 尝试展开
                        const expanded = this.expandPolynomial(simplified, varName);
                        if (expanded !== simplified) {
                            steps.push(`步骤4: 展开多项式: ${this.cleanMathJSText(expanded)}`);
                        } else {
                             steps.push(`步骤4: 展开多项式: 跳过`);
                        }
                        simplified = expanded;
                        
                        // 2.5. 最终合并同类项
                        const finalMerged = this.mergeLikeTerms(simplified, varName);
                        if (finalMerged !== simplified) {
                            steps.push(`步骤5: 最终合并同类项: ${this.cleanMathJSText(finalMerged)}`);
                        } else {
                             steps.push(`步骤5: 最终合并同类项: ${this.cleanMathJSText(finalMerged)}`);
                        }
                        simplified = finalMerged;
                    }
                } else {
                    steps.push('步骤1: 有限部分结果为零。');
                    simplified = '0';
                }
                
                // 3. 添加无穷大项到结果
                const finalResult = this.appendInfiniteTerms(simplified, infiniteTerms);
                
                const copyText = `${finalResult.copyText}`;
                return { expression: finalResult.expression, steps, copyText };
            },
            
            // 表达式求值 (新增无穷大项分离逻辑)
            evaluateExpression(expr) {
                const variable = this.elements.variableInput.value.trim() || 'x';
                const steps = [`表达式: ${this.formatExpressionForDisplay(expr)}`];
                const scope = {};
                const inputs = this.elements.variableInputs.querySelectorAll('input');
                inputs.forEach(input => {
                    const varName = input.id.replace('var-', '');
                    scope[varName] = parseFloat(input.value) || 0;
                });
                
                // 确保 scope 包含常数
                scope.pi = math.pi;
                scope.e = math.e;
                scope.i = math.i; // 新增：支持虚数单位

                const scopeDisplay = Object.entries(scope).map(([key, value]) => `${key} = ${value}`).join(', ');
                steps.push(`步骤1: 变量赋值: { ${scopeDisplay} }`);

                // 1. 分离无穷大项
                const allTerms = [];
                try {
                    this.extractTerms(math.parse(expr), allTerms);
                } catch (e) {
                    throw new Error(`无法解析表达式进行求值: ${e.message}`);
                }
                const { finiteTerms, infiniteTerms } = this.getInfiniteTerms(expr, variable);
                
                const finiteExpr = this.reconstructExpression(finiteTerms);
                
                let result;
                if (finiteExpr === '0') {
                    result = '0'; // Only infinite terms
                } else {
                    try {
                        // 2. 评估有限部分
                        const compiled = math.compile(finiteExpr);
                        result = compiled.evaluate(scope);
                    } catch (error) {
                        throw new Error(`步骤2: 有限部分求值失败: ${error.message}`);
                    }
                }

                steps.push(`步骤2: 有限部分结果: ${result.toString()}`);

                // 3. 添加无穷大项到结果
                const finalResult = this.appendInfiniteTerms(result.toString(), infiniteTerms);
                
                const copyText = `${finalResult.copyText}`;
                return { expression: finalResult.expression, steps, copyText };
            },
            
            // 提取加减项 (不变)
            extractTerms(node, terms, sign = 1) {
                if (node.type === 'OperatorNode') {
                    if (node.op === '+') {
                        node.args.forEach(arg => this.extractTerms(arg, terms, sign));
                    } else if (node.op === '-') {
                        if (node.args.length === 1) { // 负号作为一元运算符 (e.g. -x)
                            this.extractTerms(node.args[0], terms, -sign);
                        } else { // 减法作为二元运算符 (e.g. x - y)
                            this.extractTerms(node.args[0], terms, sign);
                            this.extractTerms(node.args[1], terms, -sign);
                        }
                    } else {
                        terms.push({ node, sign });
                    }
                } else if (node.type === 'ParenthesisNode') {
                    this.extractTerms(node.content, terms, sign);
                } else {
                    terms.push({ node, sign });
                }
            },
            
            // 合并项 (已修改：防止 e, pi 等常数被错误地视为变量)
            mergeTerms(terms, varName) {
                const merged = new Map();
                const tolerance = this.tolerance;
                
                terms.forEach(term => {
                    let coefficient = term.sign;
                    let variablePart = '';
                    let isConstant = false;
                    let mergeKey = '';
                    
                    if (term.node.type === 'ConstantNode') {
                        // 纯数字常数
                        coefficient *= term.node.value;
                        isConstant = true;
                        mergeKey = '_NUMERICAL_CONSTANT_'; // 特殊键用于合并所有纯数字
                        variablePart = mergeKey;
                    } else if (term.node.type === 'SymbolNode') {
                        if (term.node.name === varName) {
                            // 变量
                            variablePart = varName;
                            mergeKey = varName;
                        } else if (['pi', 'e'].includes(term.node.name)) {
                            // 数学常数 (符号常数)，不进行数值合并，保持符号唯一
                            isConstant = true;
                            variablePart = term.node.name;
                            mergeKey = term.node.name;
                        } else if (term.node.name === 'i') {
                            // 虚数单位特殊处理：i 视为变量部分，系数合并
                            variablePart = 'i';
                            mergeKey = 'i';
                        } else {
                            // 其他符号常数 (例如 y, a)
                            isConstant = true;
                            variablePart = term.node.name;
                            mergeKey = term.node.name;
                        }
                    } else if (term.node.type === 'OperatorNode' && term.node.op === '*') {
                        // 尝试分离系数和变量部分
                        let varParts = [];
                        let constParts = [];
                        term.node.args.forEach(arg => {
                            // 检查是否包含变量名或无法计算的符号
                            if (arg.toString().includes(varName) || 
                                (arg.type === 'SymbolNode' && !['pi', 'e'].includes(arg.name) && arg.name !== varName) ||
                                (arg.type === 'FunctionNode' && arg.toString().includes(varName))
                            ) {
                                varParts.push(arg);
                            } else {
                                constParts.push(arg);
                            }
                        });
                        
                        // 组装系数 (数值常数和 e, pi)
                        try {
                            const coeffNode = constParts.length === 1 ? constParts[0] : new math.OperatorNode('*', 'multiply', constParts);
                            if (constParts.length > 0) {
                                // 评估常数部分，不包含虚数单位 i
                                coefficient *= math.evaluate(coeffNode.toString(), { pi: math.pi, e: math.e });
                            }
                        } catch (e) {
                            // 如果常数部分复杂到无法求值，将它们都视为变量部分
                            varParts = term.node.args;
                            coefficient = term.sign;
                            constParts = [];
                        }
                        
                        // 组装变量部分
                        variablePart = varParts.length === 1 ? varParts[0].toString() : (varParts.length > 1) ? varParts.map(n => n.toString()).join('*') : '';
                        
                        if (varParts.length === 0) {
                            isConstant = true;
                            mergeKey = '_NUMERICAL_CONSTANT_';
                            variablePart = mergeKey;
                        } else {
                            // 变量项的合并键是变量部分的标准化字符串
                            mergeKey = variablePart;
                        }
                        
                    } else if (term.node.type === 'FunctionNode' && !term.node.toString().includes(varName)) {
                         // 纯常数函数项 (如 sqrt(3), log(2)). 
                         // 必须在这里避免数值化，并保持符号形式作为变量部分。
                        isConstant = true;
                        variablePart = term.node.toString();
                        mergeKey = variablePart; 
                    }
                    else {
                        // 其他复杂结构，视为变量部分，系数为 1
                        variablePart = term.node.toString();
                        mergeKey = variablePart;
                    }
                    
                    // 标准化变量部分和合并键
                    if (!isConstant) {
                        try {
                            const parsedVar = math.parse(variablePart);
                            mergeKey = parsedVar.toString();
                        } catch (e) {
                            // 无法解析，保留原始字符串
                        }
                    }
                    
                    if (merged.has(mergeKey)) {
                        merged.get(mergeKey).coefficient += coefficient;
                    } else {
                        // 存储 originalTerm 以便在 reconstructExpression 中重建符号形式
                        merged.set(mergeKey, { variablePart: mergeKey, coefficient, originalTerm: term.node.toString() });
                    }
                });
                
                // 过滤系数接近零的项，并格式化输出
                const resultTerms = [];
                merged.forEach(term => {
                    if (Math.abs(term.coefficient) > tolerance) {
                        // 格式化常数项 (如果键不是纯数字常量，则尝试保留符号)
                        if (term.variablePart === '_NUMERICAL_CONSTANT_') {
                            resultTerms.push({ coefficient: term.coefficient, variablePart: '' });
                        } else {
                            // 对于符号常数 (e, pi, i, sqrt(3), y) 或变量项 (x, x^2)
                            // 重新设置 variablePart 为其符号形式，以便 reconstructExpression 使用
                            resultTerms.push({ coefficient: term.coefficient, variablePart: term.variablePart });
                        }
                    }
                });
                
                // 将纯数值常数项（variablePart=''）移到最前面
                resultTerms.sort((a, b) => {
                    if (a.variablePart === '' && b.variablePart !== '') return -1;
                    if (a.variablePart !== '' && b.variablePart === '') return 1;
                    return 0;
                });
                
                // 重新构建表达式 (返回给 mergeLikeTerms)
                return resultTerms;
            },
            
            // 简化有理函数（例如 (x^2+1)/(x+1) -> x-1 + 2/(x+1)） (不变)
            simplifyRationalFunction(expr, varName) {
                let result = expr;
                // 1. 增强: 对 (x^2 + 1)/(x + 1) 的特殊处理
                // (x^2 + 1)/(x + 1) = x - 1 + 2/(x + 1)
                // 匹配 (x^2 + 1) / (x + 1) 或其带有空格的变体
                const rationalPattern = new RegExp(`\\( *${varName} *\\^ *2 *\\+ *1 *\\) *\\/ *\\( *${varName} *\\+ *1 *\\)`, 'g');
                if (rationalPattern.test(expr)) {
                    // 替换为代数分解形式，使用括号确保优先级
                    result = result.replace(rationalPattern, `(${varName} - 1 + 2 / (${varName} + 1))`);
                }
                return result;
            },
            
            // 仅进行常数合并的同类项合并 (用于求导优化、化简步骤)
            mergeLikeTerms(expr, varName) {
                try {
                    const node = math.parse(expr);
                    const terms = [];
                    this.extractTerms(node, terms);
                    
                    // 重新构建表达式 (使用修复后的 reconstructExpression)
                    return this.reconstructExpression(terms);

                } catch (error) {
                    // 解析失败，返回原始表达式
                    return expr;
                }
            },
            
            // 展开多项式 (不变)
            expandPolynomial(expr, varName) {
                try {
                    // 1. 尝试使用 math.js 的 simplify 配合 rule 展开
                    const node = math.parse(expr);
                    
                    // 2. 递归展开 (a+b)^n 形式
                    const expandedNode = this.expandNode(node, varName);
                    
                    // 3. 最终简化
                    return math.simplify(expandedNode).toString();
                } catch (error) {
                    return expr;
                }
            },
            
            expandNode(node, varName) {
                if (node.type === 'OperatorNode' && node.op === '^') {
                    const base = node.args[0];
                    const exponent = node.args[1];
                    
                    if (exponent.type === 'ConstantNode' && Number.isInteger(exponent.value) && exponent.value >= 2) {
                        let baseContent = base;
                        if (base.type === 'ParenthesisNode') {
                            baseContent = base.content;
                        }
                        
                        if (baseContent.type === 'OperatorNode' && baseContent.op === '+') {
                            // 仅支持两个参数 (a+b)^n
                            if (baseContent.args.length === 2) {
                                return this.expandBinomial(baseContent.args[0], baseContent.args[1], exponent.value);
                            }
                        }
                    }
                }
                
                // 递归处理子节点
                if (node.args) {
                    const expandedArgs = node.args.map(arg => this.expandNode(arg, varName));
                    return new math.OperatorNode(node.op, node.fn, expandedArgs, node.implicit);
                }
                return node;
            },
            
            expandBinomial(a, b, n) {
                let result = null;
                for (let k = 0; k <= n; k++) {
                    const coefficient = this.binomialCoefficient(n, k);
                    
                    // a^k
                    const termA = k === 0 ? new math.ConstantNode(1) : k === 1 ? a : new math.OperatorNode('^', 'pow', [a, new math.ConstantNode(k)]);
                    
                    // b^(n-k)
                    const termB = (n - k) === 0 ? new math.ConstantNode(1) : (n - k) === 1 ? b : new math.OperatorNode('^', 'pow', [b, new math.ConstantNode(n - k)]);
                    
                    let termParts = [termA, termB].filter(part => part.toString() !== '1');
                    
                    if (coefficient !== 1) {
                        termParts.unshift(new math.ConstantNode(coefficient));
                    }
                    
                    let term;
                    if (termParts.length === 0) {
                        term = new math.ConstantNode(1);
                    } else if (termParts.length === 1) {
                        term = termParts[0];
                    } else {
                        // 创建乘积节点
                        term = new math.OperatorNode('*', 'multiply', termParts);
                    }
                    
                    if (result === null) {
                        result = term;
                    } else {
                        result = new math.OperatorNode('+', 'add', [result, term]);
                    }
                }
                
                // 确保结果被 math.js 简化
                return math.simplify(result);
            },
            
            binomialCoefficient(n, k) {
                if (k < 0 || k > n) {
                    return 0;
                }
                if (k === 0 || k === n) {
                    return 1;
                }
                if (k > n / 2) {
                    k = n - k;
                }
                let res = 1;
                for (let i = 1; i <= k; i++) {
                    res = res * (n - i + 1) / i;
                }
                return res;
            },
            
            // 格式化输出表达式 (用于最终结果和所有步骤)
            formatExpressionForDisplay(text) {
                // 调试信息
                console.log('=== formatExpressionForDisplay 函数调试 ===');
                console.log('输入文本:', text);
                
                let formattedText = text;

                // 0. 特殊处理对数导数格式，如 1/xln2【最终计算值/x】
                formattedText = formattedText.replace(/(\d+)\/(\w+)ln(\d+(?:\.\d+)?)【([^】]+)】/g, (match, numerator, variable, base, calc) => {
                    return `${numerator}/${variable}ln${base}【${calc}】`;
                });
                formattedText = formattedText.replace(/(\d+)\/(\w+)ln\(([^)]+)\)【([^】]+)】/g, (match, numerator, variable, base, calc) => {
                    return `${numerator}/${variable}ln(${base})【${calc}】`;
                });

                // 1. 保存函数参数中的内容，防止乘号被误删
                const functionContents = [];
                formattedText = formattedText.replace(/(\w+)\(([^)]+)\)/g, (match, func, content) => {
                    const index = functionContents.length;
                    functionContents.push(content);
                    console.log(`保存函数内容: ${func}(${content}) -> ${func}(__FUNC_CONTENT_${index}__)`);
                    return `${func}(__FUNC_CONTENT_${index}__)`;
                });
                
                console.log('步骤1后:', formattedText);
                
                // 2. exp(x) 转换为 e^(x) - 修复：使用占位符避免在恢复函数内容前被错误替换
                formattedText = formattedText.replace(/exp\(__FUNC_CONTENT_(\d+)__\)/g, '__EXP_PLACEHOLDER_$1__');
                formattedText = formattedText.replace(/(\d*\.?\d*)\s*\*\s*exp\(__FUNC_CONTENT_(\d+)__\)/g, '$1*__EXP_PLACEHOLDER_$2__');
                
                // 3. **关键修正: 任意底对数 log(v, b) 转换为 log_b(v)**
                console.log('步骤3前:', formattedText);
                
                // 替换 log(v, b) 格式（注意：$1是真数，$2是底数）
                const beforeLogVb = formattedText;
                formattedText = formattedText.replace(/log\(__FUNC_CONTENT_(\d+)__,\s*__FUNC_CONTENT_(\d+)__\)/g, 'log<sub>$2</sub>($1)');
                console.log('log(v,b)替换:', beforeLogVb, '->', formattedText);
                
                // 替换 logbase(b, v) 占位符格式（来自 cleanMathJSText）（注意：$1是底数，$2是真数）
                const beforeLogbase = formattedText;
                formattedText = formattedText.replace(/logbase\(__FUNC_CONTENT_(\d+)__,\s*__FUNC_CONTENT_(\d+)__\)/g, 'log<sub>$1</sub>($2)');
                console.log('logbase替换:', beforeLogbase, '->', formattedText);
                
                console.log('步骤3后 (log(v,b)转换):', formattedText);
                
                // 4. log10(v) 转换为 lg(v)
                formattedText = formattedText.replace(/log10\(__FUNC_CONTENT_(\d+)__\)/g, 'lg($1)');
                
                console.log('步骤4后 (log10转换):', formattedText);
                
                // 5. log(v) 转换为 ln(v)
                // 修复：只转换单参数的log，避免影响双参数的log函数和log(底数)(真数)格式
                const logsToConvert = [];
                formattedText = formattedText.replace(/log\(__FUNC_CONTENT_(\d+)__\)(?!<sub>)(?!\s*\()/g, (match, contentIndex) => {
                    // 检查函数内容是否包含逗号，如果包含逗号则是双参数log，不转换
                    const content = functionContents[parseInt(contentIndex)];
                    if (content && content.includes(',')) {
                        console.log(`跳过双参数log: log(${content})`);
                        return match; // 不转换双参数log
                    }
                    
                    // 检查这个log后面是否跟着另一个括号，如果是log(底数)(真数)格式，不转换
                    const nextCharIndex = formattedText.indexOf(match) + match.length;
                    if (nextCharIndex < formattedText.length && formattedText[nextCharIndex] === '(') {
                        console.log(`跳过log(底数)(真数)格式: ${match}(...)`);
                        return match; // 不转换log(底数)(真数)格式
                    }
                    
                    const index = logsToConvert.length;
                    logsToConvert.push(contentIndex);
                    console.log(`标记需要转换的log: ${match} -> __LOG_TO_CONVERT_${index}__`);
                    return `__LOG_TO_CONVERT_${index}__`;
                });
                
                console.log('步骤5.1后 (标记需要转换的log):', formattedText);
                
                // 然后转换标记的log为ln
                logsToConvert.forEach((contentIndex, index) => {
                    formattedText = formattedText.replace(`__LOG_TO_CONVERT_${index}__`, `ln(__FUNC_CONTENT_${contentIndex}__)`);
                    console.log(`转换log为ln: __LOG_TO_CONVERT_${index}__ -> ln(__FUNC_CONTENT_${contentIndex}__)`);
                });
                
                console.log('步骤5.2后 (log转换ln):', formattedText);
                
                // 6. 修复：保留数字之间的乘法符号，移除其他情况下的乘号符号
                // 保留数字之间的乘法：3*2 -> 3*2
                // 移除函数和变量之间的乘法：sin(x)*y -> sin(x)y
                // 移除常数和变量之间的乘法：3*x -> 3x
                // 注意：这里不再移除所有乘号，而是只移除特定情况下的乘号
                formattedText = formattedText.replace(/([a-zA-Z\)\)])\*([a-zA-Z\(])/g, '$1$2'); // 函数/变量与函数/变量之间的乘号
                formattedText = formattedText.replace(/(\d)\*([a-zA-Z\(])/g, '$1$2'); // 数字与函数/变量之间的乘号
                formattedText = formattedText.replace(/([a-zA-Z\)\)])\*(\d)/g, '$1$2'); // 函数/变量与数字之间的乘号
                formattedText = formattedText.replace(/([a-zA-Z])\*(\d)/g, '$1$2'); // 单个变量与数字之间的乘号
                
                // 7. sqrt(v) 转换为 √v
                formattedText = formattedText.replace(/sqrt\(__FUNC_CONTENT_(\d+)__\)/g, '√($1)');
                
                // 8. pi 转换为 π
                formattedText = formattedText.replace(/pi/g, 'π');
                
                // 9. 新增: 非初等函数积分符号 ∫(e^x/x)dx
                formattedText = formattedText.replace(/integral_exp_over_x\(__FUNC_CONTENT_(\d+)__\)/g, '∫(e^($1)/$1)d$1'); 
                
                // 10. 恢复函数内容
                console.log('步骤10前 (恢复函数内容):', formattedText);
                formattedText = formattedText.replace(/__FUNC_CONTENT_(\d+)__/g, (match, index) => {
                    const content = functionContents[parseInt(index)];
                    console.log(`恢复函数内容: ${match} -> ${content}`);
                    return content;
                });
                
                // 10.5. 处理exp占位符，转换为e^()格式
                formattedText = formattedText.replace(/__EXP_PLACEHOLDER_(\d+)__/g, (match, index) => {
                    const content = functionContents[parseInt(index)];
                    console.log(`转换exp占位符: ${match} -> e^(${content})`);
                    // 如果内容为空或只是x，直接显示为e^x
                    if (content === 'x' || content.trim() === '') {
                        return `<span class="exponential">e^x</span>`;
                    }
                    return `<span class="exponential">e^(${content})</span>`;
                });
                
                // 11. 去除多余的空格，但保留乘号前后的空格
                formattedText = formattedText.replace(/\s+/g, ' '); // 将多个连续空格替换为单个空格
                formattedText = formattedText.replace(/\s*\(\s*/g, '('); // 去除括号前后的空格
                formattedText = formattedText.replace(/\s*\)\s*/g, ')'); // 去除右括号前后的空格
                formattedText = formattedText.replace(/\s*\+\s*/g, '+'); // 去除加号前后的空格
                formattedText = formattedText.replace(/\s*-\s*/g, '-'); // 去除减号前后的空格
                // 修复：不再移除乘号前后的空格，保留乘号
                // formattedText = formattedText.replace(/\s*\*\s*/g, ''); // 去除乘号前后的空格
                formattedText = formattedText.replace(/\s*\/\s*/g, '/'); // 去除除号前后的空格
                formattedText = formattedText.replace(/\s*\^\s*/g, '^'); // 去除幂号前后的空格
                formattedText = formattedText.replace(/\s*=\s*/g, '='); // 去除等号前后的空格
                formattedText = formattedText.replace(/^\s+|\s+$/g, ''); // 去除首尾空格
                
                console.log('最终格式化结果:', formattedText);
                return formattedText;
            },
            
            // 新增：格式化原始表达式，保留π和角度符号
            formatOriginalExpression(text) {
                let formattedText = text;
                
                // 清理HTML标签，防止在原始表达式中显示
                formattedText = formattedText.replace(/<[^>]*>/g, '');
                
                // 保留π符号
                formattedText = formattedText.replace(/pi/g, 'π');
                
                // 保留角度符号
                formattedText = formattedText.replace(/(\d+)°/g, '$1°');
                
                // 保留三角函数中的各种π表达式
                // 保留单个π
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(pi/g, '$1(π');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(π/g, '$1(π');
                
                // 保留数字*π形式 (如 2π, 3π)
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)\*pi/g, '$1($2π');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)\*π/g, '$1($2π');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)pi/g, '$1($2π');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)π/g, '$1($2π');
                
                // 保留π/数字形式 (如 π/2, π/3)
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(pi\/(\d+)/g, '$1(π/$2)');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(π\/(\d+)/g, '$1(π/$2)');
                
                // 保留数字*π/数字形式 (如 2π/3, 3π/2)
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)\*pi\/(\d+)/g, '$1($2π/$3)');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\((\d+)\*π\/(\d+)/g, '$1($2π/$3)');
                
                // 保留直接跟在函数后的π形式 (如 sin2π, cos3π)
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)(\d+)pi/g, '$1$2π');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)(\d+)π/g, '$1$2π');
                
                // 新增：保留三角函数中的虚数单位i
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)\(\s*i\s*\)/g, '$1(i)');
                formattedText = formattedText.replace(/(sin|cos|tan|cot|sec|csc|asin|acos|atan|acot|asec|acsc)i\b/g, '$1(i)');
                
                // 格式化其他函数
                formattedText = formattedText.replace(/sqrt\(([^)]+)\)/g, '√($1)');
                formattedText = formattedText.replace(/log10\(([^)]+)\)/g, 'lg($1)');
                
                // 修复：确保只替换完整的log函数，避免截断参数
                // 但是不替换 log(底数)(真数) 格式，这种格式已经是最终显示格式
                formattedText = formattedText.replace(/\blog\(([^)]+)\)(?!\s*\()(?!\s*\()/g, 'ln($1)');
                
                // 修复：保留数字之间的乘法符号，移除其他情况下的乘号符号
                // 保留数字之间的乘法：3*2 -> 3*2
                // 移除函数和变量之间的乘法：sin(x)*y -> sin(x)y
                // 移除常数和变量之间的乘法：3*x -> 3x
                // 注意：这里不再移除所有乘号，而是只移除特定情况下的乘号
                formattedText = formattedText.replace(/([a-zA-Z\)\)])\*([a-zA-Z\(])/g, '$1$2'); // 函数/变量与函数/变量之间的乘号
                formattedText = formattedText.replace(/(\d)\*([a-zA-Z\(])/g, '$1$2'); // 数字与函数/变量之间的乘号
                formattedText = formattedText.replace(/([a-zA-Z\)\)])\*(\d)/g, '$1$2'); // 函数/变量与数字之间的乘号
                formattedText = formattedText.replace(/([a-zA-Z])\*(\d)/g, '$1$2'); // 单个变量与数字之间的乘号
                
                // 去除多余的空格
                formattedText = formattedText.replace(/\s+/g, ' '); // 将多个连续空格替换为单个空格
                formattedText = formattedText.replace(/\s*\(\s*/g, '('); // 去除括号前后的空格
                formattedText = formattedText.replace(/\s*\)\s*/g, ')'); // 去除右括号前后的空格
                formattedText = formattedText.replace(/\s*\+\s*/g, '+'); // 去除加号前后的空格
                formattedText = formattedText.replace(/\s*-\s*/g, '-'); // 去除减号前后的空格
                formattedText = formattedText.replace(/\s*\/\s*/g, '/'); // 去除除号前后的空格
                formattedText = formattedText.replace(/\s*\^\s*/g, '^'); // 去除幂号前后的空格
                formattedText = formattedText.replace(/\s*=\s*/g, '='); // 去除等号前后的空格
                formattedText = formattedText.replace(/^\s+|\s+$/g, ''); // 去除首尾空格
                
                return formattedText;
            },
            
            // 检测表达式是否包含对数函数
            containsLogarithm(expr) {
                // 检查各种对数格式：log(x), log(v, b), logN(v), log(底数)(真数)
                const logPatterns = [
                    /log\([^)]+\)/,           // log(x) 或 log(v, b)
                    /log\d+\([^)]+\)/,        // logN(v) 格式
                    /log\s*\([^)]+\)\s*\([^)]+\)/,  // log(底数)(真数) 格式（预处理前）
                    /log\([^,]+,\s*[^)]+\)/,  // log(v, b) 格式（预处理后）
                    /logbase\([^)]+\)/        // logbase 格式（在显示中出现）
                ];
                
                return logPatterns.some(pattern => pattern.test(expr));
            },
            
            // 计算对数函数的导数，保持ln格式
            calculateLogarithmDerivative(expr, varName) {
                console.log('计算对数导数，原始表达式:', expr);
                
                // 直接处理原始表达式，不进行预处理
                // 首先处理乘除法，再处理加减法
                
                // 处理乘法：a * b -> a' * b + a * b'
                const processMultiplication = (term) => {
                    const parts = term.split('*').map(part => part.trim());
                    if (parts.length === 2) {
                        const [a, b] = parts;
                        const aDeriv = this.calculateLogarithmDerivative(a, varName);
                        const bDeriv = this.calculateLogarithmDerivative(b, varName);
                        
                        if (aDeriv && bDeriv) {
                            return `(${aDeriv})*${b}+${a}*(${bDeriv})`;
                        } else if (aDeriv) {
                            return `(${aDeriv})*${b}`;
                        } else if (bDeriv) {
                            return `${a}*(${bDeriv})`;
                        }
                    } else if (parts.length > 2) {
                        // 处理多个因子的乘法，如 log3(x) * log5(x) * log33(x)
                        // 直接使用化简函数，确保结果为ln格式
                        const simplified = this.simplifyLogMultiplication(parts, varName);
                        if (simplified) {
                            return simplified;
                        }
                        
                        // 如果化简失败，尝试使用对数求导法则
                        // 将每个对数转换为ln形式
                        const lnTerms = [];
                        const lnDerivatives = [];
                        let isValid = true;
                        
                        for (const part of parts) {
                            const lnTerm = this.convertLogToLn(part);
                            if (lnTerm) {
                                lnTerms.push(lnTerm.term);
                                lnDerivatives.push(lnTerm.derivative);
                            } else {
                                isValid = false;
                                break;
                            }
                        }
                        
                        if (isValid && lnDerivatives.length > 0) {
                            // 构建结果：f*g*h*(f'/f + g'/g + h'/h)
                            const product = lnTerms.join('*');
                            const sumOfDerivatives = lnDerivatives.join(' + ');
                            
                            return `${product}*(${sumOfDerivatives})`;
                        }
                    }
                    return null;
                };
                
                // 处理除法：a / b -> (a' * b - a * b') / b^2
                const processDivision = (term) => {
                    const parts = term.split('/').map(part => part.trim());
                    if (parts.length === 2) {
                        const [a, b] = parts;
                        const aDeriv = this.calculateLogarithmDerivative(a, varName);
                        const bDeriv = this.calculateLogarithmDerivative(b, varName);
                        
                        if (aDeriv && bDeriv) {
                            return `((${aDeriv})*${b}-${a}*(${bDeriv}))/(${b})^2`;
                        } else if (aDeriv) {
                            return `(${aDeriv})*${b}/(${b})^2`;
                        } else if (bDeriv) {
                            return `-${a}*(${bDeriv})/(${b})^2`;
                        }
                    }
                    return null;
                };
                
                // 处理对数除法：log_a(x) / log_b(x)
                const processLogDivision = (term) => {
                    const parts = term.split('/').map(part => part.trim());
                    if (parts.length === 2) {
                        const [a, b] = parts;
                        
                        // 检查是否都是对数函数
                        const aIsLog = this.isLogarithmTerm(a, varName);
                        const bIsLog = this.isLogarithmTerm(b, varName);
                        
                        if (aIsLog && bIsLog) {
                            // 使用换底公式：log_a(x) / log_b(x) = ln(x)/ln(a) / (ln(x)/ln(b)) = ln(b)/ln(a)
                            // 这是一个常数，导数为0
                            
                            // 提取底数
                            const aBase = this.extractLogBase(a);
                            const bBase = this.extractLogBase(b);
                            
                            if (aBase && bBase) {
                                // 返回0，因为这是常数
                                // 使用换底公式：log_a(x) / log_b(x) = ln(x)/ln(a) / (ln(x)/ln(b)) = ln(b)/ln(a)
                                return '0【使用换底公式：log_a(x)/log_b(x) = ln(b)/ln(a)，结果为常数，导数为0】';
                            }
                        }
                    }
                    return null;
                };
                
                // 分割表达式为各项（先处理乘除法，再处理加减法）
                let derivativeResult = null;
                
                // 检查是否有乘除法混合表达式（如 log3(x) * log5(x) / log7(x) * log9(x)）
                if ((expr.includes('*') || expr.includes('/')) && !expr.includes('+') && !expr.includes('-')) {
                    // 处理混合乘除法表达式
                    derivativeResult = this.processMixedMultiplicationDivision(expr, varName, processMultiplication, processDivision, processLogDivision);
                }
                // 检查是否有乘法
                else if (expr.includes('*') && !expr.includes('+') && !expr.includes('-')) {
                    derivativeResult = processMultiplication(expr);
                }
                // 检查是否有除法
                else if (expr.includes('/') && !expr.includes('+') && !expr.includes('-')) {
                    // 先尝试处理对数除法
                    derivativeResult = processLogDivision(expr);
                    // 如果不是对数除法，使用普通除法处理
                    if (!derivativeResult) {
                        derivativeResult = processDivision(expr);
                    }
                }
                // 处理加减法
                else {
                    const terms = expr.split(/(?=[+-])/).map(term => term.trim());
                    const derivativeTerms = [];
                    
                    terms.forEach(term => {
                        let sign = 1;
                        let cleanTerm = term;
                        
                        // 处理符号
                        if (term.startsWith('-')) {
                            sign = -1;
                            cleanTerm = term.substring(1).trim();
                        } else if (term.startsWith('+')) {
                            cleanTerm = term.substring(1).trim();
                        }
                        
                        // 先检查是否有乘除法
                        let derivative = null;
                        
                        if (cleanTerm.includes('*')) {
                            derivative = processMultiplication(cleanTerm);
                        } else if (cleanTerm.includes('/')) {
                            // 先尝试处理对数除法
                            derivative = processLogDivision(cleanTerm);
                            // 如果不是对数除法，使用普通除法处理
                            if (!derivativeResult) {
                                derivative = processDivision(cleanTerm);
                            }
                        }
                        
                        // 如果不是乘除法或者乘除法处理失败，处理单个对数项
                        if (!derivative) {
                            // 处理各种对数格式
                            
                            // 处理 logN(v) 格式
                            const logNMatch = cleanTerm.match(/^log(\d+)\(([^)]+)\)$/);
                            if (logNMatch) {
                                const base = logNMatch[1];
                                const value = logNMatch[2];
                                if (value === varName) {
                                    // 不计算数值，保持ln格式
                                    // 判断是否为整数底数
                                    const baseNum = parseFloat(base);
                                    if (baseNum % 1 === 0) {
                                        derivative = `1/${varName}ln${base}`;
                                    } else {
                                        derivative = `1/${varName}ln(${base})`;
                                    }
                                }
                            }
                            
                            // 处理 log(底数)(真数) 格式
                            const logParenthesesMatch = cleanTerm.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                            if (logParenthesesMatch) {
                                const base = logParenthesesMatch[1];
                                const value = logParenthesesMatch[2];
                                if (value === varName) {
                                    // 不计算数值，保持ln格式
                                    derivative = `1/${varName}ln(${base})`;
                                }
                            }
                            
                            // 处理 log(v, b) 格式（预处理后）
                            const anyBaseLogMatch = cleanTerm.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                            if (anyBaseLogMatch) {
                                const value = anyBaseLogMatch[1];
                                const base = anyBaseLogMatch[2];
                                if (value === varName) {
                                    // 不计算数值，保持ln格式
                                    // 判断是否为整数底数
                                    const baseNum = parseFloat(base);
                                    if (baseNum % 1 === 0) {
                                        derivative = `1/${varName}ln${base}`;
                                    } else {
                                        derivative = `1/${varName}ln(${base})`;
                                    }
                                }
                            }
                        }
                        
                        if (derivative) {
                            derivativeTerms.push(sign === -1 ? `-${derivative}` : derivative);
                        }
                    });
                    
                    if (derivativeTerms.length === 0) {
                        console.log('没有可用的导数项');
                        return null;
                    }
                    
                    // 构建结果字符串
                    derivativeResult = derivativeTerms.join(' + ').replace(/\+ \-/g, '- ');
                }
                
                console.log('对数导数结果:', derivativeResult);
                return derivativeResult;
            },
            
            // 处理原始对数表达式，当预处理失败时使用
            processOriginalLogExpression(expr, varName) {
                console.log('处理原始对数表达式:', expr);
                
                // 分割表达式为各项
                const terms = expr.split(/(?=[+-])/).map(term => term.trim());
                const derivativeTerms = [];
                
                terms.forEach(term => {
                    let sign = 1;
                    let cleanTerm = term;
                    
                    // 处理符号
                    if (term.startsWith('-')) {
                        sign = -1;
                        cleanTerm = term.substring(1).trim();
                    } else if (term.startsWith('+')) {
                        cleanTerm = term.substring(1).trim();
                    }
                    
                    // 处理各种对数格式
                    let derivative = null;
                    
                    // 处理 logN(v) 格式
                    const logNMatch = cleanTerm.match(/^log(\d+)\(([^)]+)\)$/);
                    if (logNMatch) {
                        const base = logNMatch[1];
                        const value = logNMatch[2];
                        if (value === varName) {
                            // 直接返回ln格式，不计算数值
                            derivative = `1/${varName}ln${base}【最终计算值/${varName}】`;
                        }
                    }
                    
                    // 处理 log(底数)(真数) 格式
                    const logParenthesesMatch = cleanTerm.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                    if (logParenthesesMatch) {
                        const base = logParenthesesMatch[1];
                        const value = logParenthesesMatch[2];
                        if (value === varName) {
                            // 直接返回ln格式，不计算数值
                            derivative = `1/${varName}ln(${base})【最终计算值/${varName}】`;
                        }
                    }
                    
                    if (derivative) {
                        derivativeTerms.push(sign === -1 ? `-${derivative}` : derivative);
                    }
                });
                
                if (derivativeTerms.length === 0) {
                    return null;
                }
                
                return derivativeTerms.join(' + ').replace(/\+ \-/g, '- ');
            },
            
            // 将任意底对数转换为ln形式
            convertLogToLn(logTerm, varName) {
                // 处理 logN(v) 格式
                const logNMatch = logTerm.match(/^log(\d+)\(([^)]+)\)$/);
                if (logNMatch) {
                    const base = logNMatch[1];
                    const value = logNMatch[2];
                    if (value === varName) {
                        return {
                            term: `ln(${value})/ln(${base})`,
                            derivative: `1/(${value}*ln(${base}))`
                        };
                    }
                }
                
                // 处理 log(底数)(真数) 格式
                const logParenthesesMatch = logTerm.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                if (logParenthesesMatch) {
                    const base = logParenthesesMatch[1];
                    const value = logParenthesesMatch[2];
                    if (value === varName) {
                        return {
                            term: `ln(${value})/ln(${base})`,
                            derivative: `1/(${value}*ln(${base}))`
                        };
                    }
                }
                
                // 处理 log(v, b) 格式（预处理后）
                const anyBaseLogMatch = logTerm.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                if (anyBaseLogMatch) {
                    const value = anyBaseLogMatch[1];
                    const base = anyBaseLogMatch[2];
                    if (value === varName) {
                        return {
                            term: `ln(${value})/ln(${base})`,
                            derivative: `1/(${value}*ln(${base}))`
                        };
                    }
                }
                
                return null;
            },
            
            // 化简对数乘法的导数
            simplifyLogMultiplication(logTerms, varName) {
                // 提取所有对数的底数
                const bases = [];
                let isValid = true;
                
                for (const term of logTerms) {
                    const logNMatch = term.match(/^log(\d+)\(([^)]+)\)$/);
                    const logParenthesesMatch = term.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                    const anyBaseLogMatch = term.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                    
                    let base = null;
                    let value = null;
                    
                    if (logNMatch) {
                        base = logNMatch[1];
                        value = logNMatch[2];
                    } else if (logParenthesesMatch) {
                        base = logParenthesesMatch[1];
                        value = logParenthesesMatch[2];
                    } else if (anyBaseLogMatch) {
                        value = anyBaseLogMatch[1];
                        base = anyBaseLogMatch[2];
                    }
                    
                    if (base && value === varName) {
                        bases.push(base);
                    } else {
                        isValid = false;
                        break;
                    }
                }
                
                if (!isValid || bases.length === 0) {
                    return null;
                }
                
                // 统计每个底数出现的次数
                const baseCounts = {};
                for (const base of bases) {
                    baseCounts[base] = (baseCounts[base] || 0) + 1;
                }
                
                // 构建化简后的表达式，合并相同项
                // 例如：log3(x)*log5(x)*log33(x)*log23(x)*log3(x)*log5(x)
                // -> 6*(ln(x))^5/(x*ln(3)^2*ln(5)^2*ln(33)*ln(23))
                const numerator = bases.length; // n*(ln(x))^(n-1)
                const lnPower = bases.length > 1 ? `*(ln(${varName}))^${bases.length-1}` : '';
                
                // 构建分母，相同底数用幂次表示
                const denominatorTerms = [];
                for (const [base, count] of Object.entries(baseCounts)) {
                    if (count === 1) {
                        denominatorTerms.push(`ln(${base})`);
                    } else {
                        denominatorTerms.push(`ln(${base})^${count}`);
                    }
                }
                const denominator = `${varName}*${denominatorTerms.join('*')}`;
                
                // 完全使用ln格式，不进行任何数值计算
                return `${numerator}${lnPower}/(${denominator})`;
            },
            
            // 检查是否是对数项
            isLogarithmTerm(term, varName) {
                // 处理 logN(v) 格式
                const logNMatch = term.match(/^log(\d+)\(([^)]+)\)$/);
                if (logNMatch) {
                    const value = logNMatch[2];
                    return value === varName;
                }
                
                // 处理 log(底数)(真数) 格式
                const logParenthesesMatch = term.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                if (logParenthesesMatch) {
                    const value = logParenthesesMatch[2];
                    return value === varName;
                }
                
                // 处理 log(v, b) 格式（预处理后）
                const anyBaseLogMatch = term.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                if (anyBaseLogMatch) {
                    const value = anyBaseLogMatch[1];
                    return value === varName;
                }
                
                return false;
            },
            
            // 处理混合乘除法表达式（如 log3(x) * log5(x) / log7(x) * log9(x)）
            processMixedMultiplicationDivision(expr, varName, processMultiplication, processDivision, processLogDivision) {
                // 将表达式按乘除法分割，保持运算符顺序
                const parts = [];
                const operators = [];
                let currentPart = '';
                
                for (let i = 0; i < expr.length; i++) {
                    const char = expr[i];
                    if (char === '*' || char === '/') {
                        if (currentPart.trim()) {
                            parts.push(currentPart.trim());
                            operators.push(char);
                            currentPart = '';
                        }
                    } else {
                        currentPart += char;
                    }
                }
                
                if (currentPart.trim()) {
                    parts.push(currentPart.trim());
                }
                
                // 如果只有一个部分，直接处理
                if (parts.length === 1) {
                    return processMultiplication(expr);
                }
                
                // 检查是否所有部分都是对数函数
                const allLogs = parts.every(part => this.isLogarithmTerm(part, varName));
                
                if (allLogs) {
                    // 所有部分都是对数函数，使用换底公式化简
                    // 将每个对数转换为 ln(x)/ln(base) 形式
                    const lnTerms = [];
                    const bases = [];
                    
                    for (const part of parts) {
                        const base = this.extractLogBase(part);
                        if (base) {
                            lnTerms.push(`ln(${varName})/ln(${base})`);
                            bases.push(base);
                        }
                    }
                    
                    if (lnTerms.length === parts.length) {
                        // 构建化简后的表达式
                        let simplifiedExpr = lnTerms[0];
                        for (let i = 0; i < operators.length; i++) {
                            simplifiedExpr += ` ${operators[i]} ${lnTerms[i+1]}`;
                        }
                        
                        // 计算化简后的表达式
                        // ln(x)/ln(a) * ln(x)/ln(b) / ln(x)/ln(c) * ln(x)/ln(d)
                        // = (ln(x))^n / (分母项)
                        // 这是一个常数乘以 (ln(x))^n，导数为常数*n*(ln(x))^(n-1)/x
                        
                        // 计算ln(x)的净幂次（分子中的ln(x)数量 - 分母中的ln(x)数量）
                        let lnPower = 0;
                        let numeratorBases = [];  // 在分子中的底数
                        let denominatorBases = [];  // 在分母中的底数
                        
                        // 第一个项总是在分子中
                        lnPower++;
                        numeratorBases.push(bases[0]);
                        
                        // 处理后续项
                        for (let i = 0; i < operators.length; i++) {
                            const op = operators[i];
                            const base = bases[i+1];
                            
                            if (op === '*') {
                                // 乘法：项在分子中
                                lnPower++;
                                numeratorBases.push(base);
                            } else if (op === '/') {
                                // 除法：项在分母中
                                lnPower--;
                                denominatorBases.push(base);
                            }
                        }
                        
                        // 如果幂次为0，则表达式为常数，导数为0
                        if (lnPower === 0) {
                            // 构建常数项：分子底数积 / 分母底数积
                            const numeratorProduct = numeratorBases.map(b => `ln(${b})`).join('*');
                            const denominatorProduct = denominatorBases.map(b => `ln(${b})`).join('*');
                            return '0【使用换底公式化简后为常数，导数为0】';
                        }
                        
                        // 构建分母（所有底数的对数）
                        const allBases = [...numeratorBases, ...denominatorBases];
                        const denominatorTerms = allBases.map(b => `ln(${b})`);
                        
                        // 构建结果：根据换底公式：log_a(x) * log_b(x) / log_c(x) = ln(c)/(x*ln(a)*ln(b))
                        // 分子应该是分母底数的对数，分母是变量x和分子底数的对数
                        
                        // 分子：所有分母底数的对数
                        const numeratorProduct = denominatorBases.map(b => `ln(${b})`).join('*');
                        
                        // 分母：变量x和所有分子底数的对数
                        const denominatorParts = [varName];
                        numeratorBases.forEach(b => denominatorParts.push(`ln(${b})`));
                        const denominatorStr = denominatorParts.join('*');
                        
                        // 构建最终结果，使用单个分数形式
                        if (lnPower === 1) {
                            if (numeratorProduct && denominatorParts.length > 0) {
                                return `${numeratorProduct}/${denominatorStr}`;
                            } else if (numeratorProduct) {
                                return `${numeratorProduct}/${varName}`;
                            } else {
                                return `1/${denominatorStr}`;
                            }
                        } else {
                            if (numeratorProduct && denominatorParts.length > 0) {
                                return `${lnPower}*${numeratorProduct}*(ln(${varName}))^${lnPower-1}/${denominatorStr}`;
                            } else if (numeratorProduct) {
                                return `${lnPower}*${numeratorProduct}*(ln(${varName}))^${lnPower-1}/${varName}`;
                            } else {
                                return `${lnPower}*(ln(${varName}))^${lnPower-1}/${denominatorStr}`;
                            }
                        }
                    }
                }
                
                // 如果不是所有部分都是对数函数，使用通用方法
                // 从左到右处理表达式
                let result = parts[0];
                let resultDeriv = this.calculateLogarithmDerivative(parts[0], varName);
                
                for (let i = 0; i < operators.length; i++) {
                    const nextPart = parts[i+1];
                    const nextDeriv = this.calculateLogarithmDerivative(nextPart, varName);
                    const operator = operators[i];
                    
                    if (operator === '*') {
                        // (f*g)' = f'*g + f*g'
                        if (resultDeriv && nextDeriv) {
                            resultDeriv = `(${resultDeriv})*${nextPart}+${result}*(${nextDeriv})`;
                        } else if (resultDeriv) {
                            resultDeriv = `(${resultDeriv})*${nextPart}`;
                        } else if (nextDeriv) {
                            resultDeriv = `${result}*(${nextDeriv})`;
                        }
                        result = `${result}*${nextPart}`;
                    } else if (operator === '/') {
                        // (f/g)' = (f'*g - f*g')/g^2
                        if (resultDeriv && nextDeriv) {
                            resultDeriv = `((${resultDeriv})*${nextPart}-${result}*(${nextDeriv}))/(${nextPart})^2`;
                        } else if (resultDeriv) {
                            resultDeriv = `(${resultDeriv})*${nextPart}/(${nextPart})^2`;
                        } else if (nextDeriv) {
                            resultDeriv = `-${result}*(${nextDeriv})/(${nextPart})^2`;
                        }
                        result = `${result}/${nextPart}`;
                    }
                }
                
                return resultDeriv;
            },
            
            // 提取对数的底数
            extractLogBase(logTerm) {
                // 处理 logN(v) 格式
                const logNMatch = logTerm.match(/^log(\d+)\(([^)]+)\)$/);
                if (logNMatch) {
                    return logNMatch[1];
                }
                
                // 处理 log(底数)(真数) 格式
                const logParenthesesMatch = logTerm.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                if (logParenthesesMatch) {
                    return logParenthesesMatch[1];
                }
                
                // 处理 log(v, b) 格式（预处理后）
                const anyBaseLogMatch = logTerm.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                if (anyBaseLogMatch) {
                    return anyBaseLogMatch[2];
                }
                
                return null;
            },
            
            // 对单个对数项求导
            deriveLogarithmTerm(termStr, varName) {
                // 处理 log(x) 自然对数
                const naturalLogMatch = termStr.match(/^log\(([^)]+)\)$/);
                if (naturalLogMatch) {
                    const arg = naturalLogMatch[1];
                    if (arg === varName) {
                        return `1/${varName}ln`;
                    }
                    // 如果是复合函数，使用链式法则
                    if (arg.includes(varName)) {
                        try {
                            const innerDerivative = math.derivative(arg, varName).toString();
                            return `${innerDerivative}/${arg}ln`;
                        } catch (e) {
                            return null; // 无法求导，返回null
                        }
                    }
                    return null; // 不包含变量，导数为0
                }
                
                // 处理 log(v, b) 任意底对数（预处理后的格式）
                const anyBaseLogMatch = termStr.match(/^log\(([^,]+),\s*([^)]+)\)$/);
                if (anyBaseLogMatch) {
                    const value = anyBaseLogMatch[1];
                    const base = anyBaseLogMatch[2];
                    
                    if (value === varName) {
                        // 判断是否为整数底数
                        const baseNum = parseFloat(base);
                        if (baseNum % 1 === 0) {
                            return `1/${varName}ln${base}`;
                        } else {
                            return `1/${varName}ln(${base})`;
                        }
                    }
                    // 如果是复合函数，使用链式法则
                    if (value.includes(varName)) {
                        try {
                            const innerDerivative = math.derivative(value, varName).toString();
                            const baseNum = parseFloat(base);
                            if (baseNum % 1 === 0) {
                                return `${innerDerivative}/${value}ln${base}`;
                            } else {
                                return `${innerDerivative}/${value}ln(${base})`;
                            }
                        } catch (e) {
                            return null; // 无法求导，返回null
                        }
                    }
                    return null; // 不包含变量，导数为0
                }
                
                // 处理 logN(v) 格式（预处理前可能存在）
                const logNMatch = termStr.match(/^log(\d+)\(([^)]+)\)$/);
                if (logNMatch) {
                    const base = logNMatch[1];
                    const value = logNMatch[2];
                    
                    if (value === varName) {
                        return `1/${varName}ln${base}`;
                    }
                    // 如果是复合函数，使用链式法则
                    if (value.includes(varName)) {
                        try {
                            const innerDerivative = math.derivative(value, varName).toString();
                            return `${innerDerivative}/${value}ln${base}`;
                        } catch (e) {
                            return null; // 无法求导，返回null
                        }
                    }
                    return null; // 不包含变量，导数为0
                }
                
                // 处理 log(底数)(真数) 格式（预处理前可能存在）
                const logParenthesesMatch = termStr.match(/^log\(([^)]+)\)\(([^)]+)\)$/);
                if (logParenthesesMatch) {
                    const base = logParenthesesMatch[1];
                    const value = logParenthesesMatch[2];
                    
                    if (value === varName) {
                        return `1/${varName}ln(${base})`;
                    }
                    // 如果是复合函数，使用链式法则
                    if (value.includes(varName)) {
                        try {
                            const innerDerivative = math.derivative(value, varName).toString();
                            return `${innerDerivative}/${value}ln(${base})`;
                        } catch (e) {
                            return null; // 无法求导，返回null
                        }
                    }
                    return null; // 不包含变量，导数为0
                }
                
                // 处理系数乘以对数的情况，如 3*log(x)
                const coeffLogMatch = termStr.match(/^(\d+(?:\.\d+)?)\s*\*\s*(log.*)$/);
                if (coeffLogMatch) {
                    const coefficient = coeffLogMatch[1];
                    const logTerm = coeffLogMatch[2];
                    const logDerivative = this.deriveLogarithmTerm(logTerm, varName);
                    if (logDerivative) {
                        return `${coefficient}*${logDerivative}`;
                    }
                }
                
                return null;
            },
            
            // 剥离 HTML 标签，用于复制文本
            // 智能求值函数，分别处理包含虚数的项和纯常数项
            intelligentEvaluate(expr, scope) {
                console.log('=== intelligentEvaluate 函数调试 ===');
                console.log('输入表达式:', expr);
                
                // 将表达式分解为各项
                const terms = [];
                try {
                    const node = math.parse(expr);
                    this.extractTerms(node, terms);
                } catch (e) {
                    console.log('无法分解表达式，尝试直接求值');
                    try {
                        const result = math.evaluate(expr, scope);
                        if (isFinite(result)) {
                            return result.toFixed(6).replace(/\.?0+$/, '');
                        } else {
                            return expr; // 无穷大或无法求值，保持原样
                        }
                    } catch (e2) {
                        console.log('直接求值失败，保持原样');
                        return expr;
                    }
                }
                
                // 分别处理每一项
                const evaluatedTerms = terms.map(term => {
                    const termStr = term.node.toString();
                    console.log('处理项:', termStr);
                    
                    // 检查是否是无穷大项
                    const { infiniteTerms } = this.getInfiniteTerms(termStr, 'x');
                    if (infiniteTerms.length > 0) {
                        console.log('项是无穷大项，保持不变:', termStr);
                        return termStr;
                    }
                    
                    // 如果项包含虚数，检查是否需要将log转换为ln
                    if (this.containsImaginary(termStr)) {
                        console.log('项包含虚数，检查是否需要转换:', termStr);
                        // 如果是log(...)形式且包含虚数，转换为ln(...)
                        if (termStr.startsWith('log(') && termStr.includes('i')) {
                            const content = termStr.slice(4, -1); // 提取括号内的内容
                            console.log(`将log(${content})转换为ln(${content})`);
                            return `ln(${content})`;
                        }
                        console.log('项包含虚数，保持不变:', termStr);
                        return termStr;
                    }
                    
                    // 否则求值
                    try {
                        console.log('尝试求值项:', termStr);
                        const result = math.evaluate(termStr, scope);
                        console.log('math.evaluate 原始结果:', result);
                        console.log('math.evaluate 结果类型:', typeof result);
                        if (typeof result === 'function') {
                            console.log('结果是函数，保持原样:', termStr);
                            return termStr;
                        } else if (isFinite(result)) {
                            const formattedResult = result.toFixed(6).replace(/\.?0+$/, '');
                            console.log('项求值结果:', termStr, '->', formattedResult);
                            return formattedResult;
                        } else {
                            console.log('项求值结果为无穷大，保持原样:', termStr);
                            return termStr;
                        }
                    } catch (e) {
                        console.log('项求值失败，保持原样:', termStr);
                        console.log('错误信息:', e.message);
                        return termStr;
                    }
                });
                
                // 重新组合表达式
                const result = evaluatedTerms.join(' + ').replace(/\+ \-/g, '- ');
                console.log('最终结果:', result);
                return result;
            },
            
            stripHtmlTags(html) {
                const temp = document.createElement('div');
                temp.innerHTML = html;
                let text = temp.textContent || temp.innerText || '';
                
                // 额外清理 logb(v) 格式
                text = text.replace(/log\s*<sub>\s*([^<]+)\s*<\/sub>\s*\(([^)]+)\)/gi, 'log($2,$1)');
                // 清理 e^() 格式 - 修复：保留所有e^格式，不转换为exp
                text = text.replace(/e\^\(([^)]+)\)/g, (match, content) => {
                    // 保留所有e^格式，包括e^x和e^(x+1)等
                    return `e^(${content})`;
                });
                
                return text;
            },
            
            addCopyFunctionality() {
                document.querySelectorAll('.copy-icon').forEach(icon => {
                    icon.addEventListener('click', async (e) => {
                        const text = e.currentTarget.getAttribute('data-text');
                        try {
                            await navigator.clipboard.writeText(text);
                            this.showSuccessMessage('已复制到剪贴板！');
                        } catch (err) {
                            const textArea = document.createElement('textarea');
                            textArea.value = text;
                            document.body.appendChild(textArea);
                            textArea.select();
                            document.execCommand('copy');
                            document.body.removeChild(textArea);
                            this.showSuccessMessage('已复制到剪贴板！');
                        }
                    });
                });
            },
            
            showSuccessMessage(message) {
                const messageEl = document.createElement('div');
                messageEl.className = 'success-message';
                messageEl.innerHTML = `<i class="fas fa-check"></i> ${message}`;
                document.body.appendChild(messageEl);
                
                setTimeout(() => {
                    document.body.removeChild(messageEl);
                }, 2000);
            }
        };
        
        // 初始化计算器
        document.addEventListener('DOMContentLoaded', () => Calculator.init());
    </script>
</body>
</html>

