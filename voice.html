<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <title>è¯­éŸ³è¯´è¯åŠŸèƒ½</title>
    <style>
        html {
            font-family: 'Arial', sans-serif;
            width: 100%;
            height: 100%;
            margin: 0;
            color: #333;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: visible;
        }
        
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 10px;
            background-color: #ffffff;
            color: #333;
            min-height: 100vh;
            box-sizing: border-box;
            overflow: visible;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        textarea {
            width: 100%;
            height: 150px;
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #ddd;
            background-color: #f8f9fa;
            color: transparent;
            font-size: 16px;
            resize: vertical;
            box-sizing: border-box;
            position: relative;
            z-index: 5;
            line-height: 2.5;
            letter-spacing: 15px;
            font-family: inherit;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: auto;
        }
        
        .pinyin-container {
            position: relative;
            width: 100%;
        }
        
        /* æ‹¼éŸ³æ˜¾ç¤ºåŒºåŸŸæ ·å¼ï¼ˆå åŠ å¸ƒå±€ï¼‰ */
        #pinyin-display {
            padding: 15px;
            user-select: text;
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            line-height: 2.5;
            font-size: 16px;
            color: #000;
            font-family: inherit;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow: hidden;
            /* è½»é‡çº§GPUåŠ é€Ÿ */
            transform: translateZ(0);
            will-change: contents;
        }
        
        #pinyin-display ruby {
            ruby-position: over;
            margin: 0 3px;
            /* è½»é‡çº§GPUåŠ é€Ÿ */
            transform: translateZ(0);
        }
        
        #pinyin-display rt {
            font-size: 11px;
            color: #000;
            font-weight: 600;
            user-select: text;
            /* è½»é‡çº§GPUåŠ é€Ÿ */
            transform: translateZ(0);
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
            align-items: stretch;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            justify-content: center;
            width: 100%;
        }
        
        .voice-control-group {
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
        }
        
        .voice-select-wrapper {
                position: relative;
                width: 100%;
                max-width: 600px;
            }
        
        select {
            max-height: 200px;
            overflow-y: auto;
        }
        
        select, input[type="range"] {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
            background-color: #f8f9fa;
            color: #333;
        }
        
        select {
            flex: 1;
        }
        
        .range-value {
            min-width: 40px;
            text-align: center;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .speak-btn {
            background-color: #4CAF50;
            color: white;
        }
        
        .speak-btn:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }
        
        .speak-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .stop-btn {
            background-color: #f44336;
            color: white;
        }
        
        .stop-btn:hover {
            background-color: #d32f2f;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }
        
        .pause-btn {
            background-color: #FF9800;
            color: white;
        }
        
        .pause-btn:hover {
            background-color: #F57C00;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }
        
        .pause-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            border-radius: 8px;
            background-color: #f8f9fa;
            color: #333;
            border: 1px solid #ddd;
        }
        
        .undo-redo-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            white-space: nowrap;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        .undo-redo-btn:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.2);
        }
        
        .undo-redo-btn:active {
            transform: translateY(0);
        }
        
        .undo-redo-btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .redo-btn {
            background-color: #2196F3;
        }
        
        .redo-btn:hover {
            background-color: #0b7dda;
        }
        
        .undo-redo-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }
        
        .toast {
            position: fixed;
            top: 20px;
            right: -100%;
            padding: 10px 15px;
            color: white;
            font-size: 0.85rem;
            font-weight: 500;
            z-index: 2000;
            opacity: 0;
            transition: all 0.4s ease-out;
            border-radius: 8px;
            box-shadow: -6px 6px 20px rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 150px;
            max-width: 250px;
        }
        
        .toast.show {
            right: 20px;
            opacity: 1;
            transition-delay: 0.1s;
        }
        
        .toast.success {
            background: linear-gradient(135deg, #00b894, #00cec9, #74b9ff);
            background-size: 200% 200%;
            animation: gradientShift 3s ease infinite;
        }
        
        .toast.error {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24, #feca57);
            background-size: 200% 200%;
            animation: gradientShift 3s ease infinite;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        @keyframes pulse {
            0% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
            100% {
                opacity: 1;
            }
        }
        
        @keyframes blink {
            0%, 50% {
                opacity: 1;
            }
            51%, 100% {
                opacity: 0;
            }
        }
        
        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        /* æ‰‹æœºç«¯é€‚é… */
        @media (max-width: 767px) {
            html, body {
                padding: 5px;
            }
            
            body {
                padding: 5px 5px 20px 5px;
            }
            
            textarea {
                height: 120px;
                font-size: 16px;
                background-color: transparent;
                color: transparent;
            }
            
            #pinyin-display {
                font-size: 16px;
                line-height: 2.5;
            }
            
            #pinyin-display .ruby-text {
                font-size: 16px;
                line-height: 2.5;
            }
            
            #pinyin-display .ruby-text rt {
                font-size: 14px;
            }
            
            .preset-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .voice-control-group {
                flex-direction: row;
                align-items: center;
                gap: 10px;
                justify-content: flex-start;
                width: 100%;
            }
            
            .voice-select-wrapper {
                flex: 1;
                max-width: 300px;
                position: relative;
                display: flex;
                align-items: center;
            }
            
            .controls {
                flex-direction: column !important;
                align-items: center !important;
                justify-content: center !important;
                gap: 15px !important;
                width: 100%;
                max-width: 350px;
                margin: 0 auto;
            }
            
            .controls > div {
                width: 100%;
                max-width: 100%;
                border-right: none !important;
                padding-right: 0 !important;
                padding-left: 0 !important;
                margin: 0 auto;
            }
            
            .controls > div:last-child {
                margin-left: -80px;
            }
            
            .control-group {
                justify-content: center;
                flex-direction: row;
                align-items: center;
                text-align: left;
                gap: 2px;
                width: 100%;
            }
            
            .control-group label {
                text-align: left;
                min-width: 50px;
            }
            
            .control-group input[type="range"] {
                flex: 1;
                max-width: 100px;
            }
            
            .range-value {
                min-width: 30px;
                text-align: center;
                font-size: 14px;
                display: inline-block;
                color: #333;
                font-weight: bold;
            }
            
            .control-group label {
                text-align: left;
            }
            
            .controls > div:first-child > .control-group > label {
                margin-left: 30px;
            }
            
            .segmentation-options {
                align-items: flex-start;
                width: 100%;
                text-align: left;
                margin-left: 30px;
            }
            
            .controls > div:first-child > .control-group > label {
                margin-left: 30px;
            }
            
            .controls > div:last-child {
                margin-left: -85px;
            }
            
            /* æ‰¹é‡è¯­éŸ³ç”Ÿæˆå¼¹çª—æ‰‹æœºç«¯æ ·å¼ä¼˜åŒ– */
            #batch-modal > div > div[style*="flex-direction: column"] > div[style*="display: flex"] {
                gap: 2px !important;
            }
            
            #batch-modal > div > div[style*="flex-direction: column"] label[style*="min-width"] {
                min-width: auto !important;
                margin-right: 0 !important;
                margin-left: -15px !important;
            }
            
            #batch-modal select {
                flex: 1 !important;
            }
        }
        
        .preset-btn {
            padding: 8px 12px;
            background-color: #6c757d;
            color: white;
            border: 1px solid #5a6268;
            font-size: 14px;
        }
        
        .preset-btn:hover {
            background-color: #5a6268;
        }
        
        /* è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†æ ·å¼ */
        .custom-select {
            position: relative;
            width: 100%;
            max-width: 600px;
        }
        
        .select-trigger {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f8f9fa;
            color: #333;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .select-trigger:hover {
            border-color: #aaa;
        }
        
        .select-trigger.active {
            border-color: #4CAF50;
            box-shadow: 0 0 5px rgba(76, 175, 80, 0.3);
        }
        
        .arrow {
            transition: transform 0.3s ease;
            font-size: 12px;
        }
        
        .arrow.up {
            transform: rotate(180deg);
        }
        
        .select-options {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: none;
        }
        
        .select-options.show {
            display: block;
        }
        
        .select-option {
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .select-option:hover {
            background-color: #f0f0f0;
        }
        
        .select-option.selected {
            background-color: #e6f7e6;
            font-weight: bold;
        }

        /* ç”µè„‘ç«¯é€‚é… */
        @media (min-width: 768px) {
            html {
                background-color: #474747;
            }
            
            body {
                max-width: 900px;
                margin: 0 auto;
                padding: 30px;
                border-radius: 8px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }
            
            h1 {
                font-size: 2.5em;
            }
            
            textarea {
                height: 180px;
                font-size: 16px;
                background-color: transparent;
                color: transparent;
            }
            
            #pinyin-display {
                font-size: 16px;
                line-height: 2.5;
            }
            
            #pinyin-display .ruby-text {
                font-size: 16px;
                line-height: 2.5;
            }
            
            #pinyin-display .ruby-text rt {
                font-size: 14px;
            }
            
            .control-group {
                gap: 15px;
            }
            
            .voice-control-group {
                flex-direction: row;
                align-items: center;
                gap: 15px;
            }
            
            .voice-select-wrapper {
                position: relative;
                overflow: visible;
                width: 100%;
                max-width: 600px;
            }
            
            input[type="range"] {
                padding: 10px;
                font-size: 16px;
            }
            
            button {
                padding: 15px 30px;
                font-size: 18px;
            }
            
            .preset-btn {
                padding: 12px 15px;
                font-size: 16px;
            }
            
            .status {
                background-color: #f8f9fa;
                color: #333;
            }
        }
        
                
        /* æ‹¼éŸ³è½¬æ¢é€‰é¡¹æ ·å¼ */
        .pinyin-options-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
            align-items: center;
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
            margin-bottom: 15px;
        }
        
        .pinyin-options-row label {
            display: flex;
            align-items: center;
            gap: 5px;
            font-weight: normal;
            cursor: pointer;
            white-space: nowrap;
        }
        
        .pinyin-options-row input[type="radio"],
        .pinyin-options-row input[type="checkbox"] {
            margin-right: 5px;
        }
        
        
    </style>
</head>
<body>
    <h1>è¯­éŸ³è¯´è¯åŠŸèƒ½</h1>
    
    <!-- æ‹¼éŸ³è½¬æ¢é€‰é¡¹ -->
    <div class="input-group">
        <div class="pinyin-options-row">
            <label><input type="radio" name="toneType" value="symbol" checked> å¸¦å£°è°ƒç¬¦å·</label>
            <label><input type="radio" name="toneType" value="num"> å¸¦å£°è°ƒæ•°å­—</label>
            <label><input type="radio" name="toneType" value="none"> æ— å£°è°ƒ</label>
            <label><input type="checkbox" id="space" checked> ä¿ç•™ç©ºæ ¼</label>
            <label><input type="checkbox" id="firstLetter"> ä»…é¦–å­—æ¯</label>
        </div>
    </div>
        
    <div class="input-group">
        <label for="hanziInput">è¾“å…¥è¦è½¬æ¢çš„æ±‰å­—ï¼š</label>
        <div class="pinyin-container">
            <div id="pinyin-display" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1; padding: 15px; box-sizing: border-box; font-family: inherit; font-size: 16px; line-height: 2.5; white-space: pre-wrap; word-wrap: break-word; overflow: hidden; text-align: left;"></div>
            <div id="virtual-cursor" style="position: absolute; top: 0; left: 0; width: 2px; height: 20px; background-color: #333; pointer-events: none; z-index: 3; display: none; animation: blink 1s infinite;"></div>
            <textarea id="hanziInput" style="position: relative; z-index: 2; background-color: transparent;"></textarea>
        </div>
    </div>
        
    <div class="input-group">
        <div style="display: flex; flex-direction: column; align-items: flex-start; justify-content: center; width: fit-content; margin: 0 auto;">
            <label for="file-input" style="text-align: left; margin-bottom: 8px; display: block;">é€‰æ‹©æ–‡æœ¬æ–‡ä»¶ï¼š</label>
            <input type="file" id="file-input" accept=".txt" style="margin: 0 auto; display: block;" />
        </div>
    </div>
        
    <div class="undo-redo-container">
        <button id="undo-btn" class="undo-redo-btn" disabled style="width: 100px;">â†¶ æ’¤é”€</button>
        <button id="redo-btn" class="undo-redo-btn redo-btn" disabled style="width: 100px;">â†· åæ’¤é”€</button>
        <button id="batch-generate-btn" class="undo-redo-btn" style="width: 120px;">ğŸ“æ ¸å¿ƒéŸ³é¢‘ä¸‹è½½</button>
    </div>
        
    <!-- è¯­éŸ³æ¨¡å‹åˆ—è¡¨ -->
    <div class="control-group voice-control-group" style="flex-direction: row; align-items: center; justify-content: center; margin-bottom: 20px; gap: 15px;">
        <label for="voice-select">è¯­éŸ³æ¨¡å‹åˆ—è¡¨ï¼š</label>
        <div class="voice-select-wrapper" style="flex: 0 0 600px;">
            <div id="custom-select" class="custom-select">
                <div id="select-trigger" class="select-trigger">
                    <span id="selected-voice">è¯·é€‰æ‹©è¯­éŸ³æ¨¡å‹</span>
                    <span class="arrow">â–¼</span>
                </div>
                <div id="select-options" class="select-options">
                    <div class="select-option" data-value="-1">æ­£åœ¨åŠ è½½è¯­éŸ³æ¨¡å‹...</div>
                </div>
            </div>
            <select id="voice-select" style="display: none;"></select>
        </div>
    </div>

    <div style="display: flex; justify-content: center; width: 100%;">
        <div class="controls" style="display: flex !important; flex-direction: row !important; gap: 40px; align-items: flex-start; justify-content: center !important;">
            <!-- å·¦ä¾§ï¼šåˆ†æ®µç­–ç•¥é€‰æ‹© -->
            <div style="flex: 0 0 250px; border-right: 1px solid #ddd; padding-right: 30px;">
                <!-- åˆ†æ®µç­–ç•¥é€‰æ‹© -->
                <div class="control-group" style="display: flex; flex-direction: column; align-items: flex-start; gap: 10px;">
                    <label style="font-weight: bold;">åˆ†æ®µç­–ç•¥ï¼š</label>
                    <div class="segmentation-options" style="display: flex; flex-direction: column; gap: 8px;">
                    <label style="font-weight: normal; display: flex; align-items: center;">
                        <input type="radio" name="segmentation" value="weight" checked style="margin-right: 8px;">
                        <span>æ™ºèƒ½æƒé‡è¯„åˆ†</span>
                    </label>
                    <label style="font-weight: normal; display: flex; align-items: center;">
                        <input type="radio" name="segmentation" value="prosody" style="margin-right: 8px;">
                        <span>è¯­éŸ³éŸµå¾‹åˆ†å‰²</span>
                    </label>
                    <label style="font-weight: normal; display: flex; align-items: center;">
                        <input type="radio" name="segmentation" value="adaptive" style="margin-right: 8px;">
                        <span>æ··åˆè‡ªé€‚åº”åˆ†æ®µ</span>
                    </label>
                    <label style="font-weight: normal; display: flex; align-items: center;">
                        <input type="radio" name="segmentation" value="context" style="margin-right: 8px;">
                        <span>å®æ—¶æ„ŸçŸ¥åˆ†æ®µ</span>
                    </label>
                    <label style="font-weight: normal; display: flex; align-items: center;">
                        <input type="radio" name="segmentation" value="semantic" style="margin-right: 8px;">
                        <span>è¯­ä¹‰æ™ºèƒ½åˆ†æ®µ</span>
                    </label>
                    <label style="font-weight: normal; display: flex; align-items: center;">
                        <input type="radio" name="segmentation" value="rhythm" style="margin-right: 8px;">
                        <span>èŠ‚å¥æ¨¡å¼åˆ†æ®µ</span>
                    </label>
                </div>
                </div>
            </div>
            
            <!-- å³ä¾§ï¼šéŸ³é‡ã€è¯­é€Ÿã€éŸ³è°ƒæ§åˆ¶ -->
            <div style="flex: 1; padding-left: 20px;">
                <div class="control-group">
                    <label for="pitch-range">éŸ³è°ƒï¼š</label>
                    <input type="range" id="pitch-range" min="0.1" max="3" value="1" step="0.1" oninput="document.getElementById('pitch-value').textContent = this.value;">
                    <span class="range-value" id="pitch-value">1</span>
                </div>
                
                <div class="control-group">
                    <label for="rate-range">è¯­é€Ÿï¼š</label>
                    <input type="range" id="rate-range" min="0.1" max="3" value="1" step="0.1" oninput="document.getElementById('rate-value').textContent = this.value;">
                    <span class="range-value" id="rate-value">1</span>
                </div>
                
                <div class="control-group">
                    <label for="volume-range">éŸ³é‡ï¼š</label>
                    <input type="range" id="volume-range" min="0.1" max="3" value="1" step="0.1" oninput="document.getElementById('volume-value').textContent = this.value;">
                    <span class="range-value" id="volume-value">1</span>
                </div>
                <div style="text-align: left; font-size: 14px; color: #666; margin-top: 5px;">
                    æœ‰æ•ˆå€¼ï¼šéŸ³è°ƒ 0.1-2ã€è¯­é€Ÿ 0.1-3ã€éŸ³é‡ 0.1-2
                </div>
            </div>
        </div>
    </div>
        
    <div class="button-group">
        <button id="speak-btn" class="speak-btn">å¼€å§‹æœ—è¯»</button>
        <button id="pause-btn" class="pause-btn" disabled>æš‚åœ</button>
        <button id="stop-btn" class="stop-btn">åœæ­¢æœ—è¯»</button>
    </div>
        
    <div id="status" class="status">å‡†å¤‡å°±ç»ª</div>
    
    <!-- Toast æç¤º -->
    <div id="toast" class="toast"></div>
    
    <!-- æ‰¹é‡è¯­éŸ³ç”Ÿæˆå¼¹çª— -->
    <div id="batch-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 3000; justify-content: center; align-items: center;">
        <div style="background-color: #fff; border-radius: 12px; padding: 30px; max-width: 800px; width: 90%; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); position: relative;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; position: sticky; top: 0; background-color: #fff; padding-bottom: 10px; z-index: 10;">
                <h2 style="margin: 0; font-size: 24px; color: #333;">æ‰¹é‡è¯­éŸ³ç”Ÿæˆ</h2>
                <button id="batch-close-btn" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #666; padding: 0; width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; position: relative; z-index: 10;">Ã—</button>
            </div>
            
            <div class="input-group" style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold;">è¾“å…¥æ–‡æœ¬ï¼š</label>
                <textarea id="batch-text-input" placeholder="åœ¨è¿™é‡Œè¾“å…¥è¦åˆæˆçš„æ–‡æœ¬..." style="width: 100%; height: 200px; padding: 15px; border-radius: 10px; border: 1px solid #ddd; background-color: #f8f9fa; color: #333; font-size: 16px; resize: vertical; box-sizing: border-box; letter-spacing: 2px; word-spacing: 5px; line-height: normal;"></textarea>
            </div>
            
            <div class="input-group" style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: bold;">é€‰æ‹©æ–‡æœ¬æ–‡ä»¶ï¼š</label>
                <input type="file" id="batch-file-input" accept="*" style="margin: 0 auto; display: block;" />
            </div>
            
            <div style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: bold; min-width: 100px;">è¯­éŸ³æ¨¡å‹ï¼š</label>
                    <select id="batch-voice-select" style="flex: 1; padding: 8px; border-radius: 5px; border: 1px solid #ddd; background-color: #f8f9fa;">
    <!-- Edge-TTS é«˜è´¨é‡è¯­éŸ³æ¨¡å‹ -->
    <optgroup label="ğŸ™ï¸ Edge-TTS é«˜è´¨é‡è¯­éŸ³ï¼ˆæ¨èï¼‰">
        <option value="zh-CN-XiaoxiaoNeural" selected>æ™“æ™“ - å¤§é™†å¥³å£°ï¼ˆæ¸©æŸ”æ¸©æš–ï¼‰</option>
        <option value="zh-CN-XiaoyiNeural">æ™“ä¾ - å¤§é™†å¥³å£°ï¼ˆæ´»æ³¼å¯çˆ±ï¼‰</option>
        <option value="zh-CN-YunjianNeural">äº‘å¥ - å¤§é™†ç”·å£°ï¼ˆæ¿€æƒ…æ¾æ¹ƒï¼‰</option>
        <option value="zh-CN-YunxiNeural">äº‘å¸Œ - å¤§é™†ç”·å£°ï¼ˆé˜³å…‰æ´»åŠ›ï¼‰</option>
        <option value="zh-CN-YunxiaNeural">äº‘å¤ - å¤§é™†ç”·å£°ï¼ˆå¯çˆ±äº²åˆ‡ï¼‰</option>
        <option value="zh-CN-YunyangNeural">äº‘æ‰¬ - å¤§é™†ç”·å£°ï¼ˆä¸“ä¸šå¯é ï¼‰</option>
    </optgroup>
    
    <optgroup label="ğŸŒ Edge-TTS æ–¹è¨€è¯­éŸ³">
        <option value="zh-CN-liaoning-XiaobeiNeural">å°è´ - ä¸œåŒ—è¯ï¼ˆå¹½é»˜é£è¶£ï¼‰</option>
        <option value="zh-CN-shaanxi-XiaoniNeural">å°å¦® - é™•è¥¿è¯ï¼ˆæ˜å¿«äº®ä¸½ï¼‰</option>
    </optgroup>
    
    <optgroup label="ğŸ‡¨ğŸ‡³ Edge-TTS å°æ¹¾è¯­éŸ³">
        <option value="zh-TW-HsiaoChenNeural">æ™“ç”„ - å°æ¹¾å¥³å£°ï¼ˆå‹å¥½äº²åˆ‡ï¼‰</option>
        <option value="zh-TW-HsiaoYuNeural">æ™“é›¨ - å°æ¹¾å¥³å£°ï¼ˆè‡ªç„¶æµç•…ï¼‰</option>
        <option value="zh-TW-YunJheNeural">äº‘å“² - å°æ¹¾ç”·å£°ï¼ˆå‹å¥½äº²åˆ‡ï¼‰</option>
    </optgroup>
    
    <optgroup label="ğŸ‡¨ğŸ‡³ Edge-TTS ç²¤è¯­è¯­éŸ³">
        <option value="zh-HK-HiuGaaiNeural">æ›‰ä½³ - é¦™æ¸¯å¥³å£°ï¼ˆå‹å¥½äº²åˆ‡ï¼‰</option>
        <option value="zh-HK-HiuMaanNeural">æ›‰æ–‡ - é¦™æ¸¯å¥³å£°ï¼ˆå‹å¥½äº²åˆ‡ï¼‰</option>
        <option value="zh-HK-WanLungNeural">äº‘é¾ - é¦™æ¸¯ç”·å£°ï¼ˆå‹å¥½äº²åˆ‡ï¼‰</option>
    </optgroup>
</select>
                    <button id="preview-btn" style="padding: 8px 15px; border: none; border-radius: 5px; background-color: #4CAF50; color: white; cursor: pointer; white-space: nowrap;">ğŸ”Š è¯•å¬</button>
                </div>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: bold; min-width: 100px;">åˆ†æ®µç­–ç•¥ï¼š</label>
                    <select id="batch-segmentation-select" style="flex: 1; padding: 8px; border-radius: 5px; border: 1px solid #ddd; background-color: #f8f9fa;">
                        <option value="weight">æ™ºèƒ½æƒé‡è¯„åˆ†</option>
                        <option value="prosody">è¯­éŸ³éŸµå¾‹åˆ†å‰²</option>
                        <option value="adaptive">æ··åˆè‡ªé€‚åº”åˆ†æ®µ</option>
                        <option value="context">å®æ—¶æ„ŸçŸ¥åˆ†æ®µ</option>
                        <option value="semantic">è¯­ä¹‰æ™ºèƒ½åˆ†æ®µ</option>
                        <option value="rhythm">èŠ‚å¥æ¨¡å¼åˆ†æ®µ</option>
                    </select>
                </div>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: bold; min-width: 100px;">éŸ³è°ƒï¼š</label>
                    <input type="range" id="batch-pitch-range" min="0.1" max="2" value="1" step="0.1" style="flex: 1;">
                    <span id="batch-pitch-value" class="range-value">1</span>
                </div>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: bold; min-width: 100px;">è¯­é€Ÿï¼š</label>
                    <input type="range" id="batch-rate-range" min="0.1" max="3" value="1" step="0.1" style="flex: 1;">
                    <span id="batch-rate-value" class="range-value">1</span>
                </div>
                
                <div style="display: flex; align-items: center; gap: 10px;">
                    <label style="font-weight: bold; min-width: 100px;">éŸ³é‡ï¼š</label>
                    <input type="range" id="batch-volume-range" min="0.1" max="2" value="1" step="0.1" style="flex: 1;">
                    <span id="batch-volume-value" class="range-value">1</span>
                </div>
            </div>
            
            <div id="batch-status" style="text-align: center; margin-bottom: 20px; padding: 10px; border-radius: 8px; background-color: #f8f9fa; color: #333; border: 1px solid #ddd;">
                å‡†å¤‡å°±ç»ª
            </div>
            
            <div style="display: flex; gap: 10px; justify-content: center;">
                <button id="batch-synthesize-btn" style="flex: 1; padding: 12px 25px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; background-color: #4CAF50; color: white; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">ğŸµ æœ¬åœ°éƒ¨ç½²</button>
                <button id="batch-export-btn" style="flex: 1; padding: 12px 25px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; background-color: #FF9800; color: white; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">ğŸ“ å¯¼å‡ºé…ç½®</button>
                <button id="batch-download-btn" style="flex: 1; padding: 12px 25px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold; background-color: #2196F3; color: white; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">ğŸ“¥ ç”ŸæˆéŸ³é¢‘</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== æ ¸å¿ƒéŸ³é¢‘ä¸‹è½½çª—å£é€»è¾‘ï¼ˆä¸ä¾èµ–ä»»ä½•åº“ï¼Œç§»åˆ°æœ€å‰é¢ï¼‰ ====================
        // æ‰¹é‡ç”ŸæˆåŠŸèƒ½ï¼ˆç«‹å³æ‰§è¡Œï¼Œä¸ä¾èµ– speechSynthesisï¼‰
        (function() {
            const batchModal = document.getElementById('batch-modal');
            const batchText = document.getElementById('batch-text-input');
            const batchFileInput = document.getElementById('batch-file-input');
            const batchVoiceSelect = document.getElementById('batch-voice-select');
            const batchSegmentationSelect = document.getElementById('batch-segmentation-select');
            const batchPitchRange = document.getElementById('batch-pitch-range');
            const batchRateRange = document.getElementById('batch-rate-range');
            const batchVolumeRange = document.getElementById('batch-volume-range');
            const batchPitchValue = document.getElementById('batch-pitch-value');
            const batchRateValue = document.getElementById('batch-rate-value');
            const batchVolumeValue = document.getElementById('batch-volume-value');
            const batchStatus = document.getElementById('batch-status');
            const batchSynthesizeBtn = document.getElementById('batch-synthesize-btn');
            const batchDownloadBtn = document.getElementById('batch-download-btn');
            
            let batchVoiceList = [];
            
            // éšæœºé¢œè‰²æ•°ç»„ï¼ˆåŒ…å«æ‰€æœ‰é¢œè‰²ï¼‰
            const allColors = [
                '#FF0000', '#FF7F00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#8B00FF', '#FF00FF',
                '#FF1493', '#FF69B4', '#FFB6C1', '#FFA07A', '#00CED1', '#20B2AA', '#3CB371', '#2E8B57',
                '#9400D3', '#8A2BE2', '#7B68EE', '#6495ED', '#FFD700', '#FFA500', '#FF8C00', '#FF4500',
                '#32CD32', '#00FA9A', '#00FF7F', '#7FFF00', '#1E90FF', '#4169E1', '#0000CD', '#191970',
                '#C71585', '#DB7093', '#F0E68C', '#BDB76B', '#9ACD32', '#6B8E23', '#FF6B6B', '#4ECDC4',
                '#45B7D1', '#96CEB4', '#7FDBDA', '#6B73FF', '#A78BFA', '#C3A5FF', '#FFE66D', '#FF8E72',
                '#FFAB91', '#8B5CF6', '#7C3AED', '#6D28D9', '#A0522D', '#CD853F', '#D2691E', '#BC8F8F',
                '#F4A460', '#DAA520', '#B8860B', '#FF6347', '#FF4500', '#DC143C', '#B22222', '#8B0000'
            ];
            
            // éšæœºé¢œè‰²å‡½æ•°
            function getRandomColor() {
                return allColors[Math.floor(Math.random() * allColors.length)];
            }
            
            // éšæœºè§’åº¦å‡½æ•°ï¼ˆ0-360åº¦ï¼‰
            function getRandomAngle() {
                return Math.random() * 360;
            }
            
            // æ›´æ–°åœ†ç¯é¢œè‰²
            function updateRingColors() {
                const closeBtn = document.getElementById('batch-close-btn');
                if (!closeBtn) return;
                
                // éšæœºè®¾ç½®8ä¸ªè¾¹æ¡†é¢œè‰²
                closeBtn.style.setProperty('--color-1', getRandomColor());
                closeBtn.style.setProperty('--color-2', getRandomColor());
                closeBtn.style.setProperty('--color-3', getRandomColor());
                closeBtn.style.setProperty('--color-4', getRandomColor());
                closeBtn.style.setProperty('--color-5', getRandomColor());
                closeBtn.style.setProperty('--color-6', getRandomColor());
                closeBtn.style.setProperty('--color-7', getRandomColor());
                closeBtn.style.setProperty('--color-8', getRandomColor());
            }
            
            // å¯åŠ¨éšæœºé¢œè‰²å’Œæ—‹è½¬åŠ¨ç”»
            function startRandomAnimation() {
                setInterval(() => {
                    updateRingColors();
                }, 800); // æ¯800æ¯«ç§’åˆ‡æ¢ä¸€æ¬¡é¢œè‰²
            }
            
            // æ·»åŠ CSSæ ·å¼
            const style = document.createElement('style');
            style.textContent = `
                #batch-close-btn {
                    position: relative;
                    --rotate-before: 0deg;
                    --rotate-after: 0deg;
                    --color-1: #FF6B6B;
                    --color-2: #4ECDC4;
                    --color-3: #45B7D1;
                    --color-4: #96CEB4;
                    --color-5: #FFE66D;
                    --color-6: #FF6B6B;
                    --color-7: #4ECDC4;
                    --color-8: #45B7D1;
                }
                
                #batch-close-btn::before {
                    content: '';
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 50px;
                    height: 50px;
                    border-radius: 50%;
                    border: 4px solid transparent;
                    border-top-color: var(--color-1);
                    border-right-color: var(--color-2);
                    border-bottom-color: var(--color-3);
                    border-left-color: var(--color-4);
                    z-index: -1;
                    animation: spinBefore 2s linear infinite;
                    transition: border-color 0.5s ease-in-out;
                    box-shadow: 0 0 15px rgba(78, 205, 196, 0.5);
                }
                
                #batch-close-btn::after {
                    content: '';
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 35px;
                    height: 35px;
                    border-radius: 50%;
                    border: 3px solid transparent;
                    border-top-color: var(--color-5);
                    border-right-color: var(--color-6);
                    border-bottom-color: var(--color-7);
                    border-left-color: var(--color-8);
                    z-index: -1;
                    animation: spinAfter 1.5s linear infinite;
                    transition: border-color 0.5s ease-in-out;
                    box-shadow: 0 0 10px rgba(255, 230, 109, 0.5);
                }
                
                @keyframes spinBefore {
                    0% {
                        transform: translate(-50%, -50%) rotate(0deg);
                    }
                    100% {
                        transform: translate(-50%, -50%) rotate(360deg);
                    }
                }
                
                @keyframes spinAfter {
                    0% {
                        transform: translate(-50%, -50%) rotate(360deg);
                    }
                    100% {
                        transform: translate(-50%, -50%) rotate(0deg);
                    }
                }
            `;
            document.head.appendChild(style);
            
            // å¯åŠ¨éšæœºåŠ¨ç”»
            startRandomAnimation();
            
            // æ‰“å¼€æ‰¹é‡ç”Ÿæˆå¼¹çª—
            document.getElementById('batch-generate-btn').addEventListener('click', () => {
                batchModal.style.display = 'flex';
                
                // è¯­éŸ³æ¨¡å‹å·²ç»åœ¨ HTML ä¸­é™æ€å®šä¹‰ï¼Œæ— éœ€åŠ¨æ€åŠ è½½
                console.log('æ‰¹é‡è¯­éŸ³ç”Ÿæˆå¼¹çª—å·²æ‰“å¼€ï¼Œä½¿ç”¨ Edge-TTS è¯­éŸ³æ¨¡å‹');
            });
            
            // å…³é—­å¼¹çª—
            document.getElementById('batch-close-btn').addEventListener('click', () => {
                batchModal.style.display = 'none';
            });
            
            // æ–‡ä»¶ä¸Šä¼ ï¼ˆå®Œå…¨ç…§æ‰¹è¾“å…¥æ¡†é€»è¾‘ï¼‰
            batchFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    batchStatus.textContent = 'æ­£åœ¨è¯»å–æ–‡ä»¶...';
                    
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const fileContent = event.target.result;
                        batchText.value = fileContent;
                        batchStatus.textContent = `æ–‡ä»¶å·²åŠ è½½: ${file.name} (${fileContent.length} å­—)`;
                    };
                    reader.onerror = () => {
                        batchStatus.textContent = 'æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•';
                    };
                    reader.readAsText(file, 'UTF-8');
                }
            });
            
            // å®æ—¶æ›´æ–°å‚æ•°æ˜¾ç¤º
            batchPitchRange.addEventListener('input', () => {
                batchPitchValue.textContent = batchPitchRange.value;
            });
            
            batchRateRange.addEventListener('input', () => {
                batchRateValue.textContent = batchRateRange.value;
            });
            
            batchVolumeRange.addEventListener('input', () => {
                batchVolumeValue.textContent = batchVolumeRange.value;
            });
            
            // å¯¼å‡ºé…ç½®
            const batchExportBtn = document.getElementById('batch-export-btn');
            if (batchExportBtn) {
                batchExportBtn.addEventListener('click', () => {
                    const text = batchText.value.trim();
                    if (!text) {
                        batchStatus.textContent = 'è¯·è¾“å…¥æ–‡æœ¬æˆ–é€‰æ‹©æ–‡ä»¶';
                        return;
                    }
                    
                    // åˆ›å»ºé…ç½®å¯¹è±¡
                    const config = {
                        text: text,
                        voice_model: batchVoiceSelect.value,  // ä½¿ç”¨ Edge-TTS è¯­éŸ³ ID
                        voice_name: batchVoiceSelect.options[batchVoiceSelect.selectedIndex]?.text || '',
                        voice_index: batchVoiceSelect.value,
                        segmentation_strategy: batchSegmentationSelect.value,
                        pitch: parseFloat(batchPitchRange.value),
                        rate: parseFloat(batchRateRange.value),
                        volume: parseFloat(batchVolumeRange.value),
                        output_file: 'speech_output.mp3',
                        method: 'edge-tts-js',  // æ ‡è¯†ä½¿ç”¨ JavaScript å®ç°
                        note: 'æ­¤é…ç½®æ–‡ä»¶å¯ç›´æ¥åœ¨æµè§ˆå™¨ä¸­ä½¿ç”¨ï¼Œæ— éœ€ Python æœåŠ¡å™¨'
                    };
                    
                    // å¯¼å‡ºä¸º JSON æ–‡ä»¶
                    const configJson = JSON.stringify(config, null, 2);
                    const blob = new Blob([configJson], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'speech_config.json';
                    a.click();
                    URL.revokeObjectURL(url);
                    
                    batchStatus.textContent = 'âœ… é…ç½®æ–‡ä»¶å·²å¯¼å‡ºï¼šspeech_config.jsonï¼ˆå¯ç”¨äºå¤‡ç”¨æˆ–åˆ†äº«ï¼‰';
                });
            }
            
            // è¯•å¬é¢„è§ˆ
            batchSynthesizeBtn.addEventListener('click', async () => {
                const text = batchText.value.trim();
                
                batchSynthesizeBtn.disabled = true;
                batchSynthesizeBtn.textContent = 'â³ è¯•å¬ä¸­...';
                batchStatus.textContent = 'æ­£åœ¨è¯•å¬è¯­éŸ³ï¼Œè¯·ç¨å€™...';
                
                try {
                    const selectedVoice = batchVoiceSelect.value;
                    
                    // Edge-TTS è¯­éŸ³æ— æ³•åœ¨æµè§ˆå™¨ä¸­è¯•å¬ï¼Œæç¤ºç”¨æˆ·ç›´æ¥ä¸‹è½½
                    // ç®€åŒ–ç‰ˆæœ¬ - åªç”¨ä¸€ç§æ•ˆæœ
                    document.head.insertAdjacentHTML('beforeend', `
                    <style>
                        @keyframes download-pulse {
                            0% {
                                box-shadow: 0 0 0 0 rgba(74, 0, 255, 0.7);
                            }
                            70% {
                                box-shadow: 0 0 0 10px rgba(74, 0, 255, 0);
                            }
                            100% {
                                box-shadow: 0 0 0 0 rgba(74, 0, 255, 0);
                            }
                        }
                        
                        .download-pulse {
                            display: inline-flex;
                            align-items: center;
                            justify-content: center;
                            width: 20px;
                            height: 20px;
                            background-color: #4a00ff;
                            border-radius: 50%;
                            color: white;
                            cursor: pointer;
                            margin: 0 5px;
                            font-size: 12px;
                            animation: download-pulse 2s infinite;
                            transition: all 0.3s ease;
                        }
                        
                        .download-pulse:hover {
                            transform: scale(1.1);
                            background-color: #3a00cc;
                        }
                    </style>
                    `);

                    batchStatus.innerHTML = `
                        <div style="text-align: center; color: #d32f2f; margin-bottom: 15px;">
                            <strong>æœ¬åœ°éƒ¨ç½² ğŸ’¡ æç¤º</strong>
                        </div>
                        <div style="text-align: left; color: #d32f2f;">
                            - å®‰è£… Python: å‘½ä»¤è¡Œæˆ–å®˜ç½‘ä¸‹è½½å®‰è£…<br>
                            - <strong style="color: #4a00ff;">å¯åŠ¨æœåŠ¡å™¨ï¼ˆæ¨èï¼‰</strong>: è¿è¡Œå‘½ä»¤ <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">python edge_tts_proxy.py</code> 
                            <span onclick="downloadFile('tts_voice_proxy/edge_tts_proxy.py', 'edge_tts_proxy.py')" class="download-pulse" title="ç‚¹å‡»ä¸‹è½½">â†“</span><br>
                            - è¿è¡Œå‘½ä»¤è¡Œç”Ÿæˆï¼ˆä¸æ¨èï¼‰: <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">python text_to_speech_edge.py speech_config.json</code>
                            <span onclick="downloadFile('tts_voice_proxy/text_to_speech_edge.py', 'text_to_speech_edge.py')" class="download-pulse" title="ç‚¹å‡»ä¸‹è½½">â†“</span><br>
                            - <strong style="color: #4a00ff;">æ‰‹æœºç«¯ä½¿ç”¨ï¼ˆéœ€è¦ Termuxï¼‰</strong>: <a href="https://www.123865.com/s/yS8UVv-82Red?pwd=6666#" target="_blank" style="color: #4a00ff; text-decoration: none; font-weight: bold;">ä¸‹è½½ Termux</a>
                            <a href="https://www.123865.com/s/yS8UVv-82Red?pwd=6666#" target="_blank" class="download-pulse" style="color: white; text-decoration: none;" title="ç‚¹å‡»ä¸‹è½½">â†“</a>ï¼Œå®‰è£…åè¿è¡Œ: <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">python edge_tts_proxy.py</code>
                            <span onclick="downloadFile('tts_voice_proxy/edge_tts_proxy.py', 'edge_tts_proxy.py')" class="download-pulse" title="ç‚¹å‡»ä¸‹è½½">â†“</span><br>
                            - åœæ­¢æœåŠ¡å™¨: æŒ‰ <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">Ctrl + C</code> æˆ–è¿è¡Œå‘½ä»¤ <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">netstat -ano | findstr :9191</code> ç„¶å <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">taskkill /F /PID <è¿›ç¨‹ID></code>
                        </div>
                    `;
                    batchDownloadBtn.disabled = false;
                    
                } catch (error) {
                    batchStatus.textContent = `è¯•å¬å¤±è´¥ï¼š${error.message}`;
                }
                
                batchSynthesizeBtn.disabled = false;
                batchSynthesizeBtn.textContent = 'ğŸµ æœ¬åœ°éƒ¨ç½²';
            });
            
            // ==================== è¯•å¬é¢„è§ˆåŠŸèƒ½ ====================
            const previewBtn = document.getElementById('preview-btn');
            let previewAudio = null;
            
            previewBtn.addEventListener('click', async () => {
                const selectedVoice = batchVoiceSelect.value;
                const selectedOption = batchVoiceSelect.options[batchVoiceSelect.selectedIndex];
                const voiceShortName = selectedOption.text.split(' - ')[0];
                
                // ç”Ÿæˆè¯•å¬æ–‡æœ¬
                const previewText = `ä½ å¥½ï¼Œæˆ‘æ˜¯${voiceShortName}è¯­éŸ³æ¨¡å‹`;
                
                console.log('[è¯•å¬] å¼€å§‹è¯•å¬:', voiceShortName, previewText);
                
                // ç¦ç”¨æŒ‰é’®
                previewBtn.disabled = true;
                previewBtn.textContent = 'â³ ç”Ÿæˆä¸­...';
                
                try {
                    // åˆ›å»º WebSocket è¿æ¥
                    const ws = new WebSocket('ws://localhost:9191');
                    
                    const audioData = await new Promise((resolve, reject) => {
                        ws.onopen = () => {
                            console.log('[è¯•å¬] WebSocket è¿æ¥å·²å»ºç«‹');
                            // å‘é€è¯•å¬è¯·æ±‚
                            ws.send(JSON.stringify({
                                text: previewText,
                                voice_model: selectedVoice,
                                pitch: 1,
                                rate: 1,
                                volume: 1,
                                preview: true  // æ ‡è®°ä¸ºè¯•å¬æ¨¡å¼
                            }));
                        };
                        
                        ws.onmessage = (event) => {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'audio') {
                                console.log('[è¯•å¬] éŸ³é¢‘æ•°æ®å·²æ¥æ”¶');
                                const audioBytes = new Uint8Array(data.data.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                                const audioBlob = new Blob([audioBytes], { type: 'audio/mpeg' });
                                resolve(audioBlob);
                            } else if (data.type === 'error') {
                                reject(new Error(data.message));
                            }
                        };
                        
                        ws.onerror = (error) => {
                            console.error('[è¯•å¬] WebSocket é”™è¯¯:', error);
                            reject(new Error('WebSocket è¿æ¥é”™è¯¯'));
                        };
                        
                        ws.onclose = () => {
                            console.log('[è¯•å¬] WebSocket è¿æ¥å·²å…³é—­');
                        };
                    });
                    
                    // æ’­æ”¾è¯•å¬éŸ³é¢‘
                    if (previewAudio) {
                        previewAudio.pause();
                        previewAudio = null;
                    }
                    
                    previewAudio = new Audio(URL.createObjectURL(audioData));
                    previewAudio.play();
                    
                    console.log('[è¯•å¬] éŸ³é¢‘æ’­æ”¾ä¸­');
                    
                } catch (error) {
                    console.error('[è¯•å¬] é”™è¯¯:', error);
                    alert('è¯•å¬å¤±è´¥: ' + error.message);
                } finally {
                    // æ¢å¤æŒ‰é’®
                    previewBtn.disabled = false;
                    previewBtn.textContent = 'ğŸ”Š è¯•å¬';
                }
            });
            
            // ==================== å–æ¶ˆç”ŸæˆåŠŸèƒ½ ====================
            let currentWebSocket = null;
            let currentTimerInterval = null;
            
            // æ·»åŠ å–æ¶ˆæŒ‰é’®äº‹ä»¶ç›‘å¬å™¨ï¼ˆä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼‰
            document.addEventListener('click', (e) => {
                if (e.target.id === 'cancel-btn') {
                    // æ˜¾ç¤ºç¡®è®¤å¼¹çª—
                    if (confirm('ç¡®å®šè¦å–æ¶ˆç”Ÿæˆå—ï¼Ÿ')) {
                        console.log('[å–æ¶ˆ] ç”¨æˆ·ç¡®è®¤å–æ¶ˆç”Ÿæˆ');
                        
                        // å‘é€å–æ¶ˆæ¶ˆæ¯
                        if (currentWebSocket && currentWebSocket.readyState === WebSocket.OPEN) {
                            currentWebSocket.send(JSON.stringify({ type: 'cancel' }));
                            console.log('[å–æ¶ˆ] å·²å‘é€å–æ¶ˆæ¶ˆæ¯');
                        }
                        
                        // å…³é—­ WebSocket
                        if (currentWebSocket) {
                            currentWebSocket.close();
                            currentWebSocket = null;
                        }
                        
                        // åœæ­¢è®¡æ—¶å™¨
                        if (currentTimerInterval) {
                            clearInterval(currentTimerInterval);
                            currentTimerInterval = null;
                        }
                        
                        // æ¢å¤æŒ‰é’®çŠ¶æ€
                        batchDownloadBtn.disabled = false;
                        batchDownloadBtn.textContent = 'ğŸ“¥ ç”ŸæˆéŸ³é¢‘';
                        
                        // æ›´æ–°çŠ¶æ€ä¿¡æ¯ï¼Œè¿›åº¦æ¡æ•´ä½“æ¶ˆå¤±
                        batchStatus.innerHTML = `
                            <strong>âŒ ç”Ÿæˆå·²å–æ¶ˆ</strong><br><br>
                            <div style="font-size: 14px; color: #666;">
                                éŸ³é¢‘ç”Ÿæˆå·²è¢«ç”¨æˆ·å–æ¶ˆ
                            </div>
                        `;
                        batchStatus.style.textAlign = 'center';
                        batchStatus.style.display = 'block';
                        
                        console.log('[å–æ¶ˆ] ç”Ÿæˆå·²å–æ¶ˆ');
                    }
                }
            });
            
            // ç”ŸæˆéŸ³é¢‘æ–‡ä»¶ï¼ˆç›´æ¥ä½¿ç”¨ JavaScript è°ƒç”¨ Edge-TTS APIï¼‰
            batchDownloadBtn.addEventListener('click', async () => {
                const text = batchText.value.trim();
                
                if (!text) {
                    batchStatus.textContent = 'è¯·è¾“å…¥æ–‡æœ¬æˆ–é€‰æ‹©æ–‡ä»¶';
                    return;
                }
                
                batchDownloadBtn.disabled = true;
                batchDownloadBtn.textContent = 'â³ ç”Ÿæˆä¸­...';
                
                // æ·»åŠ è¿›åº¦æ¡
                batchStatus.innerHTML = `
                    <div style="width: 100%;">
                                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;">
                                                <span>æ­£åœ¨ç”ŸæˆéŸ³é¢‘...</span>
                                                <div style="display: flex; align-items: center; gap: 15px;">
                                                    <span id="progress-timer">0ç§’</span>
                                                    <span id="progress-percent">0%</span>
                                                    <button id="cancel-btn" style="padding: 5px 12px; border: none; border-radius: 5px; background-color: #f44336; color: white; cursor: pointer; font-size: 14px;">âŒ å–æ¶ˆ</button>
                                                </div>
                                            </div>                            <div style="width: 100%; background-color: #e0e0e0; border-radius: 10px; overflow: hidden; height: 20px;">
                        <div id="progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #2196F3, #64B5F6); transition: width 0.3s ease; border-radius: 10px;"></div>
                    </div>
                </div>
                `;
                
                try {
                    // è·å–å‚æ•°
                    const selectedVoice = batchVoiceSelect.value;
                    const pitch = parseFloat(batchPitchRange.value);
                    const rate = parseFloat(batchRateRange.value);
                    const volume = parseFloat(batchVolumeRange.value);
                    
                    // è·å–è¿›åº¦æ¡å…ƒç´ 
                    const progressBar = document.getElementById('progress-bar');
                    const progressPercent = document.getElementById('progress-percent');
                    const progressTimer = document.getElementById('progress-timer');
                    
                    // å¼€å§‹è®¡æ—¶
                    let startTime = Date.now();
                    currentTimerInterval = setInterval(() => {
                        const elapsed = Math.floor((Date.now() - startTime) / 1000);
                        if (progressTimer) {
                            if (elapsed >= 60) {
                                const minutes = Math.floor(elapsed / 60);
                                const seconds = elapsed % 60;
                                progressTimer.textContent = `${minutes}åˆ†${seconds}ç§’`;
                            } else {
                                progressTimer.textContent = `${elapsed}ç§’`;
                            }
                        }
                    }, 1000);
                    
                    // è·å–æ¨¡å‹ç®€å†™åï¼ˆä»optionæ–‡æœ¬ä¸­æå–ï¼‰
                    const voiceOption = batchVoiceSelect.options[batchVoiceSelect.selectedIndex];
                    const voiceShortName = voiceOption.text.split(' - ')[0]; // æå–"æ™“æ™“"éƒ¨åˆ†
                    
                    console.log('[Edge-TTS] å¼€å§‹ç”ŸæˆéŸ³é¢‘');
                    console.log('[Edge-TTS] è¯­éŸ³æ¨¡å‹:', selectedVoice);
                    console.log('[Edge-TTS] æ¨¡å‹ç®€å†™:', voiceShortName);
                    console.log('[Edge-TTS] æ–‡æœ¬é•¿åº¦:', text.length);
                    
                    // ç”Ÿæˆæ—¶é—´æˆ³æ–‡ä»¶åï¼ˆæ ¼å¼ï¼šæ¨¡å‹ç®€å†™_speech_æ—¶é—´æˆ³.mp3ï¼‰
                    const timestamp = new Date().getTime();
                    const outputFileName = `${voiceShortName}_speech_${timestamp}.mp3`;
                    
                    // åˆ›å»º WebSocket è¿æ¥
                    const ws = new WebSocket('ws://localhost:9191');
                    currentWebSocket = ws;  // ä¿å­˜å¼•ç”¨ç”¨äºå–æ¶ˆ
                    
                    // åˆ›å»ºè¯·æ±‚é…ç½®
                    const requestConfig = {
                        text: text,
                        voice_model: selectedVoice,
                        pitch: pitch,
                        rate: rate,
                        volume: volume
                    };
                    
                    // ä½¿ç”¨ Promise åŒ…è£… WebSocket
                    const audioData = await new Promise((resolve, reject) => {
                        let totalBytes = 0;
                        let audioHex = '';
                        
                        ws.onopen = () => {
                            console.log('[WebSocket] è¿æ¥å·²å»ºç«‹');
                            // å‘é€é…ç½®
                            ws.send(JSON.stringify(requestConfig));
                        };
                        
                        ws.onmessage = (event) => {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'init') {
                                console.log('[WebSocket] æ€»å—æ•°:', data.total_chunks, 'æ€»å¤§å°:', data.total_bytes);
                                totalBytes = data.total_bytes;
                            } else if (data.type === 'progress') {
                                // æ›´æ–°è¿›åº¦æ¡
                                if (progressBar && progressPercent) {
                                    progressBar.style.width = data.progress + '%';
                                    progressPercent.textContent = data.progress + '%';
                                }
                                console.log(`[WebSocket] è¿›åº¦: ${data.progress}%`);
                            } else if (data.type === 'audio') {
                                // æ¥æ”¶éŸ³é¢‘æ•°æ®ï¼ˆåå…­è¿›åˆ¶ï¼‰
                                audioHex = data.data;
                                console.log('[WebSocket] éŸ³é¢‘æ•°æ®å·²æ¥æ”¶ï¼Œå¤§å°:', data.size);
                            } else if (data.type === 'complete') {
                                console.log('[WebSocket] éŸ³é¢‘ç”Ÿæˆå®Œæˆ');
                                // å°†åå…­è¿›åˆ¶è½¬æ¢ä¸ºäºŒè¿›åˆ¶
                                const audioBytes = new Uint8Array(audioHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));
                                const audioBlob = new Blob([audioBytes], { type: 'audio/mpeg' });
                                resolve(audioBlob);
                            } else if (data.type === 'cancelled') {
                                console.log('[WebSocket] ç”Ÿæˆå·²å–æ¶ˆ');
                                reject(new Error('ç”Ÿæˆå·²å–æ¶ˆ'));
                            } else if (data.type === 'error') {
                                reject(new Error(data.message));
                            }
                        };
                        
                        ws.onerror = (error) => {
                            console.error('[WebSocket] é”™è¯¯:', error);
                            reject(new Error('WebSocket è¿æ¥é”™è¯¯'));
                        };
                        
                        ws.onclose = () => {
                            console.log('[WebSocket] è¿æ¥å·²å…³é—­');
                        };
                    });
                    
                    const audioSize = audioData.size;
                    console.log('[Edge-TTS] éŸ³é¢‘æ–‡ä»¶å·²ç”Ÿæˆï¼Œå¤§å°:', audioSize);
                    
                    if (audioSize === 0) {
                        throw new Error('ç”Ÿæˆçš„éŸ³é¢‘æ–‡ä»¶å¤§å°ä¸º 0');
                    }
                    
                    // åˆ›å»º blob URL
                    const audioUrl = URL.createObjectURL(audioData);
                    
                    // åœæ­¢è®¡æ—¶å¹¶æ˜¾ç¤ºæ€»æ—¶é—´
                    clearInterval(currentTimerInterval);
                    currentTimerInterval = null;
                    const totalTime = Math.floor((Date.now() - startTime) / 1000);
                    if (progressTimer) {
                        if (totalTime >= 60) {
                            const minutes = Math.floor(totalTime / 60);
                            const seconds = totalTime % 60;
                            progressTimer.textContent = `æ€»ç”¨æ—¶: ${minutes}åˆ†${seconds}ç§’`;
                        } else {
                            progressTimer.textContent = `æ€»ç”¨æ—¶: ${totalTime}ç§’`;
                        }
                    }
                    
                    // æ¸…ç† WebSocket å¼•ç”¨
                    currentWebSocket = null;
                    
                    // æ›´æ–°è¿›åº¦æ¡ä¸ºå®Œæˆ
                    if (progressBar && progressPercent) {
                        progressBar.style.width = '100%';
                        progressPercent.textContent = 'å®Œæˆ';
                    }
                    
                    // è‡ªåŠ¨ä¸‹è½½
                    const a = document.createElement('a');
                    a.href = audioUrl;
                    a.download = outputFileName;
                    a.click();
                    
                    // åˆ›å»ºéŸ³é¢‘æ’­æ”¾å™¨å’Œç®¡ç†åŒºåŸŸ
                    const audioPlayerDiv = document.createElement('div');
                    audioPlayerDiv.style.marginTop = '20px';
                    audioPlayerDiv.style.padding = '15px';
                    audioPlayerDiv.style.borderRadius = '8px';
                    audioPlayerDiv.style.backgroundColor = '#f0f8ff';
                    audioPlayerDiv.style.border = '1px solid #2196F3';
                    
                    audioPlayerDiv.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                            <strong style="color: #2196F3;">ğŸµ éŸ³é¢‘æ’­æ”¾å™¨</strong>
                            <audio id="audio-player-${timestamp}" controls style="flex: 1;">
                                <source src="${audioUrl}" type="audio/mpeg">
                                æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ’­æ”¾
                            </audio>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button id="play-btn-${timestamp}" 
                                    style="padding: 8px 15px; border: none; border-radius: 5px; background-color: #4CAF50; color: white; cursor: pointer;">
                                â–¶ï¸ æ’­æ”¾
                            </button>
                            <button id="pause-btn-${timestamp}" 
                                    style="padding: 8px 15px; border: none; border-radius: 5px; background-color: #FF9800; color: white; cursor: pointer;">
                                â¸ï¸ æš‚åœ
                            </button>
                            <a id="download-link-${timestamp}" href="${audioUrl}" download="${outputFileName}" 
                                    style="padding: 8px 15px; border: none; border-radius: 5px; background-color: #2196F3; color: white; text-decoration: none; cursor: pointer; display: inline-block;">
                                ğŸ“¥ ä¸‹è½½
                            </a>
                        </div>
                    `;
                    
                    // æ·»åŠ äº‹ä»¶ç›‘å¬å™¨ï¼ˆä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œé¿å… setTimeoutï¼‰
                    batchStatus.addEventListener('click', (e) => {
                        if (e.target.id === `play-btn-${timestamp}`) {
                            const audioElement = document.getElementById(`audio-player-${timestamp}`);
                            if (audioElement) audioElement.play();
                        } else if (e.target.id === `pause-btn-${timestamp}`) {
                            const audioElement = document.getElementById(`audio-player-${timestamp}`);
                            if (audioElement) audioElement.pause();
                        }
                    });
                    
                    // æ·»åŠ åˆ°çŠ¶æ€åŒºåŸŸ
                    const voiceName = batchVoiceSelect.options[batchVoiceSelect.selectedIndex]?.text || selectedVoice;
                    
                    batchStatus.innerHTML = `
                        <strong>âœ… éŸ³é¢‘æ–‡ä»¶ç”ŸæˆæˆåŠŸï¼</strong><br><br>
                        <div style="font-size: 14px; display: inline-block; text-align: left;">
                            <div>ğŸ“ æ–‡ä»¶åï¼š${outputFileName}</div>
                            <div>ğŸ“Š æ–‡ä»¶å¤§å°ï¼š${(audioSize / 1024).toFixed(2)} KB</div>
                            <div>ğŸ—£ï¸ è¯­éŸ³æ¨¡å‹ï¼š${voiceName}</div>
                            <div>âš™ï¸ éŸ³è°ƒï¼š${pitch} | è¯­é€Ÿï¼š${rate} | éŸ³é‡ï¼š${volume}</div>
                        </div>
                    `;
                    
                    // è®¾ç½® batchStatus å±…ä¸­
                    batchStatus.style.textAlign = 'center';
                    batchStatus.style.display = 'block';
                    
                    // å°†æ’­æ”¾å™¨æ’å…¥åˆ°ä¿¡æ¯å‰é¢
                    batchStatus.insertBefore(audioPlayerDiv, batchStatus.firstChild);
                    
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    batchDownloadBtn.disabled = false;
                    batchDownloadBtn.textContent = 'ğŸ“¥ ç”ŸæˆéŸ³é¢‘';
                    
                    return; // ç»“æŸæ‰§è¡Œ
                    
                } catch (error) {
                    console.error('[Edge-TTS] ç”Ÿæˆå¤±è´¥:', error);
                    batchStatus.innerHTML = `
                        <div style="text-align: left; color: #d32f2f;">
                            <strong>âŒ ç”Ÿæˆå¤±è´¥</strong><br><br>
                            é”™è¯¯ä¿¡æ¯ï¼š${error.message}<br><br>
                            <strong>å»ºè®®ï¼š</strong><br>
                            - å®‰è£… Python: å‘½ä»¤è¡Œæˆ–å®˜ç½‘ä¸‹è½½å®‰è£…<br>
                            - å¯åŠ¨æœåŠ¡å™¨ï¼ˆæ¨èï¼‰: è¿è¡Œå‘½ä»¤ <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">python edge_tts_proxy.py</code> 
                              <span onclick="downloadFile('tts_voice_proxy/edge_tts_proxy.py', 'edge_tts_proxy.py')" style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; background-color: #2196F3; border-radius: 50%; color: white; cursor: pointer; margin: 0 5px; font-size: 12px;" title="ç‚¹å‡»ä¸‹è½½">â†“</span><br>
                            - è¿è¡Œå‘½ä»¤è¡Œç”Ÿæˆï¼ˆä¸æ¨èï¼‰: <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">python text_to_speech_edge.py speech_config.json</code>
                              <span onclick="downloadFile('tts_voice_proxy/text_to_speech_edge.py', 'text_to_speech_edge.py')" style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; background-color: #2196F3; border-radius: 50%; color: white; cursor: pointer; margin: 0 5px; font-size: 12px;" title="ç‚¹å‡»ä¸‹è½½">â†“</span><br>
                            - æ‰‹æœºç«¯ä½¿ç”¨ï¼ˆéœ€è¦ Termuxï¼‰: <a href="https://www.123865.com/s/yS8UVv-82Red?pwd=6666#" target="_blank" style="color: #FF9800; text-decoration: none;">ä¸‹è½½ Termux</a>
                              <a href="https://www.123865.com/s/yS8UVv-82Red?pwd=6666#" target="_blank" style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; background-color: #2196F3; border-radius: 50%; color: white; text-decoration: none; cursor: pointer; margin: 0 5px; font-size: 12px;" title="ç‚¹å‡»ä¸‹è½½">â†“</a>ï¼Œå®‰è£…åè¿è¡Œ: <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">python edge_tts_proxy.py</code>
                              <span onclick="downloadFile('tts_voice_proxy/edge_tts_proxy.py', 'edge_tts_proxy.py')" style="display: inline-flex; align-items: center; justify-content: center; width: 20px; height: 20px; background-color: #2196F3; border-radius: 50%; color: white; cursor: pointer; margin: 0 5px; font-size: 12px;" title="ç‚¹å‡»ä¸‹è½½">â†“</span><br>
                            - åœæ­¢æœåŠ¡å™¨: æŒ‰ <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">Ctrl + C</code> æˆ–è¿è¡Œå‘½ä»¤ <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">netstat -ano | findstr :9191</code> ç„¶å <code style="background-color: #2D2D2D; color: #A5D6A7; padding: 2px 6px; border-radius: 3px; font-family: Consolas, Monaco;">taskkill /F /PID <è¿›ç¨‹ID></code>
                        </div>
                    `;
                }
                
                batchDownloadBtn.disabled = false;
                batchDownloadBtn.textContent = 'ğŸ“¥ ç”ŸæˆéŸ³é¢‘';
            });
        })();

        // ==================== æ‹¼éŸ³è½¬æ¢åŠŸèƒ½ï¼ˆä¸ä¾èµ–è¯­éŸ³åˆæˆï¼‰ ====================
        // æ‹¼éŸ³è½¬æ¢ç›¸å…³çš„å˜é‡å’Œåˆå§‹åŒ–
        const hanziInput = document.getElementById('hanziInput');
        const fileInput = document.getElementById('file-input');
        const undoBtn = document.getElementById('undo-btn');
        const redoBtn = document.getElementById('redo-btn');
        const status = document.getElementById('status');
        
        // æ’¤é”€å’Œåæ’¤é”€åŠŸèƒ½ç›¸å…³å˜é‡
        let currentContent = '';
        let undoStack = [];
        let redoStack = [];
        
        //Promiseå¼‚æ­¥æ‰§è¡Œï¼ŒåŠ è½½pinyinproåº“ï¼ˆç§»åˆ°å¤–é¢ï¼Œä¸ä¾èµ–è¯­éŸ³åˆæˆï¼‰
        function loadPinyinPro() {
            return new Promise((resolve, reject) => {
                if (window.pinyinPro) {
                    resolve();
                    return;
                }

                const CDN_TIMEOUT = 3000;
                let completed = false;
                const cdnScript = document.createElement('script');
                
                const timer = setTimeout(() => {
                    if (completed) return;
                    console.log('CDNåŠ è½½è¶…æ—¶ï¼Œåˆ‡æ¢åˆ°æœ¬åœ°');
                    loadLocal();
                }, CDN_TIMEOUT);
                
                function cleanup() {
                    clearTimeout(timer);
                    if (cdnScript.parentNode) {
                        cdnScript.parentNode.removeChild(cdnScript);
                    }
                }
                
                function loadLocal() {
                    if (completed) return;
                    completed = true;
                    cleanup();
                    
                    const localScript = document.createElement('script');
                    localScript.src = './CDN/pinyinpro.js';
                    localScript.onload = () => {
                        console.log('æœ¬åœ°æ–‡ä»¶åŠ è½½æˆåŠŸ');
                        resolve();
                    };
                    localScript.onerror = () => {
                        console.error('æœ¬åœ°æ–‡ä»¶åŠ è½½å¤±è´¥');
                        reject(new Error('æ— æ³•åŠ è½½ pinyin-pro åº“'));
                    };
                    document.head.appendChild(localScript);
                }
                
                cdnScript.src = 'https://cdn.jsdelivr.net/npm/pinyin-pro@3.26.0/dist/index.js';
                cdnScript.async = false;
                
                cdnScript.onload = () => {
                    if (completed) return;
                    completed = true;
                    cleanup();
                    console.log('CDNåŠ è½½æˆåŠŸ');
                    resolve();
                };
                
                cdnScript.onerror = () => {
                    if (completed) return;
                    console.log('CDNåŠ è½½å¤±è´¥ï¼Œåˆ‡æ¢åˆ°æœ¬åœ°');
                    loadLocal();
                };
                
                document.head.appendChild(cdnScript);
            });
        }
        
        // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒè¯­éŸ³åˆæˆ
        if ('speechSynthesis' in window) {
            const synth = window.speechSynthesis;
            const voiceSelect = document.getElementById('voice-select');
            const pitchRange = document.getElementById('pitch-range');
            const rateRange = document.getElementById('rate-range');
            const volumeRange = document.getElementById('volume-range');
            const pitchValue = document.getElementById('pitch-value');
            const rateValue = document.getElementById('rate-value');
            const volumeValue = document.getElementById('volume-value');
            const speakBtn = document.getElementById('speak-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const stopBtn = document.getElementById('stop-btn');
            
            let isPaused = false;
            let voices = [];
            
            // åˆå§‹åŒ–è¯­éŸ³é€‰æ‹©
            function initVoiceSelect() {
                voiceSelect.innerHTML = '';
                const loadingOption = document.createElement('option');
                loadingOption.value = -1;
                loadingOption.textContent = 'æ­£åœ¨åŠ è½½è¯­éŸ³æ¨¡å‹...';
                voiceSelect.appendChild(loadingOption);
                
                // åˆå§‹åŒ–è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†
                const selectOptions = document.getElementById('select-options');
                selectOptions.innerHTML = '';
                const loadingDiv = document.createElement('div');
                loadingDiv.className = 'select-option';
                loadingDiv.setAttribute('data-value', -1);
                loadingDiv.textContent = 'æ­£åœ¨åŠ è½½è¯­éŸ³æ¨¡å‹...';
                selectOptions.appendChild(loadingDiv);
            }
            
            // å¼‚æ­¥åŠ è½½å¯ç”¨è¯­éŸ³
            function loadVoices() {
                // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿ä¸é˜»å¡UI
                requestAnimationFrame(() => {
                    voices = synth.getVoices();
                    
                    if (voices.length > 0) {
                        voiceSelect.innerHTML = '';
                        
                        voices.forEach((voice, index) => {
                            const option = document.createElement('option');
                            option.value = index;
                            option.textContent = `${voice.name} (${voice.lang})`;
                            if (voice.default) {
                                option.textContent += ' -- é»˜è®¤';
                            }
                            if (voice.lang.includes('zh')) {
                                option.textContent += ' â˜…ä¸­æ–‡';
                            }
                            voiceSelect.appendChild(option);
                        });
                        
                        // æ›´æ–°è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†
                        updateCustomSelect();
                        
                        // å°è¯•é€‰æ‹©ä¸­æ–‡è¯­éŸ³
                        let chineseVoiceFound = false;
                        for (let i = 0; i < voices.length; i++) {
                            if (voices[i].lang.includes('zh')) {
                                voiceSelect.value = i;
                                chineseVoiceFound = true;
                                break;
                            }
                        }
                        
                        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä¸­æ–‡è¯­éŸ³ï¼Œé€‰æ‹©é»˜è®¤è¯­éŸ³
                        if (!chineseVoiceFound) {
                            for (let i = 0; i < voices.length; i++) {
                                if (voices[i].default) {
                                    voiceSelect.value = i;
                                    break;
                                }
                            }
                        }
                        
                        // æ›´æ–°è‡ªå®šä¹‰é€‰æ‹©æ˜¾ç¤º
                        updateSelectedVoiceDisplay();
                    } else {
                        // å¦‚æœä»ç„¶æ²¡æœ‰è¯­éŸ³ï¼Œæ˜¾ç¤ºé»˜è®¤æ¨¡å‹
                        voiceSelect.innerHTML = '';
                        const option = document.createElement('option');
                        option.value = -1;
                        option.textContent = 'é»˜è®¤æ¨¡å‹';
                        voiceSelect.appendChild(option);
                        
                        // æ›´æ–°è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†
                        updateCustomSelect();
                    }
                });
            }
            
            // æ›´æ–°è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†
            function updateCustomSelect() {
                const selectOptions = document.getElementById('select-options');
                selectOptions.innerHTML = '';
                
                voices.forEach((voice, index) => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'select-option';
                    optionDiv.setAttribute('data-value', index);
                    
                    let displayText = `${voice.name} (${voice.lang})`;
                    if (voice.default) {
                        displayText += ' -- é»˜è®¤';
                    }
                    if (voice.lang.includes('zh')) {
                        displayText += ' â˜…ä¸­æ–‡';
                    }
                    
                    optionDiv.textContent = displayText;
                    selectOptions.appendChild(optionDiv);
                });
            }
            
            // æ›´æ–°é€‰ä¸­çš„è¯­éŸ³æ˜¾ç¤º
            function updateSelectedVoiceDisplay() {
                const selectedVoice = document.getElementById('selected-voice');
                const selectedIndex = voiceSelect.value;
                
                if (selectedIndex >= 0 && selectedIndex < voices.length) {
                    const voice = voices[selectedIndex];
                    let displayText = `${voice.name} (${voice.lang})`;
                    if (voice.default) {
                        displayText += ' -- é»˜è®¤';
                    }
                    if (voice.lang.includes('zh')) {
                        displayText += ' â˜…ä¸­æ–‡';
                    }
                    selectedVoice.textContent = displayText;
                } else {
                    selectedVoice.textContent = 'è¯·é€‰æ‹©è¯­éŸ³æ¨¡å‹';
                }
                
                // æ›´æ–°é€‰ä¸­çŠ¶æ€
                const options = document.querySelectorAll('.select-option');
                options.forEach(option => {
                    option.classList.remove('selected');
                    if (option.getAttribute('data-value') == selectedIndex) {
                        option.classList.add('selected');
                    }
                });
            }
            
            // æ’¤é”€æ“ä½œ
            function undo() {
                if (undoStack.length === 0) {
                    showToast('æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ', 'error');
                    return;
                }
                
                // å°†å½“å‰å†…å®¹æ·»åŠ åˆ°é‡åšæ ˆ
                redoStack.push(currentContent);
                
                // ä»æ’¤é”€æ ˆä¸­å–å‡ºä¸Šä¸€ä¸ªå†…å®¹
                currentContent = undoStack.pop();
                
                // æ›´æ–°æ˜¾ç¤º
                updateDisplay();
                
                showToast('å·²æ’¤é”€', 'success');
            }
            
            // åæ’¤é”€æ“ä½œ
            function redo() {
                if (redoStack.length === 0) {
                    showToast('æ²¡æœ‰å¯é‡åšçš„æ“ä½œ', 'error');
                    return;
                }
                
                // å°†å½“å‰å†…å®¹æ·»åŠ åˆ°æ’¤é”€æ ˆ
                undoStack.push(currentContent);
                
                // ä»é‡åšæ ˆä¸­å–å‡ºä¸‹ä¸€ä¸ªå†…å®¹
                currentContent = redoStack.pop();
                
                // æ›´æ–°æ˜¾ç¤º
                updateDisplay();
                
                showToast('å·²é‡åš', 'success');
            }
            
            // æ›´æ–°æ˜¾ç¤º
            function updateDisplay() {
                if (currentContent) {
                    hanziInput.value = currentContent;
                } else {
                    hanziInput.value = '';
                }
                
                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                updateButtonStates();
                
                // æ›´æ–°æ‹¼éŸ³è½¬æ¢
                if (typeof convertHanzi === 'function') {
                    convertHanzi();
                }
            }
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            function updateButtonStates() {
                // æ ¹æ®æ ˆçš„çŠ¶æ€å¯ç”¨/ç¦ç”¨æŒ‰é’®
                undoBtn.disabled = undoStack.length === 0;
                redoBtn.disabled = redoStack.length === 0;
            }
            
            // æ˜¾ç¤ºToastæç¤º
            function showToast(message, type) {
                const toast = document.getElementById('toast');
                
                // æ ¹æ®ç±»å‹æ·»åŠ å›¾æ ‡
                let icon = '';
                switch(type) {
                    case 'success':
                        icon = 'ğŸŒŸ ';
                        break;
                    case 'error':
                        icon = 'âš ï¸ ';
                        break;
                    default:
                        icon = 'ğŸ’¡ ';
                }
                
                toast.innerHTML = `<span style="display: flex; align-items: center; gap: 6px;">${icon}${message}</span>`;
                toast.className = `toast ${type}`;
                toast.classList.add('show');
                
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 3000);
            }
            
            // è®¾ç½®é¢„è®¾æ–‡æœ¬
            function setText(text) {
                // ä¿å­˜å½“å‰å†…å®¹åˆ°æ’¤é”€æ ˆ
                if (currentContent) {
                    undoStack.push(currentContent);
                }
                
                // è®¾ç½®æ–°å†…å®¹
                currentContent = text;
                
                // æ¸…ç©ºé‡åšæ ˆ
                redoStack = [];
                
                // æ›´æ–°æ˜¾ç¤º
                updateDisplay();
                
                // æ›´æ–°åˆ†æ®µæ•°é‡
                updateSegmentCount();
            }
            
            // å…¨å±€å˜é‡å­˜å‚¨å½“å‰æœ—è¯»å¯¹è±¡
            let currentUtterance = null;
            let currentText = '';
            let currentVoiceIndex = 0;
            let isSpeaking = false;
            let currentPosition = 0;
            let textSegments = [];
            let currentSegmentIndex = 0;
            let pendingStrategySwitch = false; // æ ‡è®°æ˜¯å¦éœ€è¦åœ¨å½“å‰æ®µè½è¯»å®Œååˆ‡æ¢ç­–ç•¥
            
            // è·å–å½“å‰é€‰æ‹©çš„åˆ†æ®µç­–ç•¥
            function getCurrentSegmentationStrategy() {
                const selectedRadio = document.querySelector('input[name="segmentation"]:checked');
                return selectedRadio ? selectedRadio.value : 'weight';
            }
            
            // è·å–åˆ†æ®µç­–ç•¥çš„ä¸­æ–‡åç§°
            function getSegmentationStrategyName(strategy) {
                const strategyNames = {
                    'weight': 'æ™ºèƒ½æƒé‡è¯„åˆ†',
                    'prosody': 'è¯­éŸ³éŸµå¾‹åˆ†å‰²',
                    'adaptive': 'æ··åˆè‡ªé€‚åº”åˆ†æ®µ',
                    'context': 'å®æ—¶æ„ŸçŸ¥åˆ†æ®µ',
                    'semantic': 'è¯­ä¹‰æ™ºèƒ½åˆ†æ®µ',
                    'rhythm': 'èŠ‚å¥æ¨¡å¼åˆ†æ®µ'
                };
                return strategyNames[strategy] || 'æœªçŸ¥ç­–ç•¥';
            }
            
            // æ›´æ–°çŠ¶æ€æ æ˜¾ç¤ºåˆ†æ®µæ•°é‡
            function updateSegmentCount() {
                const text = hanziInput.value.trim();
                if (!text) {
                    status.textContent = 'å‡†å¤‡å°±ç»ª';
                    return;
                }
                
                const segments = splitTextIntoSegments(text);
                const strategy = getCurrentSegmentationStrategy();
                const strategyName = getSegmentationStrategyName(strategy);
                status.textContent = `å‡†å¤‡å°±ç»ª | ${strategyName} | å…±${segments.length}æ®µ`;
            }
            
            // å°†æ–‡æœ¬åˆ†å‰²æˆå°æ®µï¼Œç”¨äºå®æ—¶è°ƒæ•´å‚æ•°
            function splitTextIntoSegments(text) {
                const strategy = getCurrentSegmentationStrategy();
                
                switch(strategy) {
                    case 'prosody':
                        return prosodyBasedSegmentation(text);
                    case 'adaptive':
                        return adaptiveSegmentation(text);
                    case 'context':
                        return contextAwareSegmentation(text);
                    case 'semantic':
                        return semanticSegmentation(text);
                    case 'rhythm':
                        return rhythmBasedSegmentation(text);
                    case 'weight':
                    default:
                        return weightBasedSegmentation(text);
                }
            }
            
            // 1. æ™ºèƒ½æƒé‡è¯„åˆ†ç³»ç»Ÿï¼ˆæ¨èï¼‰
            function weightBasedSegmentation(text) {
                const segments = [];
                let currentSegment = '';
                let contextScore = 0;
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    const nextChar = text[i + 1];
                    const prevChar = text[i - 1];
                    currentSegment += char;
                    
                    // è®¡ç®—å½“å‰åˆ†å‰²ç‚¹çš„ç»¼åˆæƒé‡
                    const splitScore = calculateAdvancedSplitScore(char, currentSegment, i, text, prevChar, nextChar, contextScore);
                    
                    // åŠ¨æ€é˜ˆå€¼ï¼šæ ¹æ®æ–‡æœ¬å¤æ‚åº¦å’Œä¸Šä¸‹æ–‡è°ƒæ•´
                    const threshold = getAdvancedThreshold(currentSegment, segments, text);
                    
                    // å¦‚æœæƒé‡è¶…è¿‡é˜ˆå€¼ï¼Œè¿›è¡Œåˆ†å‰²
                    if (splitScore >= threshold) {
                        segments.push(currentSegment);
                        currentSegment = '';
                        contextScore = 0;
                    } else {
                        // ç´¯ç§¯ä¸Šä¸‹æ–‡åˆ†æ•°
                        contextScore = Math.max(0, contextScore - 0.5);
                    }
                }
                
                // æ·»åŠ å‰©ä½™å†…å®¹
                if (currentSegment) {
                    segments.push(currentSegment);
                }
                
                // æ™ºèƒ½åˆå¹¶å’Œä¼˜åŒ–
                return optimizeSegments(segments);
            }
            
            // é«˜çº§åˆ†å‰²åˆ†æ•°è®¡ç®—
            function calculateAdvancedSplitScore(char, segment, position, fullText, prevChar, nextChar, contextScore) {
                let score = 0;
                
                // 1. æ ‡ç‚¹ç¬¦å·æƒé‡ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
                if (/[ã€‚ï¼ï¼Ÿ]/.test(char)) {
                    score += 20; // å¥æœ«æ ‡ç‚¹æœ€é«˜åˆ†
                } else if (/[ï¼Œã€ï¼›ï¼š]/.test(char)) {
                    score += 12; // åˆ†å¥æ ‡ç‚¹é«˜åˆ†
                } else if (/[â€¦â€”]/.test(char)) {
                    score += 15; // ç‰¹æ®Šæ ‡ç‚¹
                }
                
                // 2. è¯­æ³•ç»“æ„æƒé‡
                if (/[çš„å¾—åœ°]/.test(char) && segment.length >= 6) {
                    score += 6; // åŠ©è¯ååˆ†å‰²
                } else if (/[äº†ç€è¿‡]/.test(char) && isChineseChar(prevChar)) {
                    score += 5; // åŠ¨æ€åŠ©è¯
                } else if (/[å’Œä¸åŠæˆ–]/.test(char) && segment.length >= 8) {
                    score += 7; // è¿è¯ååˆ†å‰²
                }
                
                // 3. è¯­ä¹‰åœé¡¿æƒé‡
                if (/[å› ä¸ºæ‰€ä»¥å¦‚æœé‚£ä¹ˆè™½ç„¶ç„¶è€Œä½†æ˜¯ä¸è¿‡å¯æ˜¯]/.test(char)) {
                    score += 8; // é€»è¾‘è¿æ¥è¯
                    if (!isPartOfComplexExpression(char, nextChar)) {
                        score += 3; // éå¤åˆè¡¨è¾¾åŠ åˆ†
                    }
                }
                
                // 4. é•¿åº¦æ§åˆ¶æƒé‡
                if (segment.length > 25) {
                    score += 10; // å¼ºåˆ¶åˆ†å‰²è¿‡é•¿æ®µè½
                } else if (segment.length > 18) {
                    score += 5; // å»ºè®®åˆ†å‰²
                } else if (segment.length > 12) {
                    score += 2; // å¯é€‰åˆ†å‰²
                }
                
                // 5. ä¸Šä¸‹æ–‡æ„ŸçŸ¥æƒé‡
                // é¿å…åœ¨ç‰¹å®šæ¨¡å¼ä¸­åˆ†å‰²
                if (/[a-zA-Z0-9]/.test(nextChar)) {
                    score -= 15; // é¿å…åœ¨è‹±æ–‡/æ•°å­—ä¸­åˆ†å‰²
                }
                if (/[æ—¶åˆ†ç§’]/.test(char) && /[0-9]/.test(nextChar)) {
                    score -= 12; // é¿å…åœ¨æ—¶é—´è¡¨è¾¾å¼ä¸­åˆ†å‰²
                }
                if (/[ç¬¬]/.test(prevChar) && /[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒä¸‡]/.test(char)) {
                    score -= 10; // é¿å…åœ¨åºæ•°è¯ä¸­åˆ†å‰²
                }
                
                // 6. éŸµå¾‹æƒé‡
                if (position > 0 && /[ä»„å¹³]/.test(getCharTone(char))) {
                    const prevTone = getCharTone(prevChar);
                    if (prevTone && getCharTone(char) !== prevTone) {
                        score += 3; // å£°è°ƒå˜åŒ–ç‚¹
                    }
                }
                
                return Math.max(0, score + contextScore);
            }
            
            // é«˜çº§åŠ¨æ€é˜ˆå€¼è®¡ç®—
            function getAdvancedThreshold(segment, existingSegments, fullText) {
                let threshold = 8; // åŸºç¡€é˜ˆå€¼
                
                // æ ¹æ®æ–‡æœ¬å¤æ‚åº¦è°ƒæ•´
                const complexity = calculateTextComplexity(fullText);
                threshold += complexity * 2;
                
                // æ ¹æ®æ®µè½é•¿åº¦è°ƒæ•´
                if (segment.length < 4) {
                    threshold += 5; // é¿å…è¿‡çŸ­æ®µè½
                } else if (segment.length > 22) {
                    threshold -= 3; // é¼“åŠ±åˆ†å‰²è¿‡é•¿æ®µè½
                }
                
                // æ ¹æ®å·²æœ‰æ®µè½æ•°é‡è°ƒæ•´
                if (existingSegments.length > 15) {
                    threshold += 2; // æ®µè½è¿‡å¤šæ—¶æé«˜é˜ˆå€¼
                }
                
                // æ ¹æ®æ ‡ç‚¹å¯†åº¦è°ƒæ•´
                const punctuationDensity = calculatePunctuationDensity(segment);
                if (punctuationDensity > 0.3) {
                    threshold -= 2; // æ ‡ç‚¹å¯†é›†æ—¶é™ä½é˜ˆå€¼
                }
                
                return threshold;
            }
            
            // 2. åŸºäºè¯­éŸ³éŸµå¾‹çš„åˆ†å‰²
            function prosodyBasedSegmentation(text) {
                const segments = [];
                let currentSegment = '';
                let syllableCount = 0;
                let stressPattern = 0;
                let intonationCurve = 0;
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    const nextChar = text[i + 1];
                    currentSegment += char;
                    
                    // è®¡ç®—éŸ³èŠ‚å’ŒéŸµå¾‹ç‰¹å¾
                    if (isChineseChar(char)) {
                        syllableCount++;
                        const tone = getCharTone(char);
                        if (tone) {
                            intonationCurve += getToneWeight(tone);
                        }
                        
                        // é‡éŸ³æ¨¡å¼æ£€æµ‹ï¼ˆ2-4éŸ³èŠ‚ä¸€ä¸ªé‡éŸ³ï¼‰
                        if (syllableCount % 3 === 0 || isStressedWord(char, nextChar)) {
                            stressPattern++;
                        }
                    }
                    
                    // éŸµå¾‹åˆ†å‰²æ¡ä»¶
                    if (shouldSplitAtProsodyBoundary(char, syllableCount, stressPattern, intonationCurve, i, text, nextChar)) {
                        segments.push(currentSegment);
                        currentSegment = '';
                        syllableCount = 0;
                        stressPattern = 0;
                        intonationCurve = 0;
                    }
                }
                
                if (currentSegment) {
                    segments.push(currentSegment);
                }
                
                return balanceProsodySegments(segments);
            }
            
            // é«˜çº§éŸµå¾‹è¾¹ç•Œåˆ¤æ–­
            function shouldSplitAtProsodyBoundary(char, syllableCount, stressPattern, intonationCurve, position, fullText, nextChar) {
                // å¥æœ«æ ‡ç‚¹å¼ºåˆ¶åˆ†å‰²
                if (/[ã€‚ï¼ï¼Ÿ]/.test(char)) return true;
                
                // éŸ³èŠ‚æ§åˆ¶ï¼š4-8ä¸ªéŸ³èŠ‚ä¸€ä¸ªæ®µè½
                if (syllableCount >= 6 && /[ï¼Œã€ï¼›ï¼š]/.test(char)) return true;
                if (syllableCount >= 8) return true;
                
                // é‡éŸ³æ¨¡å¼ï¼šé‡éŸ³è¯ååˆ†å‰²
                if (stressPattern >= 2 && /[çš„äº†åœ¨æ˜¯æœ‰]/.test(char)) return true;
                
                // è¯­è°ƒæ›²çº¿ï¼šåœ¨è¯­è°ƒè½¬æŠ˜ç‚¹åˆ†å‰²
                if (Math.abs(intonationCurve) > 3 && /[ä½†è€Œå› ä¸ºæ‰€ä»¥å¦‚æœé‚£ä¹ˆ]/.test(char)) return true;
                
                // èŠ‚å¥æ¨¡å¼ï¼šåœ¨èŠ‚å¥åœé¡¿ç‚¹åˆ†å‰²
                if (syllableCount >= 4 && isRhythmBoundary(char, nextChar)) return true;
                
                return false;
            }
            
            // 3. æ··åˆè‡ªé€‚åº”åˆ†æ®µ
            function adaptiveSegmentation(text) {
                // æ·±åº¦åˆ†ææ–‡æœ¬ç‰¹å¾
                const textFeatures = analyzeTextFeatures(text);
                const strategy = generateAdaptiveStrategy(textFeatures);
                
                // å¤šå±‚åˆ†å‰²
                const primarySegments = performPrimarySegmentation(text, strategy);
                const optimizedSegments = optimizeSegmentation(primarySegments, textFeatures);
                
                return optimizedSegments;
            }
            
            // æ·±åº¦æ–‡æœ¬ç‰¹å¾åˆ†æ
            function analyzeTextFeatures(text) {
                // ç¡®ä¿æ–‡æœ¬ä¸ä¸ºç©º
                if (!text || text.trim().length === 0) {
                    return {
                        type: 'general',
                        complexity: 0.5,
                        avgSentenceLength: 10,
                        punctuationPattern: { density: 0.1 },
                        semanticDensity: 0.5,
                        rhythmPattern: { pattern: 'regular', intensity: 0.5, tempo: 1.0 },
                        formalLevel: 'medium'
                    };
                }
                
                return {
                    type: detectTextType(text),
                    complexity: calculateTextComplexity(text),
                    avgSentenceLength: calculateAvgSentenceLength(text),
                    punctuationPattern: analyzePunctuationPattern(text),
                    semanticDensity: calculateSemanticDensity(text),
                    rhythmPattern: analyzeRhythmPattern(text),
                    formalLevel: detectFormalLevel(text)
                };
            }
            
            // ç”Ÿæˆè‡ªé€‚åº”ç­–ç•¥
            function generateAdaptiveStrategy(features) {
                const strategy = {
                    baseSegmentLength: 15,
                    maxLength: 25,
                    minLength: 6,
                    splitPoints: /[ï¼Œã€‚ï¼ï¼Ÿ]/g,
                    optimizationRules: []
                };
                
                // æ ¹æ®æ–‡æœ¬ç±»å‹è°ƒæ•´
                switch(features.type) {
                    case 'conversation':
                        strategy.baseSegmentLength = 10;
                        strategy.maxLength = 18;
                        strategy.minLength = 5;
                        strategy.splitPoints = /[ï¼Œã€‚ï¼ï¼Ÿ]/g;
                        break;
                    case 'formal':
                        strategy.baseSegmentLength = 18;
                        strategy.maxLength = 30;
                        strategy.minLength = 8;
                        strategy.splitPoints = /[ã€‚ï¼ï¼Ÿï¼›]/g;
                        break;
                    case 'poetry':
                        strategy.baseSegmentLength = 7;
                        strategy.maxLength = 12;
                        strategy.minLength = 4;
                        strategy.splitPoints = /[ï¼Œã€‚ï¼ï¼Ÿ]/g;
                        break;
                    case 'technical':
                        strategy.baseSegmentLength = 20;
                        strategy.maxLength = 35;
                        strategy.minLength = 10;
                        strategy.splitPoints = /[ã€‚ï¼ï¼Ÿï¼›ï¼š]/g;
                        break;
                    default:
                        strategy.baseSegmentLength = 15;
                        strategy.maxLength = 25;
                        strategy.minLength = 6;
                        strategy.splitPoints = /[ï¼Œã€‚ï¼ï¼Ÿ]/g;
                }
                
                // æ ¹æ®å¤æ‚åº¦è°ƒæ•´
                if (features.complexity > 0.7) {
                    strategy.maxLength = Math.floor(strategy.maxLength * 1.2);
                    strategy.minLength = Math.floor(strategy.minLength * 0.8);
                }
                
                // ç¡®ä¿å‚æ•°åœ¨åˆç†èŒƒå›´å†…
                strategy.baseSegmentLength = Math.max(5, Math.min(30, strategy.baseSegmentLength));
                strategy.maxLength = Math.max(10, Math.min(50, strategy.maxLength));
                strategy.minLength = Math.max(3, Math.min(15, strategy.minLength));
                
                return strategy;
            }
            
            // 4. å®æ—¶æ„ŸçŸ¥åˆ†æ®µ
            function contextAwareSegmentation(text) {
                // è·å–å½“å‰è¯­éŸ³å‚æ•°
                const speechRate = parseFloat(rateRange.value);
                const pitch = parseFloat(pitchRange.value);
                const volume = parseFloat(volumeRange.value);
                
                // æ ¹æ®è¯­éŸ³å‚æ•°è®¡ç®—æœ€ä½³åˆ†æ®µç­–ç•¥
                const segmentParams = calculateOptimalSegmentParams(speechRate, pitch, volume);
                
                // æ‰§è¡Œä¸Šä¸‹æ–‡æ„ŸçŸ¥åˆ†æ®µ
                return performContextAwareSegmentation(text, segmentParams);
            }
            
            // è®¡ç®—æœ€ä½³åˆ†æ®µå‚æ•°
            function calculateOptimalSegmentParams(speechRate, pitch, volume) {
                return {
                    targetLength: calculateSegmentLength(speechRate),
                    splitSensitivity: calculateSplitSensitivity(pitch),
                    mergeThreshold: calculateMergeThreshold(volume),
                    realTimeFactor: calculateRealTimeFactor(speechRate, pitch, volume)
                };
            }
            
            // æ‰§è¡Œä¸Šä¸‹æ–‡æ„ŸçŸ¥åˆ†æ®µ
            function performContextAwareSegmentation(text, params) {
                const segments = [];
                let currentSegment = '';
                let contextScore = 0;
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    const nextChar = text[i + 1];
                    currentSegment += char;
                    
                    // æ›´æ–°ä¸Šä¸‹æ–‡åˆ†æ•°
                    contextScore = updateContextScore(char, contextScore, params);
                    
                    // æ£€æŸ¥æ˜¯å¦åº”è¯¥åˆ†å‰²
                    if (shouldSplitInContext(currentSegment, char, nextChar, contextScore, params)) {
                        segments.push(currentSegment);
                        currentSegment = '';
                        contextScore = 0;
                    }
                }
                
                if (currentSegment) {
                    segments.push(currentSegment);
                }
                
                return segments;
            }
            
            // 5. åŸºäºè¯­ä¹‰çš„æ™ºèƒ½åˆ†æ®µ
            function semanticSegmentation(text) {
                // è¯­ä¹‰åˆ†æ
                const semanticUnits = performSemanticAnalysis(text);
                const semanticGraph = buildSemanticGraph(semanticUnits);
                
                // åŸºäºè¯­ä¹‰å›¾è¿›è¡Œåˆ†æ®µ
                const segments = segmentBySemanticBoundaries(semanticGraph);
                
                return optimizeSemanticSegments(segments);
            }
            
            // æ‰§è¡Œè¯­ä¹‰åˆ†æ
            function performSemanticAnalysis(text) {
                const units = [];
                let currentUnit = {
                    text: '',
                    type: 'unknown',
                    importance: 0,
                    connections: []
                };
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    currentUnit.text += char;
                    
                    // åˆ†æè¯­ä¹‰ç±»å‹
                    currentUnit.type = classifySemanticUnit(currentUnit.text);
                    currentUnit.importance = calculateSemanticImportance(currentUnit.text);
                    
                    // åœ¨è¯­ä¹‰è¾¹ç•Œåˆ†å‰²
                    if (isSemanticBoundary(char, currentUnit.text)) {
                        units.push({...currentUnit});
                        currentUnit = {
                            text: '',
                            type: 'unknown',
                            importance: 0,
                            connections: []
                        };
                    }
                }
                
                if (currentUnit.text) {
                    units.push(currentUnit);
                }
                
                return units;
            }
            
            // 6. åŸºäºèŠ‚å¥çš„åˆ†æ®µï¼ˆæ–°å¢ï¼‰
            function rhythmBasedSegmentation(text) {
                const rhythmPattern = analyzeRhythmPattern(text);
                const segments = [];
                let currentSegment = '';
                let rhythmScore = 0;
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    currentSegment += char;
                    
                    // æ›´æ–°èŠ‚å¥åˆ†æ•°
                    rhythmScore = updateRhythmScore(char, rhythmScore, rhythmPattern);
                    
                    // åœ¨èŠ‚å¥åœé¡¿ç‚¹åˆ†å‰²
                    if (shouldSplitAtRhythmPoint(char, rhythmScore, currentSegment)) {
                        segments.push(currentSegment);
                        currentSegment = '';
                        rhythmScore = 0;
                    }
                }
                
                if (currentSegment) {
                    segments.push(currentSegment);
                }
                
                return balanceRhythmSegments(segments, rhythmPattern);
            }
            
            // è¾…åŠ©å‡½æ•°
            function optimizeSegments(segments) {
                // æ™ºèƒ½åˆå¹¶è¿‡çŸ­æ®µè½
                const optimized = [];
                let tempSegment = '';
                
                for (const segment of segments) {
                    if (tempSegment.length + segment.length < 8 && !/[ã€‚ï¼ï¼Ÿ]$/.test(tempSegment)) {
                        tempSegment += segment;
                    } else {
                        if (tempSegment) optimized.push(tempSegment);
                        tempSegment = segment;
                    }
                }
                
                if (tempSegment) optimized.push(tempSegment);
                
                return optimized;
            }
            
            function calculateTextComplexity(text) {
                // è®¡ç®—æ–‡æœ¬å¤æ‚åº¦çš„ç®€åŒ–ç‰ˆæœ¬
                const uniqueChars = new Set(text).size;
                const totalChars = text.length;
                const avgWordLength = text.split(/\s+/).reduce((sum, word) => sum + word.length, 0) / text.split(/\s+/).length;
                
                return Math.min(1, (uniqueChars / totalChars + avgWordLength / 10) / 2);
            }
            
            function getCharTone(char) {
                // ç®€åŒ–çš„å£°è°ƒæ£€æµ‹
                const toneMap = {
                    'Ä': 'å¹³', 'Ã¡': 'å¹³', 'Ç': 'å¹³', 'Ã ': 'å¹³',
                    'Ä“': 'å¹³', 'Ã©': 'å¹³', 'Ä›': 'å¹³', 'Ã¨': 'å¹³',
                    'Ä«': 'å¹³', 'Ã­': 'å¹³', 'Ç': 'å¹³', 'Ã¬': 'å¹³',
                    'Å': 'å¹³', 'Ã³': 'å¹³', 'Ç’': 'å¹³', 'Ã²': 'å¹³',
                    'Å«': 'å¹³', 'Ãº': 'å¹³', 'Ç”': 'å¹³', 'Ã¹': 'å¹³'
                };
                
                return toneMap[char] || null;
            }
            
            function getToneWeight(tone) {
                return tone === 'å¹³' ? 1 : -1;
            }
            
            function isChineseChar(char) {
                return /[\u4e00-\u9fa5]/.test(char);
            }
            
            function isPartOfComplexExpression(char, nextChar) {
                const complexPatterns = [
                    ['å› ä¸º', 'æ‰€ä»¥'],
                    ['è™½ç„¶', 'ä½†æ˜¯'],
                    ['å¦‚æœ', 'é‚£ä¹ˆ'],
                    ['ä¸ä½†', 'è€Œä¸”'],
                    ['ä¸ä»…', 'è¿˜']
                ];
                
                for (const pattern of complexPatterns) {
                    for (let i = 0; i < pattern.length - 1; i++) {
                        if (char === pattern[i][pattern[i].length - 1] && 
                            nextChar === pattern[i + 1][0]) {
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // æ›´å¤šè¾…åŠ©å‡½æ•°...
            function isStressedWord(char, nextChar) {
                return /[é‡è¦å…³é”®æ ¸å¿ƒä¸»è¦]/.test(char);
            }
            
            function isRhythmBoundary(char, nextChar) {
                return /[çš„äº†åœ¨æ˜¯æœ‰å’Œä¸åŠæˆ–]/.test(char) && !/[a-zA-Z0-9]/.test(nextChar);
            }
            
            function detectTextType(text) {
                // ç¡®ä¿æ–‡æœ¬ä¸ä¸ºç©º
                if (!text || text.trim().length === 0) {
                    return 'general';
                }
                
                const hasQuestion = /[ï¼Ÿ]/.test(text);
                const hasExclamation = /[ï¼]/.test(text);
                const technicalTerms = (text.match(/[æŠ€æœ¯ç³»ç»Ÿæ–¹æ³•ç®—æ³•æ•°æ®]/g) || []).length;
                const sentences = text.split(/[ã€‚ï¼ï¼Ÿ]/).filter(s => s.trim().length > 0);
                const avgSentenceLength = sentences.length > 0 ? 
                    sentences.reduce((sum, s) => sum + s.length, 0) / sentences.length : 10;
                
                if (technicalTerms > 3) return 'technical';
                if (hasQuestion && hasExclamation && avgSentenceLength < 15) return 'conversation';
                if (avgSentenceLength > 25) return 'formal';
                if (/[è¯—è¯æ­Œèµ‹]/.test(text)) return 'poetry';
                
                return 'general';
            }
            
            function calculatePunctuationDensity(segment) {
                const punctuationCount = (segment.match(/[ã€‚ï¼Œï¼›ï¼šï¼ï¼Ÿ]/g) || []).length;
                return punctuationCount / segment.length;
            }
            
            function calculateSegmentLength(speechRate) {
                if (speechRate < 0.5) return 8;
                if (speechRate < 1.0) return 12;
                if (speechRate < 1.5) return 16;
                return 22;
            }
            
            function calculateSplitSensitivity(pitch) {
                return 0.5 + pitch * 0.3;
            }
            
            function calculateMergeThreshold(volume) {
                return 10 - volume * 3;
            }
            
            function calculateRealTimeFactor(speechRate, pitch, volume) {
                return (speechRate + pitch + volume) / 3;
            }
            
            function updateContextScore(char, currentScore, params) {
                let newScore = currentScore;
                
                if (/[ï¼Œã€‚ï¼ï¼Ÿ]/.test(char)) {
                    newScore += params.splitSensitivity * 5;
                } else if (/[çš„äº†åœ¨æ˜¯æœ‰]/.test(char)) {
                    newScore += params.splitSensitivity * 2;
                }
                
                return Math.max(0, newScore - 0.1);
            }
            
            function shouldSplitInContext(segment, char, nextChar, contextScore, params) {
                const lengthFactor = segment.length / params.targetLength;
                const contextFactor = contextScore / 10;
                
                return (lengthFactor >= 1 || contextFactor >= 1) && 
                       /[ï¼Œã€‚ï¼ï¼Ÿï¼›ï¼šçš„äº†åœ¨æ˜¯æœ‰å’Œä¸åŠæˆ–]/.test(char) &&
                       !/[a-zA-Z0-9]/.test(nextChar);
            }
            
            function classifySemanticUnit(text) {
                if (/[å› ä¸ºæ‰€ä»¥å¦‚æœé‚£ä¹ˆ]/.test(text)) return 'logic';
                if (/[çš„å¾—åœ°]/.test(text)) return 'modifier';
                if (/[å’Œä¸åŠæˆ–]/.test(text)) return 'conjunction';
                return 'content';
            }
            
            function calculateSemanticImportance(text) {
                const importantWords = (text.match(/[é‡è¦å…³é”®æ ¸å¿ƒä¸»è¦]/g) || []).length;
                return Math.min(1, importantWords / text.length * 10);
            }
            
            function isSemanticBoundary(char, text) {
                return /[ã€‚ï¼ï¼Ÿï¼Œã€ï¼›ï¼š]/.test(char) ||
                       (/[çš„äº†åœ¨æ˜¯æœ‰å’Œä¸åŠæˆ–]/.test(char) && text.length >= 5);
            }
            
            function analyzeRhythmPattern(text) {
                // ç®€åŒ–çš„èŠ‚å¥åˆ†æ
                return {
                    pattern: 'regular',
                    intensity: 0.5,
                    tempo: 1.0
                };
            }
            
            function updateRhythmScore(char, currentScore, pattern) {
                return currentScore + pattern.intensity;
            }
            
            function shouldSplitAtRhythmPoint(char, rhythmScore, segment) {
                return rhythmScore > 3 && /[ï¼Œã€‚ï¼ï¼Ÿ]/.test(char) && segment.length >= 8;
            }
            
            function balanceProsodySegments(segments) {
                return segments;
            }
            
            function balanceRhythmSegments(segments, pattern) {
                return segments;
            }
            
            function optimizeSegmentation(segments, strategy) {
                // æ™ºèƒ½ä¼˜åŒ–åˆ†æ®µç»“æœ
                const optimized = [];
                let tempSegment = '';
                
                for (let i = 0; i < segments.length; i++) {
                    const segment = segments[i];
                    
                    // å¦‚æœå½“å‰æ®µè½å¤ªçŸ­ä¸”ä¸æ˜¯å¥æœ«ï¼Œå°è¯•ä¸ä¸‹ä¸€æ®µåˆå¹¶
                    if (segment.length < strategy.minLength && 
                        i < segments.length - 1 && 
                        !/[ã€‚ï¼ï¼Ÿ]$/.test(segment) &&
                        tempSegment.length + segment.length < strategy.maxLength) {
                        tempSegment += segment;
                    } else {
                        // å¦‚æœæœ‰ä¸´æ—¶æ®µè½ï¼Œå…ˆæ·»åŠ 
                        if (tempSegment) {
                            optimized.push(tempSegment);
                            tempSegment = '';
                        }
                        
                        // æ£€æŸ¥å½“å‰æ®µè½æ˜¯å¦éœ€è¦è¿›ä¸€æ­¥åˆ†å‰²
                        if (segment.length > strategy.maxLength) {
                            const splitSegments = splitLongSegment(segment, strategy);
                            optimized.push(...splitSegments);
                        } else {
                            optimized.push(segment);
                        }
                    }
                }
                
                // æ·»åŠ å‰©ä½™çš„ä¸´æ—¶æ®µè½
                if (tempSegment) {
                    optimized.push(tempSegment);
                }
                
                return optimized;
            }
            
            function performPrimarySegmentation(text, strategy) {
                const segments = [];
                let currentSegment = '';
                
                // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ‰¾åˆ°æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²ç‚¹
                const splitRegex = /[ã€‚ï¼ï¼Ÿï¼Œã€ï¼›ï¼š]/g;
                let match;
                let lastIndex = 0;
                
                while ((match = splitRegex.exec(text)) !== null) {
                    const splitIndex = match.index;
                    const splitChar = match[0];
                    
                    // è·å–åˆ†å‰²ç‚¹å‰çš„æ–‡æœ¬
                    const segmentText = text.substring(lastIndex, splitIndex + 1);
                    
                    // æ ¹æ®ç­–ç•¥å†³å®šæ˜¯å¦åœ¨æ­¤å¤„åˆ†æ®µ
                    if (shouldSplitAtPoint(segmentText, splitChar, strategy)) {
                        if (currentSegment) {
                            currentSegment += segmentText;
                            // å¦‚æœå½“å‰æ®µè½è¾¾åˆ°åˆé€‚é•¿åº¦ï¼Œæ·»åŠ åˆ°ç»“æœä¸­
                            if (currentSegment.length >= strategy.baseSegmentLength) {
                                segments.push(currentSegment);
                                currentSegment = '';
                            }
                        } else {
                            // å¦‚æœæ˜¯å¥æœ«æ ‡ç‚¹æˆ–æ®µè½è¶³å¤Ÿé•¿ï¼Œç›´æ¥åˆ†æ®µ
                            if (/[ã€‚ï¼ï¼Ÿ]/.test(splitChar) || segmentText.length >= strategy.baseSegmentLength) {
                                segments.push(segmentText);
                            } else {
                                currentSegment = segmentText;
                            }
                        }
                    } else {
                        // ä¸åˆ†æ®µï¼Œç»§ç»­ç´¯ç§¯
                        currentSegment += segmentText;
                    }
                    
                    lastIndex = splitIndex + 1;
                }
                
                // å¤„ç†å‰©ä½™æ–‡æœ¬
                if (lastIndex < text.length) {
                    const remainingText = text.substring(lastIndex);
                    if (currentSegment) {
                        currentSegment += remainingText;
                    } else {
                        currentSegment = remainingText;
                    }
                }
                
                // æ·»åŠ æœ€åä¸€æ®µ
                if (currentSegment) {
                    segments.push(currentSegment);
                }
                
                // å¦‚æœæ²¡æœ‰åˆ†æ®µï¼Œå°†æ•´ä¸ªæ–‡æœ¬ä½œä¸ºä¸€æ®µ
                if (segments.length === 0) {
                    segments.push(text);
                }
                
                return segments;
            }
            
            // åˆ¤æ–­æ˜¯å¦åº”è¯¥åœ¨ç‰¹å®šç‚¹åˆ†å‰²
            function shouldSplitAtPoint(segmentText, splitChar, strategy) {
                // å¥æœ«æ ‡ç‚¹æ€»æ˜¯åˆ†å‰²
                if (/[ã€‚ï¼ï¼Ÿ]/.test(splitChar)) {
                    return true;
                }
                
                // åˆ†å¥æ ‡ç‚¹æ ¹æ®é•¿åº¦å†³å®š
                if (/[ï¼Œã€ï¼›ï¼š]/.test(splitChar)) {
                    return segmentText.length >= strategy.baseSegmentLength * 0.8;
                }
                
                // å…¶ä»–æƒ…å†µæ ¹æ®æ–‡æœ¬é•¿åº¦å†³å®š
                return segmentText.length >= strategy.maxLength;
            }
            
            // åˆ†å‰²è¿‡é•¿çš„æ®µè½
            function splitLongSegment(segment, strategy) {
                const segments = [];
                let currentSegment = '';
                
                for (let i = 0; i < segment.length; i++) {
                    const char = segment[i];
                    currentSegment += char;
                    
                    // åœ¨åˆé€‚çš„åˆ†å‰²ç‚¹è¿›è¡Œåˆ†æ®µ
                    if (/[ï¼Œã€‚ï¼ï¼Ÿã€ï¼›ï¼š]/.test(char) && 
                        currentSegment.length >= strategy.baseSegmentLength) {
                        segments.push(currentSegment);
                        currentSegment = '';
                    } else if (currentSegment.length >= strategy.maxLength) {
                        // å¼ºåˆ¶åˆ†å‰²
                        segments.push(currentSegment);
                        currentSegment = '';
                    }
                }
                
                // æ·»åŠ å‰©ä½™éƒ¨åˆ†
                if (currentSegment) {
                    segments.push(currentSegment);
                }
                
                return segments.length > 0 ? segments : [segment];
            }
            
            function buildSemanticGraph(units) {
                return { units, connections: [] };
            }
            
            function segmentBySemanticBoundaries(graph) {
                return graph.units.map(unit => unit.text);
            }
            
            function optimizeSemanticSegments(segments) {
                return segments;
            }
            
            function calculateAvgSentenceLength(text) {
                // ç¡®ä¿æ–‡æœ¬ä¸ä¸ºç©º
                if (!text || text.trim().length === 0) {
                    return 10;
                }
                
                const sentences = text.split(/[ã€‚ï¼ï¼Ÿ]/).filter(s => s.trim());
                if (sentences.length === 0) {
                    return text.length; // å¦‚æœæ²¡æœ‰å¥æœ«æ ‡ç‚¹ï¼Œè¿”å›æ•´ä¸ªæ–‡æœ¬çš„é•¿åº¦
                }
                
                return sentences.reduce((sum, s) => sum + s.length, 0) / sentences.length;
            }
            
            function analyzePunctuationPattern(text) {
                return { density: calculatePunctuationDensity(text) };
            }
            
            function calculateSemanticDensity(text) {
                return 0.5; // ç®€åŒ–å®ç°
            }
            
            function detectFormalLevel(text) {
                const formalWords = (text.match(/[å› æ­¤ç„¶è€Œæ­¤å¤–ç»¼ä¸Šæ‰€è¿°]/g) || []).length;
                return formalWords > 2 ? 'high' : 'medium';
            }
            
            // æœ—è¯»å½“å‰æ®µè½çš„å‡½æ•°
            function speakCurrentSegment() {
                if (currentSegmentIndex >= textSegments.length) {
                    // æœ—è¯»å®Œæˆ
                    isSpeaking = false;
                    currentUtterance = null;
                    const strategy = getCurrentSegmentationStrategy();
                    const strategyName = getSegmentationStrategyName(strategy);
                    status.textContent = `æœ—è¯»å®Œæˆ | ${strategyName} | å…±${textSegments.length}æ®µ`;
                    status.classList.remove('speaking');
                    speakBtn.disabled = false;
                    pauseBtn.disabled = true;
                    pauseBtn.textContent = 'æš‚åœ';
                    isPaused = false;
                    return;
                }
                
                const segment = textSegments[currentSegmentIndex];
                currentUtterance = new SpeechSynthesisUtterance(segment);
                currentUtterance.voice = voices[voiceSelect.value];
                currentUtterance.pitch = pitchRange.value;
                currentUtterance.rate = rateRange.value;
                currentUtterance.volume = volumeRange.value;
                
                currentUtterance.onstart = () => {
                    currentPosition += segment.length;
                    const strategy = getCurrentSegmentationStrategy();
                    const strategyName = getSegmentationStrategyName(strategy);
                    status.textContent = `æ­£åœ¨æœ—è¯»... | ${strategyName} | ç¬¬${currentSegmentIndex + 1}/${textSegments.length}æ®µ`;
                    status.classList.add('speaking');
                };
                
                currentUtterance.onend = () => {
                    currentSegmentIndex++;
                    // ä½¿ç”¨ setTimeout å»¶è¿Ÿæ£€æŸ¥ï¼Œç¡®ä¿çŠ¶æ€æ­£ç¡®æ›´æ–°
                    setTimeout(() => {
                        // æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ‡æ¢ç­–ç•¥
                        if (pendingStrategySwitch && currentText) {
                            // æ‰§è¡Œç­–ç•¥åˆ‡æ¢
                            const strategy = getCurrentSegmentationStrategy();
                            const strategyName = getSegmentationStrategyName(strategy);
                            
                            // ç¡®ä¿ currentPosition ä¸è¶…è¿‡æ–‡æœ¬é•¿åº¦
                            if (currentPosition > currentText.length) {
                                currentPosition = currentText.length;
                            }
                            
                            // è®¡ç®—å‰©ä½™æ–‡æœ¬
                            const remainingText = currentText.substring(currentPosition);
                            
                            // ä½¿ç”¨æ–°ç­–ç•¥å¯¹å‰©ä½™æ–‡æœ¬é‡æ–°åˆ†æ®µ
                            textSegments = splitTextIntoSegments(remainingText);
                            currentSegmentIndex = 0;
                            
                            // æ¸…é™¤åˆ‡æ¢æ ‡å¿—
                            pendingStrategySwitch = false;
                            
                            // æ›´æ–°çŠ¶æ€æ 
                            status.textContent = `å·²åˆ‡æ¢åˆ°${strategyName} | ç¬¬${currentSegmentIndex + 1}/${textSegments.length}æ®µ`;
                            status.classList.add('speaking');
                            
                            // å¼€å§‹æœ—è¯»æ–°ç­–ç•¥çš„ç¬¬ä¸€æ®µ
                            if (isSpeaking && !isPaused) {
                                speakCurrentSegment();
                            }
                        } else if (isSpeaking && !isPaused && currentSegmentIndex < textSegments.length) {
                            // æ­£å¸¸ç»§ç»­ä¸‹ä¸€æ®µ
                            speakCurrentSegment();
                        } else if (currentSegmentIndex >= textSegments.length) {
                            // æœ—è¯»å®Œæˆ
                            isSpeaking = false;
                            currentUtterance = null;
                            const strategy = getCurrentSegmentationStrategy();
                            const strategyName = getSegmentationStrategyName(strategy);
                            status.textContent = `æœ—è¯»å®Œæˆ | ${strategyName} | å…±${textSegments.length}æ®µ`;
                            status.classList.remove('speaking');
                            speakBtn.disabled = false;
                            pauseBtn.disabled = true;
                            pauseBtn.textContent = 'æš‚åœ';
                            isPaused = false;
                        }
                    }, 10);
                };
                
                currentUtterance.onerror = (event) => {
                    isSpeaking = false;
                    currentUtterance = null;
                    const strategy = getCurrentSegmentationStrategy();
                    const strategyName = getSegmentationStrategyName(strategy);
                    status.textContent = `æœ—è¯»å‡ºé”™: ${event.error} | ${strategyName} | å…±${textSegments.length}æ®µ`;
                    status.classList.remove('speaking');
                    speakBtn.disabled = false;
                    pauseBtn.disabled = true;
                    pauseBtn.textContent = 'æš‚åœ';
                    isPaused = false;
                };
                
                synth.speak(currentUtterance);
            }
            
            // æ›´æ–°è¯­éŸ³å‚æ•°çš„å‡½æ•° - å®æ—¶åº”ç”¨è€Œä¸é‡æ–°å¼€å§‹
            function updateUtteranceParameters() {
                if (currentUtterance && isSpeaking) {
                    // ç›´æ¥æ›´æ–°å½“å‰æœ—è¯»å¯¹è±¡çš„å‚æ•°
                    currentUtterance.voice = voices[voiceSelect.value];
                    currentUtterance.pitch = pitchRange.value;
                    currentUtterance.rate = rateRange.value;
                    currentUtterance.volume = volumeRange.value;
                }
            }
            
            // å¼€å§‹æœ—è¯»
            speakBtn.addEventListener('click', () => {
                if (isSpeaking && !isPaused) {
                    return;
                }
                
                if (hanziInput.value.trim() !== '') {
                    // å¦‚æœæ˜¯ä»æš‚åœçŠ¶æ€æ¢å¤ï¼Œç»§ç»­å½“å‰æ®µè½
                    if (isPaused) {
                        synth.resume();
                        isPaused = false;
                        pauseBtn.textContent = 'æš‚åœ';
                        status.textContent = 'æ­£åœ¨æœ—è¯»...';
                        status.classList.add('speaking');
                        return;
                    }
                    
                    // åˆå§‹åŒ–æœ—è¯»çŠ¶æ€
                    currentText = hanziInput.value;
                    currentVoiceIndex = voiceSelect.value;
                    textSegments = splitTextIntoSegments(currentText);
                    currentSegmentIndex = 0;
                    currentPosition = 0;
                    
                    isSpeaking = true;
                    const strategy = getCurrentSegmentationStrategy();
                    const strategyName = getSegmentationStrategyName(strategy);
                    status.textContent = `æ­£åœ¨æœ—è¯»... | ${strategyName} | å…±${textSegments.length}æ®µ`;
                    status.classList.add('speaking');
                    speakBtn.disabled = true;
                    pauseBtn.disabled = false;
                    pauseBtn.textContent = 'æš‚åœ';
                    isPaused = false;
                    
                    // å¼€å§‹æœ—è¯»ç¬¬ä¸€æ®µ
                    speakCurrentSegment();
                } else {
                    status.textContent = 'è¯·è¾“å…¥è¦æœ—è¯»çš„æ–‡æœ¬';
                }
            });
            
            // æš‚åœ/ç»§ç»­æœ—è¯»
            pauseBtn.addEventListener('click', () => {
                if (isPaused) {
                    // ç»§ç»­æ’­æ”¾ - ä»å½“å‰æ®µè½ç»§ç»­
                    synth.resume();
                    isPaused = false;
                    pauseBtn.textContent = 'æš‚åœ';
                    const strategy = getCurrentSegmentationStrategy();
                    const strategyName = getSegmentationStrategyName(strategy);
                    status.textContent = `æ­£åœ¨æœ—è¯»... | ${strategyName} | ç¬¬${currentSegmentIndex + 1}/${textSegments.length}æ®µ`;
                    status.classList.add('speaking');
                    
                    // å¦‚æœå½“å‰æ®µè½å·²ç»è¯»å®Œï¼Œç«‹å³ç»§ç»­ä¸‹ä¸€æ®µ
                    if (!synth.speaking && isSpeaking && !isPaused) {
                        speakCurrentSegment();
                    }
                } else {
                    // æš‚åœæ’­æ”¾
                    if (synth.speaking) {
                        synth.pause();
                        isPaused = true;
                        pauseBtn.textContent = 'ç»§ç»­';
                        const strategy = getCurrentSegmentationStrategy();
                        const strategyName = getSegmentationStrategyName(strategy);
                        status.textContent = `å·²æš‚åœæœ—è¯» | ${strategyName} | ç¬¬${currentSegmentIndex + 1}/${textSegments.length}æ®µ`;
                        status.classList.remove('speaking');
                    }
                }
            });
            
            // åœæ­¢æœ—è¯»
            stopBtn.addEventListener('click', () => {
                if (synth.speaking || synth.paused) {
                    synth.cancel();
                    isSpeaking = false;
                    isPaused = false;
                    pendingStrategySwitch = false; // æ¸…é™¤ç­–ç•¥åˆ‡æ¢æ ‡å¿—
                    currentUtterance = null;
                    const segmentCount = textSegments.length;
                    textSegments = [];
                    currentSegmentIndex = 0;
                    currentPosition = 0;
                    pauseBtn.textContent = 'æš‚åœ';
                    pauseBtn.disabled = true;
                    const strategy = getCurrentSegmentationStrategy();
                    const strategyName = getSegmentationStrategyName(strategy);
                    status.textContent = `å·²åœæ­¢æœ—è¯» | ${strategyName} | å…±${segmentCount}æ®µ`;
                    status.classList.remove('speaking');
                    speakBtn.disabled = false;
                    // æ›´æ–°åˆ†æ®µæ•°é‡æ˜¾ç¤º
                    updateSegmentCount();
                }
            });
            
            // ç›‘å¬è¯­éŸ³å‚æ•°å˜åŒ–ï¼Œå®æ—¶æ›´æ–°æœ—è¯»
            pitchRange.addEventListener('input', () => {
                pitchValue.textContent = pitchRange.value;
                updateUtteranceParameters();
            });
            
            pitchRange.addEventListener('change', () => {
                pitchValue.textContent = pitchRange.value;
                updateUtteranceParameters();
            });
            
            rateRange.addEventListener('input', () => {
                rateValue.textContent = rateRange.value;
                updateUtteranceParameters();
            });
            
            rateRange.addEventListener('change', () => {
                rateValue.textContent = rateRange.value;
                updateUtteranceParameters();
            });
            
            volumeRange.addEventListener('input', () => {
                volumeValue.textContent = volumeRange.value;
                updateUtteranceParameters();
            });
            
            volumeRange.addEventListener('change', () => {
                volumeValue.textContent = volumeRange.value;
                updateUtteranceParameters();
            });
            
            // ç›‘å¬åˆ†æ®µç­–ç•¥å˜åŒ–
            document.querySelectorAll('input[name="segmentation"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    const strategy = getCurrentSegmentationStrategy();
                    const strategyName = getSegmentationStrategyName(strategy);
                    showToast(`å·²åˆ‡æ¢åˆ°${strategyName}`, 'success');
                    updateSegmentCount();
                    
                    // å¦‚æœæ­£åœ¨æœ—è¯»ï¼Œæ ‡è®°éœ€è¦åœ¨å½“å‰æ®µè½è¯»å®Œååˆ‡æ¢ç­–ç•¥
                    if (isSpeaking && currentText) {
                        pendingStrategySwitch = true;
                        status.textContent = `æ­£åœ¨è¯»å®Œå½“å‰æ®µè½ï¼Œå³å°†åˆ‡æ¢åˆ°${strategyName}...`;
                    }
                });
            });
            
            voiceSelect.addEventListener('change', () => {
                updateSelectedVoiceDisplay();
                updateUtteranceParameters();
            });
            
            // åˆå§‹åŒ–è¯­éŸ³é€‰æ‹©
            initVoiceSelect();
            
            // åˆå§‹åŒ–æ’¤é”€/åæ’¤é”€æŒ‰é’®çŠ¶æ€
            updateButtonStates();
            
            // åˆå§‹åŒ–å½“å‰å†…å®¹
            currentContent = hanziInput.value;
            
            // åˆå§‹åŒ–åˆ†æ®µæ•°é‡æ˜¾ç¤º
            updateSegmentCount();
            
            // ç›‘å¬è¯­éŸ³åˆ—è¡¨å˜åŒ–
            if (speechSynthesis.onvoiceschanged !== undefined) {
                speechSynthesis.onvoiceschanged = loadVoices;
            }
            
            // å¤šæ¬¡å°è¯•åŠ è½½ï¼Œç¡®ä¿è¯­éŸ³åˆ—è¡¨å®Œå…¨åŠ è½½
            let loadAttempts = 0;
            const maxAttempts = 10;
            const loadInterval = setInterval(() => {
                loadAttempts++;
                if (synth.getVoices().length > 0 || loadAttempts >= maxAttempts) {
                    clearInterval(loadInterval);
                    loadVoices();
                }
            }, 200);
            
            // è‡ªå®šä¹‰ä¸‹æ‹‰æ¡†äº¤äº’
            const selectTrigger = document.getElementById('select-trigger');
            const selectOptions = document.getElementById('select-options');
            const arrow = document.querySelector('.arrow');
            
            // ç‚¹å‡»è§¦å‘å™¨æ˜¾ç¤º/éšè—é€‰é¡¹
            selectTrigger.addEventListener('click', () => {
                const isShowing = selectOptions.classList.contains('show');
                if (isShowing) {
                    selectOptions.classList.remove('show');
                    selectTrigger.classList.remove('active');
                    arrow.classList.remove('up');
                } else {
                    selectOptions.classList.add('show');
                    selectTrigger.classList.add('active');
                    arrow.classList.add('up');
                }
            });
            
            // ç‚¹å‡»é€‰é¡¹é€‰æ‹©è¯­éŸ³
            document.addEventListener('click', (event) => {
                if (event.target.classList.contains('select-option')) {
                    const value = event.target.getAttribute('data-value');
                    voiceSelect.value = value;
                    updateSelectedVoiceDisplay();
                    
                    // å…³é—­ä¸‹æ‹‰æ¡†
                    selectOptions.classList.remove('show');
                    selectTrigger.classList.remove('active');
                    arrow.classList.remove('up');
                }
            });
            
            // ç‚¹å‡»å¤–éƒ¨å…³é—­ä¸‹æ‹‰æ¡†
            document.addEventListener('click', (event) => {
                if (!event.target.closest('.custom-select')) {
                    selectOptions.classList.remove('show');
                    selectTrigger.classList.remove('active');
                    arrow.classList.remove('up');
                }
            });
            
            } else {
            document.getElementById('status').textContent = 'æŠ±æ­‰ï¼Œæ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆåŠŸèƒ½ã€‚';
            document.getElementById('speak-btn').disabled = true;
            document.getElementById('pause-btn').disabled = true;
            document.getElementById('stop-btn').disabled = true;
        }
        
        // ==================== ä¸‹è½½æ–‡ä»¶åŠŸèƒ½ï¼ˆä¸ä¾èµ–è¯­éŸ³åˆæˆï¼Œç§»åˆ°å¤–é¢ï¼‰ ====================
        window.downloadFile = function(filePath, fileName) {
            console.log('[ä¸‹è½½] ä¸‹è½½æ–‡ä»¶:', filePath, fileName);
            
            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const a = document.createElement('a');
            a.href = filePath;
            a.download = fileName;
            a.style.display = 'none';
            document.body.appendChild(a);
            
            // è§¦å‘ä¸‹è½½
            a.click();
            
            // æ¸…ç†
            document.body.removeChild(a);
            
            console.log('[ä¸‹è½½] ä¸‹è½½å®Œæˆ');
        };
        
        // ==================== æ‹¼éŸ³è½¬æ¢åŠŸèƒ½ï¼ˆä¸ä¾èµ–è¯­éŸ³åˆæˆï¼Œç§»åˆ°å¤–é¢ï¼‰ ====================
        // æ˜¾ç¤ºToastæç¤º
        function showToast(message, type) {
            const toast = document.getElementById('toast');
            
            // æ ¹æ®ç±»å‹æ·»åŠ å›¾æ ‡
            let icon = '';
            switch(type) {
                case 'success':
                    icon = 'ğŸŒŸ ';
                    break;
                case 'error':
                    icon = 'âš ï¸ ';
                    break;
                default:
                    icon = 'ğŸ’¡ ';
            }
            
            toast.innerHTML = `<span style="display: flex; align-items: center; gap: 6px;">${icon}${message}</span>`;
            toast.className = `toast ${type}`;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }
        
        // æ›´æ–°æ˜¾ç¤º
        function updateDisplay() {
            if (currentContent) {
                hanziInput.value = currentContent;
            } else {
                hanziInput.value = '';
            }
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            updateButtonStates();
            
            // æ›´æ–°æ‹¼éŸ³è½¬æ¢
            if (typeof convert === 'function') {
                convert();
            }
        }
        
        // æ›´æ–°æŒ‰é’®çŠ¶æ€
        function updateButtonStates() {
            // æ ¹æ®æ ˆçš„çŠ¶æ€å¯ç”¨/ç¦ç”¨æŒ‰é’®
            undoBtn.disabled = undoStack.length === 0;
            redoBtn.disabled = redoStack.length === 0;
        }
        
        // æ’¤é”€æ“ä½œ
        function undo() {
            if (undoStack.length === 0) {
                showToast('æ²¡æœ‰å¯æ’¤é”€çš„æ“ä½œ', 'error');
                return;
            }
            
            // å°†å½“å‰å†…å®¹æ·»åŠ åˆ°é‡åšæ ˆ
            redoStack.push(currentContent);
            
            // ä»æ’¤é”€æ ˆä¸­å–å‡ºä¸Šä¸€ä¸ªå†…å®¹
            currentContent = undoStack.pop();
            
            // æ›´æ–°æ˜¾ç¤º
            updateDisplay();
            
            showToast('å·²æ’¤é”€', 'success');
        }
        
        // åæ’¤é”€æ“ä½œ
        function redo() {
            if (redoStack.length === 0) {
                showToast('æ²¡æœ‰å¯é‡åšçš„æ“ä½œ', 'error');
                return;
            }
            
            // å°†å½“å‰å†…å®¹æ·»åŠ åˆ°æ’¤é”€æ ˆ
            undoStack.push(currentContent);
            
            // ä»é‡åšæ ˆä¸­å–å‡ºä¸‹ä¸€ä¸ªå†…å®¹
            currentContent = redoStack.pop();
            
            // æ›´æ–°æ˜¾ç¤º
            updateDisplay();
            
            showToast('å·²é‡åš', 'success');
        }
        
        // æ–‡ä»¶åŠ è½½åŠŸèƒ½ï¼ˆæ‹¼éŸ³è½¬æ¢ï¼‰
        fileInput.addEventListener('change', () => {
            const file = fileInput.files[0];
            if (file) {
                const pinyinDisplay = document.getElementById('pinyin-display');
                
                // æ˜¾ç¤ºè¯»å–ä¸­çŠ¶æ€
                status.textContent = 'æ­£åœ¨è¯»å–æ–‡ä»¶...';
                pinyinDisplay.innerHTML = '<div style="text-align: center; color: #667eea; padding: 20px;"><i style="font-size: 24px; display: block; margin-bottom: 10px;">â³</i>æ­£åœ¨è¯»å–æ–‡ä»¶...</div>';
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    const fileContent = e.target.result;
                    
                    // ä¿å­˜å½“å‰å†…å®¹åˆ°æ’¤é”€æ ˆ
                    if (currentContent !== undefined && currentContent !== fileContent) {
                        undoStack.push(currentContent);
                        if (undoStack.length > 50) {
                            undoStack.shift();
                        }
                        redoStack = [];
                        updateButtonStates();
                    }
                    
                    // è®¾ç½®æ–°å†…å®¹åˆ°è¾“å…¥æ¡†
                    hanziInput.value = fileContent;
                    currentContent = fileContent;
                    
                    // ç«‹å³è§¦å‘è½¬æ¢
                    // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
                    if (typingTimer) {
                        clearTimeout(typingTimer);
                    }
                    
                    // è®¾ç½®æ–°çš„å®šæ—¶å™¨ï¼Œå»¶è¿Ÿæ‰§è¡Œè½¬æ¢ï¼ˆTYPING_DELAY = 30msï¼‰
                    typingTimer = setTimeout(() => {
                        convert();
                    }, TYPING_DELAY);
                    
                    status.textContent = `å·²æˆåŠŸåŠ è½½æ–‡ä»¶: ${file.name} (${fileContent.length} å­—)`;
                    showToast(`æ–‡ä»¶åŠ è½½æˆåŠŸï¼Œå…± ${fileContent.length} å­—`, 'success');
                };
                reader.onerror = function() {
                    status.textContent = 'æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•';
                    pinyinDisplay.innerHTML = '<span style="color: red;">æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•</span>';
                    showToast('æ–‡ä»¶è¯»å–å¤±è´¥', 'error');
                };
                reader.readAsText(file, 'UTF-8');
            }
        });
        
        // ç›‘å¬è¾“å…¥æ¡†å˜åŒ–ï¼ˆå®æ—¶è½¬æ¢ï¼‰
        hanziInput.addEventListener('input', function(e) {
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (typingTimer) {
                clearTimeout(typingTimer);
            }
            
            // è®¾ç½®æ–°çš„å®šæ—¶å™¨ï¼Œå»¶è¿Ÿæ‰§è¡Œè½¬æ¢
            typingTimer = setTimeout(() => {
                convert();
            }, TYPING_DELAY);
            
            // æ›´æ–°è™šæ‹Ÿå…‰æ ‡
            setTimeout(updateVirtualCursor, 10);
        });
        
        // ç›‘å¬æ»šåŠ¨äº‹ä»¶ï¼Œä¿æŒæ‹¼éŸ³æ˜¾ç¤ºå’Œè¾“å…¥æ¡†åŒæ­¥
        hanziInput.addEventListener('scroll', function() {
            const pinyinDisplay = document.getElementById('pinyin-display');
            pinyinDisplay.scrollTop = this.scrollTop;
            pinyinDisplay.scrollLeft = this.scrollLeft;
        });
        
        // è™šæ‹Ÿå…‰æ ‡åŒæ­¥é€»è¾‘
        function updateVirtualCursor() {
            const virtualCursor = document.getElementById('virtual-cursor');
            const pinyinDisplay = document.getElementById('pinyin-display');
            
            try {
                const cursorPos = hanziInput.selectionStart;
                const textBeforeCursor = hanziInput.value.substring(0, cursorPos);
                
                // åˆ›å»ºä¸€ä¸ªä¸è¾“å…¥æ¡†å®Œå…¨ç›¸åŒçš„divæ¥æµ‹é‡
                const measurer = document.createElement('div');
                
                // ç›´æ¥å¤åˆ¶è¾“å…¥æ¡†çš„æ‰€æœ‰æ ·å¼
                const inputStyle = window.getComputedStyle(hanziInput);
                for (let prop of inputStyle) {
                    measurer.style[prop] = inputStyle[prop];
                }
                
                // è®¾ç½®æµ‹é‡å…ƒç´ çš„ä½ç½®å’Œå¯è§æ€§
                measurer.style.position = 'absolute';
                measurer.style.visibility = 'hidden';
                measurer.style.left = '-9999px';
                measurer.style.top = '-9999px';
                measurer.style.width = hanziInput.offsetWidth + 'px';
                measurer.style.height = hanziInput.offsetHeight + 'px';
                measurer.style.overflow = 'auto';
                measurer.style.whiteSpace = 'pre-wrap';
                measurer.style.wordWrap = 'break-word';
                
                // è®¾ç½®å†…å®¹
                measurer.textContent = textBeforeCursor;
                document.body.appendChild(measurer);
                
                // æ»šåŠ¨åˆ°ä¸è¾“å…¥æ¡†ç›¸åŒçš„ä½ç½®
                measurer.scrollTop = hanziInput.scrollTop;
                measurer.scrollLeft = hanziInput.scrollLeft;
                
                // åˆ›å»ºä¸€ä¸ªå…‰æ ‡æ ‡è®°å…ƒç´ 
                const cursorMarker = document.createElement('span');
                cursorMarker.textContent = '|';
                cursorMarker.style.color = 'red';
                measurer.appendChild(cursorMarker);
                
                // è·å–å…‰æ ‡æ ‡è®°çš„ä½ç½®
                const markerRect = cursorMarker.getBoundingClientRect();
                const measurerRect = measurer.getBoundingClientRect();
                
                // è®¡ç®—ç›¸å¯¹äºè¾“å…¥æ¡†çš„ä½ç½®
                const relativeLeft = markerRect.left - measurerRect.left;
                const relativeTop = markerRect.top - measurerRect.top;
                
                // è®¾ç½®è™šæ‹Ÿå…‰æ ‡ä½ç½®
                virtualCursor.style.left = relativeLeft + 'px';
                virtualCursor.style.top = relativeTop + 'px';
                virtualCursor.style.display = 'block';
                virtualCursor.style.backgroundColor = '#333';
                virtualCursor.style.height = (parseFloat(inputStyle.lineHeight) || 20) + 'px';
                
                // æ¸…ç†
                document.body.removeChild(measurer);
            } catch (e) {
                console.error('è·å–å…‰æ ‡ä½ç½®å¤±è´¥:', e);
                virtualCursor.style.display = 'none';
            }
        }
        
        // ç›‘å¬å…‰æ ‡ä½ç½®å˜åŒ–
        hanziInput.addEventListener('click', updateVirtualCursor);
        hanziInput.addEventListener('keyup', updateVirtualCursor);
        hanziInput.addEventListener('keydown', updateVirtualCursor);
        hanziInput.addEventListener('focus', updateVirtualCursor);
        hanziInput.addEventListener('blur', function() {
            document.getElementById('virtual-cursor').style.display = 'none';
        });
        
        // åˆå§‹åŒ–è™šæ‹Ÿå…‰æ ‡
        setTimeout(updateVirtualCursor, 500);
        
        // æ’¤é”€å’Œåæ’¤é”€æŒ‰é’®äº‹ä»¶ç›‘å¬
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        
        // ç›‘å¬é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function(e) {
            // Ctrl+Z æ’¤é”€
            if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            }
            // Ctrl+Shift+Z æˆ– Ctrl+Y åæ’¤é”€
            else if ((e.ctrlKey && e.shiftKey && e.key === 'Z') || (e.ctrlKey && e.key === 'y')) {
                e.preventDefault();
                redo();
            }
        });
        
        // æ‹¼éŸ³ç¼“å­˜
        const pinyinCache = new Map();
        let processingTimeout = null;
        
        // é˜²æŠ–å‡½æ•°
        function debounce(func, wait) {
            return function(...args) {
                clearTimeout(processingTimeout);
                processingTimeout = setTimeout(() => func.apply(this, args), wait);
            };
        }
        
        // å®æ—¶æ‹¼éŸ³è½¬æ¢ç›¸å…³å˜é‡ï¼ˆå®Œå…¨æ¥è‡ª realtime_pinyin_converter.htmlï¼‰
        let currentTab = 'ruby';
        let currentResult = '';
        let typingTimer = null;
        const TYPING_DELAY = 30; // æ‰“å­—å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰

        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchTab(element, tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            element.classList.add('active');
            currentTab = tab;
            
            // å¦‚æœæœ‰è¾“å…¥å†…å®¹ï¼Œç«‹å³æ›´æ–°
            if (document.getElementById('hanziInput').value.trim()) {
                convert();
            }
        }

        // å®æ—¶è½¬æ¢å‡½æ•°ï¼ˆä¼˜åŒ–ç‰ˆ - å¼‚æ­¥å¤„ç†ï¼‰
        function convert() {
            const input = document.getElementById('hanziInput').value.trim();
            const resultDiv = document.getElementById('pinyin-display');
            
            if (!input) {
                resultDiv.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">è¯·åœ¨ä¸Šæ–¹è¾“å…¥æ–‡å­—ï¼Œæ‹¼éŸ³å°†å®æ—¶æ˜¾ç¤º</p>';
                currentResult = '';
                return;
            }

            const toneType = document.querySelector('input[name="toneType"]:checked').value;
            const keepSpace = document.getElementById('space').checked;
            const firstLetter = document.getElementById('firstLetter').checked;

// âœ… æ€§èƒ½ä¼˜åŒ–ï¼šä½¿ç”¨ type: 'array' ä»£æ›¿ 'all'ï¼Œæ€§èƒ½æå‡å‡ åå€
                    const options = {
                        pattern: 'pinyin',
                        toneType: toneType,
                        type: 'array', // å…³é”®ä¼˜åŒ–ï¼šè¿”å›å­—ç¬¦ä¸²æ•°ç»„ï¼Œè€Œä¸æ˜¯å¯¹è±¡æ•°ç»„
                        v: true,
                        nonZh: 'removed', // å§‹ç»ˆç§»é™¤éä¸­æ–‡å­—ç¬¦çš„æ‹¼éŸ³ï¼ŒåŒ…æ‹¬æ ‡ç‚¹ç¬¦å·
                        separator: '',
                        mode: 'normal'
                    };

            // æ ¹æ®é¦–å­—æ¯é€‰é¡¹è°ƒæ•´
            if (firstLetter) {
                options.pattern = 'first';
            }

            // âœ… ç«‹å³è¿”å›ï¼Œä¸é˜»å¡ä¸»çº¿ç¨‹
            setTimeout(() => {
                try {
                    // åˆ¤æ–­æ˜¯å¦éœ€è¦åˆ†æ‰¹å¤„ç†
                    if (input.length > 100000) {
                        // è¶…å¤§æ–‡æœ¬ï¼ˆ>10ä¸‡å­—ï¼‰ï¼šåˆ†æ‰¹å¤„ç†
                        convertWithBatchProcessing(input, options, false);
                    } else {
                        // ä¸­å°æ–‡æœ¬ï¼ˆ<10ä¸‡å­—ï¼‰ï¼šç›´æ¥å¤„ç†
                        const result = pinyinPro.pinyin(input, options);
                        currentResult = result;
                        
                        // âœ… æ¸²æŸ“ä¹Ÿå¼‚æ­¥
                        setTimeout(() => {
                            displayRubyResult(input, result, options);
                        }, 0);
                    }
                } catch (error) {
                    console.error('è½¬æ¢é”™è¯¯:', error);
                    resultDiv.innerHTML = '<span style="color: red;">è½¬æ¢å¤±è´¥ï¼š' + error.message + '</span>';
                }
            }, 0);
        }

        // è¶…å¤§æ–‡æœ¬åˆ†æ‰¹å¤„ç†
        function convertWithBatchProcessing(input, options, arrayFormat) {
            const resultDiv = document.getElementById('pinyin-display');
            const BATCH_SIZE = 80000; // 8ä¸‡ä¸€æ‰¹
            
            // æ˜¾ç¤ºè¿›åº¦æç¤º
            resultDiv.innerHTML = '<div style="text-align: center; color: #667eea; padding: 20px;"><i style="font-size: 24px; display: block; margin-bottom: 10px;">â³</i>æ­£åœ¨è½¬æ¢ä¸­...ï¼ˆå…± ' + input.length + ' å­—ï¼‰</div>';
            
            const totalChunks = Math.ceil(input.length / BATCH_SIZE);
            const results = new Array(totalChunks);
            let completed = 0;
            
            function processChunk(chunkIndex) {
                if (chunkIndex >= totalChunks) {
                    // æ‰€æœ‰æ‰¹æ¬¡å®Œæˆï¼Œåˆå¹¶ç»“æœ
                    finishBatchProcessing(results, input, options, arrayFormat);
                    return;
                }
                
                const startIndex = chunkIndex * BATCH_SIZE;
                const endIndex = Math.min(startIndex + BATCH_SIZE, input.length);
                const chunk = input.slice(startIndex, endIndex);
                
                // ä½¿ç”¨ setTimeout è®©å‡ºä¸»çº¿ç¨‹ï¼Œé¿å…é˜»å¡ UI
                setTimeout(() => {
                    try {
                        const chunkResult = pinyinPro.pinyin(chunk, options);
                        results[chunkIndex] = chunkResult;
                        completed++;
                        
                        // æ›´æ–°è¿›åº¦æç¤ºï¼ˆæ¯5ä¸ªæ‰¹æ¬¡æ›´æ–°ä¸€æ¬¡ï¼Œé¿å…é¢‘ç¹ DOM æ“ä½œï¼‰
                        if (chunkIndex % 5 === 0 || chunkIndex === totalChunks - 1) {
                            const progress = Math.round((completed / totalChunks) * 100);
                            resultDiv.innerHTML = `<div style="text-align: center; color: #667eea; padding: 20px;"><i style="font-size: 24px; display: block; margin-bottom: 10px;">â³</i>æ­£åœ¨è½¬æ¢ä¸­... ${progress}%</div>`;
                        }
                        
                        // å¤„ç†ä¸‹ä¸€æ‰¹
                        setTimeout(() => processChunk(chunkIndex + 1), 0);
                    } catch (error) {
                        console.error('æ‰¹æ¬¡è½¬æ¢é”™è¯¯:', error);
                        resultDiv.innerHTML = '<span style="color: red;">è½¬æ¢å¤±è´¥ï¼š' + error.message + '</span>';
                    }
                }, 0);
            }
            
            // å¼€å§‹å¤„ç†ç¬¬ä¸€æ‰¹
            setTimeout(() => processChunk(0), 0);
        }

        // å®Œæˆåˆ†æ‰¹å¤„ç†
        function finishBatchProcessing(results, input, options, arrayFormat) {
            // åˆå¹¶æ‰€æœ‰æ‰¹æ¬¡ç»“æœ
            const finalResult = results.flat();
            currentResult = finalResult;
            
            // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿ DOM æ›´æ–°åœ¨ä¸‹ä¸€å¸§
            requestAnimationFrame(() => {
                displayRubyResult(input, finalResult, options);
            });
        }

// âœ… æ˜¾ç¤º Ruby ç»“æœ - é«˜æ€§èƒ½ç‰ˆæœ¬
        function displayRubyResult(input, result, options) {
            const resultDiv = document.getElementById('pinyin-display');
            
            // âœ… result ç°åœ¨æ˜¯å­—ç¬¦ä¸²æ•°ç»„ï¼Œå¯¹åº” input ä¸­çš„ä¸­æ–‡å­—ç¬¦
            if (!Array.isArray(result)) {
                console.error('result ä¸æ˜¯æ•°ç»„:', result);
                return;
            }
            
            // è·å–"ä»…é¦–å­—æ¯"é€‰é¡¹
            const firstLetter = document.getElementById('firstLetter').checked;
            
            // âœ… æ€§èƒ½ä¼˜åŒ–ï¼šç›´æ¥æ„å»º HTML å­—ç¬¦ä¸²ï¼Œé¿å…é¢‘ç¹ DOM æ“ä½œ
            const BATCH_SIZE = 10000; // æ¯æ‰¹å¤„ç†10000ä¸ªå­—ç¬¦
            let currentIndex = 0;
            let html = '';
            let pinyinIndex = 0; // è·Ÿè¸ªæ‹¼éŸ³æ•°ç»„çš„ç´¢å¼•
            
            // æ¸…ç©ºæ˜¾ç¤º
            resultDiv.innerHTML = '';
            
            function processBatch() {
                if (currentIndex >= input.length) {
                    // æ‰€æœ‰æ‰¹æ¬¡å¤„ç†å®Œæˆï¼Œä¸€æ¬¡æ€§æ¸²æŸ“
                    resultDiv.innerHTML = html;
                    return;
                }
                
                const endIndex = Math.min(currentIndex + BATCH_SIZE, input.length);
                
                // âœ… éå† input å­—ç¬¦ä¸²ï¼ŒåŒæ—¶ä½¿ç”¨ pinyinIndex è·Ÿè¸ªæ‹¼éŸ³
                for (let i = currentIndex; i < endIndex; i++) {
                    const char = input[i];
                    
                    // åˆ¤æ–­æ˜¯å¦æ˜¯ä¸­æ–‡å­—ç¬¦
                    if (/[\u4e00-\u9fa5]/.test(char)) {
                        // ä»ç»“æœæ•°ç»„ä¸­è·å–å¯¹åº”çš„æ‹¼éŸ³
                        let pinyin = result[pinyinIndex] || '';
                        pinyinIndex++;
                        
                        // å¤„ç†é¦–å­—æ¯
                        if (firstLetter && pinyin) {
                            pinyin = pinyin.charAt(0).toUpperCase();
                        }
                        
                        // âœ… ä½¿ç”¨ ruby æ ‡ç­¾ï¼ˆé«˜æ€§èƒ½ç‰ˆæœ¬ï¼‰
                        html += `<ruby>${char}<rt>${pinyin}</rt></ruby>`;
                    } else if (char === '\n') {
                        html += '<br>';
                    } else if (char === ' ') {
                        if (document.getElementById('space').checked) {
                            html += ' ';
                        }
                    } else {
                        // éä¸­æ–‡å­—ç¬¦ï¼ˆæ ‡ç‚¹ã€æ•°å­—ã€è‹±æ–‡ç­‰ï¼‰- ç›´æ¥æ˜¾ç¤ºï¼Œä¸ä½¿ç”¨ ruby æ ‡ç­¾
                        switch(char) {
                            case '<': html += '&lt;'; break;
                            case '>': html += '&gt;'; break;
                            case '&': html += '&amp;'; break;
                            case '"': html += '&quot;'; break;
                            case "'": html += '&#39;'; break;
                            default: html += char;
                        }
                    }
                }
                
                currentIndex = endIndex;
                
                // ä½¿ç”¨ requestAnimationFrame è®©å‡ºä¸»çº¿ç¨‹
                requestAnimationFrame(processBatch);
            }
            
            // å¼€å§‹å¤„ç†
            processBatch();
        }

        // åŠ è½½æ‹¼éŸ³åº“ååˆå§‹åŒ–
        loadPinyinPro().then(() => {
            // åˆå§‹åŒ–å®Œæˆåè°ƒç”¨ä¸€æ¬¡
            convert();
        });
        
        // ç›‘å¬é…ç½®é€‰é¡¹å˜åŒ–
        document.querySelectorAll('input[name="toneType"], input[type="checkbox"]').forEach(element => {
            element.addEventListener('change', function() {
                if (document.getElementById('hanziInput').value.trim()) {
                    convert();
                }
            });
        });
        
        
        
                // æ·»åŠ é”®ç›˜äº‹ä»¶æ”¯æŒ
        
                document.getElementById('hanziInput').addEventListener('keydown', function(e) {
        
                    if (e.key === 'Enter' && e.ctrlKey) {
        
                        if (typeof convertHanzi === 'function') {
        
                            convertHanzi();
        
                        }
        
                    }
        
                });
        
        // è®¡ç®—åˆ†å‰²ç‚¹æƒé‡ï¼ˆæƒé‡è¯„åˆ†ç³»ç»Ÿä¸“ç”¨ï¼‰
        function calculateSplitScore(char, segment, position, fullText, prevChar, nextChar) {
            let score = 0;
            
            // 1. å¥æœ«æ ‡ç‚¹ - æœ€é«˜æƒé‡
            if (/[ã€‚ï¼ï¼Ÿ]/.test(char)) {
                score += 15;
            }
            // çœç•¥å·
            else if (char === 'â€¦' || (char === '.' && nextChar === '.')) {
                score += 12;
            }
            // 2. åˆ†å¥æ ‡ç‚¹ - é«˜æƒé‡
            else if (/[ï¼Œã€ï¼›ï¼š]/.test(char)) {
                score += 8;
            }
            // 3. å¼•å·ç»“æŸ - ä¸­é«˜æƒé‡
            else if (/[\""''ã€‹ï¼‰ã€‹ã€‘ã€•\]\}]/.test(char)) {
                score += 7;
            }
            // 4. è¯­ä¹‰åœé¡¿è¯ - ä¸­ç­‰æƒé‡
            else if (/[çš„äº†åœ¨æ˜¯æœ‰å’Œä¸åŠæˆ–ä½†è€Œå› ä¸ºæ‰€ä»¥å¦‚æœé‚£ä¹ˆè™½ç„¶ç„¶è€Œä¸è¿‡ä¸è¿‡å¯æ˜¯ç„¶è€Œ]/.test(char)) {
                // è¯­ä¹‰åœé¡¿è¯ååˆ†å‰²ï¼Œä½†ç¡®ä¿ä¸åœ¨å¤åˆè¯ä¸­
                if (!isPartOfCompound(char, nextChar)) {
                    score += 4;
                }
            }
            // 5. åŠ¨è¯ååˆ†å‰² - è¾ƒä½æƒé‡
            else if (/[äº†ç€è¿‡]/.test(char) && isChineseChar(prevChar)) {
                score += 3;
            }
            // 6. ç©ºæ ¼åˆ†å‰² - è‹±æ–‡å•è¯è¾¹ç•Œ
            else if (/\s/.test(char) && segment.trim().length > 0) {
                score += 2;
            }
            // 7. é•¿åº¦æƒ©ç½š - é¿å…è¿‡é•¿æ®µè½
            if (segment.length > 18) {
                score += 5;
            } else if (segment.length > 15) {
                score += 3;
            } else if (segment.length > 12) {
                score += 1;
            }
            
            // 8. ä¸Šä¸‹æ–‡è°ƒæ•´
            // é¿å…åœ¨è‹±æ–‡å•è¯ä¸­é—´åˆ†å‰²
            if (/[a-zA-Z0-9]/.test(nextChar)) {
                score -= 8;
            }
            // é¿å…åœ¨æ•°å­—ä¸­é—´åˆ†å‰²
            if (/[0-9]/.test(char) && /[0-9]/.test(nextChar)) {
                score -= 6;
            }
            // é¿å…åœ¨æ—¶é—´è¡¨è¾¾å¼ä¸­åˆ†å‰²
            if (/[æ—¶åˆ†ç§’]/.test(char) && /[0-9]/.test(nextChar)) {
                score -= 5;
            }
            
            return Math.max(0, score);
        }
        
        // åŠ¨æ€é˜ˆå€¼è®¡ç®—ï¼ˆæƒé‡è¯„åˆ†ç³»ç»Ÿä¸“ç”¨ï¼‰
        function getDynamicThreshold(segment, existingSegments) {
            // åŸºç¡€é˜ˆå€¼
            let threshold = 6;
            
            // æ ¹æ®æ®µè½é•¿åº¦è°ƒæ•´
            if (segment.length < 5) {
                threshold += 3; // æé«˜é˜ˆå€¼ï¼Œé¿å…è¿‡çŸ­æ®µè½
            } else if (segment.length > 20) {
                threshold -= 2; // é™ä½é˜ˆå€¼ï¼Œé¼“åŠ±åˆ†å‰²
            }
            
            // æ ¹æ®å·²æœ‰æ®µè½æ•°é‡è°ƒæ•´
            if (existingSegments.length > 10) {
                threshold += 1; // æ®µè½è¿‡å¤šæ—¶æé«˜é˜ˆå€¼
            }
            
            // æ ¹æ®æ®µè½æœ«å°¾å­—ç¬¦è°ƒæ•´
            const lastChar = segment[segment.length - 1];
            if (/[çš„]/.test(lastChar)) {
                threshold += 1; // é¿å…åœ¨"çš„"ååˆ†å‰²
            }
            
            return threshold;
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºå¤åˆè¯çš„ä¸€éƒ¨åˆ†ï¼ˆæƒé‡è¯„åˆ†ç³»ç»Ÿä¸“ç”¨ï¼‰
        function isPartOfCompound(char, nextChar) {
            const compounds = [
                ['å› ä¸º', 'æ‰€ä»¥'],
                ['è™½ç„¶', 'ä½†æ˜¯'],
                ['å¦‚æœ', 'é‚£ä¹ˆ'],
                ['ä¸ä½†', 'è€Œä¸”'],
                ['ä¸ä»…', 'è¿˜']
            ];
            
            for (const compound of compounds) {
                for (let i = 0; i < compound.length - 1; i++) {
                    if (char === compound[i][compound[i].length - 1] && 
                        nextChar === compound[i + 1][0]) {
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // æ™ºèƒ½åˆå¹¶è¿‡çŸ­æ®µè½ï¼ˆæƒé‡è¯„åˆ†ç³»ç»Ÿä¸“ç”¨ï¼‰
        function mergeShortSegments(segments) {
            const mergedSegments = [];
            let tempSegment = '';
            
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                tempSegment += segment;
                
                // åˆå¹¶æ¡ä»¶
                const shouldMerge = 
                    tempSegment.length < 8 || // å½“å‰æ®µè½è¿‡çŸ­
                    (i < segments.length - 1 && segments[i + 1].length < 5); // ä¸‹ä¸€æ®µè¿‡çŸ­
                
                // å¦‚æœé‡åˆ°å¥æœ«æ ‡ç‚¹æˆ–è¾¾åˆ°åˆé€‚é•¿åº¦ï¼Œä¸”ä¸æ»¡è¶³åˆå¹¶æ¡ä»¶ï¼Œåˆ™å®Œæˆåˆå¹¶
                if (!shouldMerge && (/[ã€‚ï¼ï¼Ÿ]$/.test(tempSegment) || tempSegment.length >= 10)) {
                    mergedSegments.push(tempSegment);
                    tempSegment = '';
                }
            }
            
            // æ·»åŠ å‰©ä½™å†…å®¹
            if (tempSegment) {
                mergedSegments.push(tempSegment);
            }
            
            return mergedSegments.length > 0 ? mergedSegments : segments;
        }
    </script>
</body>
</html>