<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‰∫åÁª¥Á†ÅÁîüÊàêÂô®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #bdbebf 0%, #000000 100%);
            min-height: 100vh;
            padding: 3px;
        }
        
        .main-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .sidebar {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            padding: 30px;
            margin-bottom: 20px;
        }
        
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 3px;
        }
        
        .logo {
            text-align: center;
            margin-bottom: 25px;
        }
        
        .logo-icon {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            margin-bottom: 10px;
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.3);
        }
        
        .logo h2 {
            font-size: 24px;
            color: #1a202c;
            font-weight: 700;
        }
        
        .config-sections {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 25px;
            margin-bottom: 25px;
        }
        
        .config-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
        }
        
        .config-section h3 {
            font-size: 15px;
            color: #2d3748;
            margin-bottom: 15px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .form-group {
            margin-bottom: 18px;
        }
        
        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }
        
        .form-group label {
            display: block;
            font-size: 13px;
            color: #2d3748;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .form-group label span {
            color: #667eea;
            font-weight: 600;
        }
        
        input[type="text"],
        input[type="file"],
        input[type="number"],
        textarea,
        select {
            width: 100%;
            padding: 10px 12px;
            border: 1.5px solid #e2e8f0;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.2s;
            background: #fafafa;
            color: #2d3748;
            font-family: inherit;
        }
        
        input[type="number"] {
            margin-bottom: 8px;
        }
        input[type="text"]:focus,
        input[type="number"]:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        textarea {
            resize: vertical;
            min-height: 80px;
            line-height: 1.5;
        }
        
        input[type="color"] {
            width: 100%;
            height: 45px;
            border: 1.5px solid #e2e8f0;
            border-radius: 8px;
            cursor: pointer;
            background: #fafafa;
        }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e2e8f0;
            outline: none;
            /* -webkit-appearance: none; */
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
        }
        
        input[type="file"] {
            padding: 8px;
            cursor: pointer;
        }
        
        small {
            display: block;
            margin-top: 5px;
            font-size: 12px;
            color: #718096;
        }
        
        .text-stats {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            padding: 8px 12px;
            background: #f0f4f8;
            border-radius: 6px;
            font-size: 12px;
            color: #4a5568;
        }
        
        .text-stats strong {
            color: #667eea;
            font-weight: 600;
        }
        
        .text-stats .warning {
            color: #e53e3e;
        }
        
        .generate-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }
        
        .generate-btn:active {
            transform: translateY(0);
        }
        
        .preview-area {
            background: white;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .preview-header {
            padding: 20px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .preview-header h1 {
            font-size: 20px;
            color: white;
            font-weight: 700;
        }
        
        .download-btn {
            padding: 10px 20px;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .preview-content {
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 50px;
            background: #f8f9fa;
        }
        
        .empty-state {
            text-align: center;
            color: #718096;
        }
        
        .empty-icon {
            font-size: 100px;
            margin-bottom: 20px;
            opacity: 0.4;
        }
        
        .empty-state h3 {
            font-size: 22px;
            color: #4a5568;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .empty-state p {
            font-size: 15px;
            color: #a0aec0;
        }
        
        .qrcode-display {
            text-align: center;
            padding: 50px;
            animation: fadeIn 0.4s ease-out;
            background: #f8f9fa;
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }
        
        #qrcode {
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.15);
            max-width: 100%;
            height: auto;
        }
        
        .bottom-text {
            margin-top: 25px;
            font-size: 18px;
            color: #2d3748;
            font-weight: 600;
        }
        
        .error-message {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #fee;
            color: #c00;
            padding: 15px 20px;
            border-radius: 10px;
            border-left: 4px solid #c00;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: none;
            animation: slideInRight 0.3s;
            max-width: 400px;
            z-index: 1000;
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .sidebar {
                padding: 20px;
            }
            
            .config-sections {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .preview-content,
            .qrcode-display {
                padding: 30px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar">
            <div class="logo">
                <div class="logo-icon">‚ö°</div>
                <h2>‰∫åÁª¥Á†ÅÁîüÊàêÂô®</h2>
            </div>
            
            <div class="config-sections">
                <div class="config-section">
                    <h3>üìù Âü∫Êú¨ËÆæÁΩÆ</h3>
                    <div class="form-group">
                        <label>ÂÜÖÂÆπ</label>
                        <textarea id="text" placeholder="ËæìÂÖ•ÊñáÊú¨„ÄÅÁΩëÂùÄÁ≠âÂÜÖÂÆπ..." rows="3"></textarea>
                        <div class="text-stats">
                            <span>Â≠óÁ¨¶: <strong id="charCount">0</strong> / <span id="maxChars">-</span></span>
                            <span>Â≠óËäÇ: <strong id="byteCount">0</strong> / <span id="maxBytes">2953</span></span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Â∫ïÈÉ®ÊñáÂ≠ó</label>
                        <input type="text" id="bottomText" placeholder="ÂèØÈÄâ">
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>üé® Â§ñËßÇËÆæÁΩÆ</h3>
                    <div class="form-row">
                        <div class="form-group">
                            <label>ÂâçÊôØËâ≤</label>
                            <input type="color" id="fgColor" value="#000000">
                        </div>
                        <div class="form-group">
                            <label>ËÉåÊôØËâ≤</label>
                            <input type="color" id="bgColor" value="#ffffff">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>ËÉåÊôØÂõæÁâá</label>
                        <input type="file" id="bgImageFile" accept="image/*">
                        <small>ÈÄâÊã©ËÉåÊôØÂõæÁâá,‰∫åÁª¥Á†ÅÂ∞ÜÁªòÂà∂Âú®ÂõæÁâá‰∏äÊñπ</small>
                    </div>
                    <div class="form-group">
                        <label>LogoÂõæÁâá</label>
                        <input type="file" id="logoFile" accept="image/*">
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>üìê Â∞∫ÂØ∏ËÆæÁΩÆ</h3>
                    <div class="form-group">
                        <label>Â∞∫ÂØ∏ <span id="sizeValue">500</span>px</label>
                        <input type="number" id="sizeInput" value="500" min="1" placeholder="ËæìÂÖ•Â∞∫ÂØ∏">
                        <input type="range" id="size" min="0" max="10000" value="500" step="50">
                    </div>
                    <div class="form-group">
                        <label>ËæπË∑ù <span id="marginValue">20</span>px</label>
                        <input type="number" id="marginInput" value="20" min="0" placeholder="ËæìÂÖ•ËæπË∑ù">
                        <input type="range" id="margin" min="0" max="100" value="20" step="5">
                    </div>
                </div>
                
                <div class="config-section">
                    <h3>‚öôÔ∏è È´òÁ∫ßËÆæÁΩÆ</h3>
                    <div class="form-group">
                        <label>ÂÆπÈîôÁ∫ßÂà´</label>
                        <select id="errorLevel">
                            <option value="L">‰Ωé 7%</option>
                            <option value="M" selected>‰∏≠ 15%</option>
                            <option value="Q">ËæÉÈ´ò 25%</option>
                            <option value="H">È´ò 30%</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>ÂØºÂá∫Ê†ºÂºè</label>
                        <select id="exportFormat">
                            <option value="png">PNG</option>
                            <option value="jpg">JPG</option>
                            <option value="webp">WebP</option>
                            <option value="svg">SVG</option>
                        </select>
                    </div>
                </div>
            </div>
            
            <button class="generate-btn" onclick="generateQRCode()">üöÄ ÁîüÊàê‰∫åÁª¥Á†Å</button>
        </div>
        
        <div class="preview-area">
            <div class="preview-header">
                <h1>È¢ÑËßà‰∏é‰∏ãËΩΩ</h1>
                <button class="download-btn" onclick="downloadQRCode()" id="downloadBtn" style="display:none;">
                    <span>üíæ</span> ‰∏ãËΩΩ
                </button>
            </div>
            
            <div class="preview-content" id="previewContent">
                <div class="empty-state">
                    <div class="empty-icon">üì±</div>
                    <h3>ÂºÄÂßãÂàõÂª∫ÊÇ®ÁöÑ‰∫åÁª¥Á†Å</h3>
                    <p>ÈÖçÁΩÆ‰∏äÊñπÈÄâÈ°πÔºåÁÇπÂáªÁîüÊàêÊåâÈíÆÂç≥ÂèØÈ¢ÑËßà</p>
                </div>
            </div>
            
            <div class="qrcode-display" id="qrcodeDisplay" style="display:none;">
                <canvas id="qrcode"></canvas>
                <div id="bottomTextDisplay" class="bottom-text"></div>
            </div>
        </div>
        
        <div class="error-message" id="error"></div>
    </div>

    <script>
        // QR Code ÁºñÁ†ÅÂÆûÁé∞
        const QRCode = (function() {
            // Á∫†ÈîôÁ≠âÁ∫ß
            const ErrorCorrectLevel = {
                L: 1,
                M: 0,
                Q: 3,
                H: 2
            };
            
            // QR Code Ê®°Âºè
            const Mode = {
                MODE_NUMBER: 1 << 0,
                MODE_ALPHA_NUM: 1 << 1,
                MODE_8BIT_BYTE: 1 << 2,
                MODE_KANJI: 1 << 3
            };
            
            // Â§öÈ°πÂºè
            function QRPolynomial(num, shift) {
                if (num.length == undefined) {
                    throw new Error(num.length + "/" + shift);
                }
                
                let offset = 0;
                while (offset < num.length && num[offset] == 0) {
                    offset++;
                }
                
                this.num = new Array(num.length - offset + shift);
                for (let i = 0; i < num.length - offset; i++) {
                    this.num[i] = num[i + offset];
                }
            }
            
            QRPolynomial.prototype = {
                get: function(index) {
                    return this.num[index];
                },
                
                getLength: function() {
                    return this.num.length;
                },
                
                multiply: function(e) {
                    const num = new Array(this.getLength() + e.getLength() - 1);
                    
                    for (let i = 0; i < this.getLength(); i++) {
                        for (let j = 0; j < e.getLength(); j++) {
                            num[i + j] ^= QRMath.gexp(QRMath.glog(this.get(i)) + QRMath.glog(e.get(j)));
                        }
                    }
                    
                    return new QRPolynomial(num, 0);
                },
                
                mod: function(e) {
                    if (this.getLength() - e.getLength() < 0) {
                        return this;
                    }
                    
                    const ratio = QRMath.glog(this.get(0)) - QRMath.glog(e.get(0));
                    const num = new Array(this.getLength());
                    
                    for (let i = 0; i < this.getLength(); i++) {
                        num[i] = this.get(i);
                    }
                    
                    for (let i = 0; i < e.getLength(); i++) {
                        num[i] ^= QRMath.gexp(QRMath.glog(e.get(i)) + ratio);
                    }
                    
                    return new QRPolynomial(num, 0).mod(e);
                }
            };
            
            // Êï∞Â≠¶Â∑•ÂÖ∑
            const QRMath = {
                glog: function(n) {
                    if (n < 1) {
                        throw new Error("glog(" + n + ")");
                    }
                    return QRMath.LOG_TABLE[n];
                },
                
                gexp: function(n) {
                    while (n < 0) {
                        n += 255;
                    }
                    while (n >= 256) {
                        n -= 255;
                    }
                    return QRMath.EXP_TABLE[n];
                },
                
                EXP_TABLE: new Array(256),
                LOG_TABLE: new Array(256)
            };
            
            for (let i = 0; i < 8; i++) {
                QRMath.EXP_TABLE[i] = 1 << i;
            }
            for (let i = 8; i < 256; i++) {
                QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4] ^ QRMath.EXP_TABLE[i - 5] ^ QRMath.EXP_TABLE[i - 6] ^ QRMath.EXP_TABLE[i - 8];
            }
            for (let i = 0; i < 255; i++) {
                QRMath.LOG_TABLE[QRMath.EXP_TABLE[i]] = i;
            }
            
            // RS Block
            function QRRSBlock(totalCount, dataCount) {
                this.totalCount = totalCount;
                this.dataCount = dataCount;
            }
            
            QRRSBlock.RS_BLOCK_TABLE = [
                // Version 1: M, L, H, Q
                [1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9],
                // Version 2
                [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16],
                // Version 3
                [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13],
                // Version 4
                [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9],
                // Version 5
                [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12],
                // Version 6
                [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15],
                // Version 7
                [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14],
                // Version 8
                [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15],
                // Version 9
                [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13],
                // Version 10
                [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16],
                // Version 11
                [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13],
                // Version 12
                [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15],
                // Version 13
                [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12],
                // Version 14
                [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13],
                // Version 15
                [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13],
                // Version 16
                [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16],
                // Version 17
                [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15],
                // Version 18
                [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15],
                // Version 19
                [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14],
                // Version 20
                [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16],
                // Version 21
                [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17],
                // Version 22
                [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13],
                // Version 23
                [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16],
                // Version 24
                [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17],
                // Version 25
                [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16],
                // Version 26
                [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17],
                // Version 27
                [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16],
                // Version 28
                [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16],
                // Version 29
                [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16],
                // Version 30
                [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16],
                // Version 31
                [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16],
                // Version 32
                [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16],
                // Version 33
                [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16],
                // Version 34
                [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17],
                // Version 35
                [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16],
                // Version 36
                [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16],
                // Version 37
                [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16],
                // Version 38
                [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16],
                // Version 39
                [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16],
                // Version 40
                [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]
            ];
            
            QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
                const rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
                
                if (rsBlock == undefined) {
                    throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
                }
                
                const length = rsBlock.length / 3;
                const list = [];
                
                for (let i = 0; i < length; i++) {
                    const count = rsBlock[i * 3 + 0];
                    const totalCount = rsBlock[i * 3 + 1];
                    const dataCount = rsBlock[i * 3 + 2];
                    
                    for (let j = 0; j < count; j++) {
                        list.push(new QRRSBlock(totalCount, dataCount));
                    }
                }
                
                return list;
            };
            
            QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {
                switch(errorCorrectLevel) {
                    case ErrorCorrectLevel.L:
                        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
                    case ErrorCorrectLevel.M:
                        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
                    case ErrorCorrectLevel.Q:
                        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
                    case ErrorCorrectLevel.H:
                        return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
                    default:
                        return undefined;
                }
            };
            
            // Bit Buffer
            function QRBitBuffer() {
                this.buffer = [];
                this.length = 0;
            }
            
            QRBitBuffer.prototype = {
                get: function(index) {
                    const bufIndex = Math.floor(index / 8);
                    return ((this.buffer[bufIndex] >>> (7 - index % 8)) & 1) == 1;
                },
                
                put: function(num, length) {
                    for (let i = 0; i < length; i++) {
                        this.putBit(((num >>> (length - i - 1)) & 1) == 1);
                    }
                },
                
                getLengthInBits: function() {
                    return this.length;
                },
                
                putBit: function(bit) {
                    const bufIndex = Math.floor(this.length / 8);
                    if (this.buffer.length <= bufIndex) {
                        this.buffer.push(0);
                    }
                    
                    if (bit) {
                        this.buffer[bufIndex] |= (0x80 >>> (this.length % 8));
                    }
                    
                    this.length++;
                }
            };
            
            // 8bit Byte
            function QR8bitByte(data) {
                this.mode = Mode.MODE_8BIT_BYTE;
                this.data = data;
                this.parsedData = utf8Encode(data);
            }
            
            QR8bitByte.prototype = {
                getLength: function(buffer) {
                    return this.parsedData.length;
                },
                
                write: function(buffer) {
                    for (let i = 0; i < this.parsedData.length; i++) {
                        buffer.put(this.parsedData[i], 8);
                    }
                }
            };
            
            // UTF-8 ÁºñÁ†ÅÂáΩÊï∞
            function utf8Encode(str) {
                const utf8 = [];
                for (let i = 0; i < str.length; i++) {
                    let charcode = str.charCodeAt(i);
                    if (charcode < 0x80) {
                        utf8.push(charcode);
                    } else if (charcode < 0x800) {
                        utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));
                    } else if (charcode < 0xd800 || charcode >= 0xe000) {
                        utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
                    } else {
                        i++;
                        charcode = 0x10000 + (((charcode & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
                        utf8.push(0xf0 | (charcode >> 18), 0x80 | ((charcode >> 12) & 0x3f), 0x80 | ((charcode >> 6) & 0x3f), 0x80 | (charcode & 0x3f));
                    }
                }
                return utf8;
            }
            
            // QRCode ‰∏ªÁ±ª
            function QRCodeModel(typeNumber, errorCorrectLevel) {
                this.typeNumber = typeNumber;
                this.errorCorrectLevel = errorCorrectLevel;
                this.modules = null;
                this.moduleCount = 0;
                this.dataCache = null;
                this.dataList = [];
            }
            
            QRCodeModel.prototype = {
                addData: function(data) {
                    const newData = new QR8bitByte(data);
                    this.dataList.push(newData);
                    this.dataCache = null;
                },
                
                isDark: function(row, col) {
                    if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
                        throw new Error(row + "," + col);
                    }
                    return this.modules[row][col];
                },
                
                getModuleCount: function() {
                    return this.moduleCount;
                },
                
                make: function() {
                    this.makeImpl(false, this.getBestMaskPattern());
                },
                
                makeImpl: function(test, maskPattern) {
                    this.moduleCount = this.typeNumber * 4 + 17;
                    this.modules = new Array(this.moduleCount);
                    
                    for (let row = 0; row < this.moduleCount; row++) {
                        this.modules[row] = new Array(this.moduleCount);
                        
                        for (let col = 0; col < this.moduleCount; col++) {
                            this.modules[row][col] = null;
                        }
                    }
                    
                    this.setupPositionProbePattern(0, 0);
                    this.setupPositionProbePattern(this.moduleCount - 7, 0);
                    this.setupPositionProbePattern(0, this.moduleCount - 7);
                    this.setupPositionAdjustPattern();
                    this.setupTimingPattern();
                    this.setupTypeInfo(test, maskPattern);
                    
                    if (this.typeNumber >= 7) {
                        this.setupTypeNumber(test);
                    }
                    
                    if (this.dataCache == null) {
                        this.dataCache = QRCodeModel.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
                    }
                    
                    this.mapData(this.dataCache, maskPattern);
                },
                
                setupPositionProbePattern: function(row, col) {
                    for (let r = -1; r <= 7; r++) {
                        if (row + r <= -1 || this.moduleCount <= row + r) continue;
                        
                        for (let c = -1; c <= 7; c++) {
                            if (col + c <= -1 || this.moduleCount <= col + c) continue;
                            
                            if ((0 <= r && r <= 6 && (c == 0 || c == 6)) ||
                                (0 <= c && c <= 6 && (r == 0 || r == 6)) ||
                                (2 <= r && r <= 4 && 2 <= c && c <= 4)) {
                                this.modules[row + r][col + c] = true;
                            } else {
                                this.modules[row + r][col + c] = false;
                            }
                        }
                    }
                },
                
                getBestMaskPattern: function() {
                    let minLostPoint = 0;
                    let pattern = 0;
                    
                    for (let i = 0; i < 8; i++) {
                        this.makeImpl(true, i);
                        const lostPoint = QRUtil.getLostPoint(this);
                        
                        if (i == 0 || minLostPoint > lostPoint) {
                            minLostPoint = lostPoint;
                            pattern = i;
                        }
                    }
                    
                    return pattern;
                },
                
                setupTimingPattern: function() {
                    for (let r = 8; r < this.moduleCount - 8; r++) {
                        if (this.modules[r][6] != null) {
                            continue;
                        }
                        this.modules[r][6] = (r % 2 == 0);
                    }
                    
                    for (let c = 8; c < this.moduleCount - 8; c++) {
                        if (this.modules[6][c] != null) {
                            continue;
                        }
                        this.modules[6][c] = (c % 2 == 0);
                    }
                },
                
                setupPositionAdjustPattern: function() {
                    const pos = QRUtil.getPatternPosition(this.typeNumber);
                    
                    for (let i = 0; i < pos.length; i++) {
                        for (let j = 0; j < pos.length; j++) {
                            const row = pos[i];
                            const col = pos[j];
                            
                            if (this.modules[row][col] != null) {
                                continue;
                            }
                            
                            for (let r = -2; r <= 2; r++) {
                                for (let c = -2; c <= 2; c++) {
                                    if (r == -2 || r == 2 || c == -2 || c == 2 || (r == 0 && c == 0)) {
                                        this.modules[row + r][col + c] = true;
                                    } else {
                                        this.modules[row + r][col + c] = false;
                                    }
                                }
                            }
                        }
                    }
                },
                
                setupTypeNumber: function(test) {
                    const bits = QRUtil.getBCHTypeNumber(this.typeNumber);
                    
                    for (let i = 0; i < 18; i++) {
                        const mod = (!test && ((bits >> i) & 1) == 1);
                        this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
                    }
                    
                    for (let i = 0; i < 18; i++) {
                        const mod = (!test && ((bits >> i) & 1) == 1);
                        this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
                    }
                },
                
                setupTypeInfo: function(test, maskPattern) {
                    const data = (this.errorCorrectLevel << 3) | maskPattern;
                    const bits = QRUtil.getBCHTypeInfo(data);
                    
                    for (let i = 0; i < 15; i++) {
                        const mod = (!test && ((bits >> i) & 1) == 1);
                        
                        if (i < 6) {
                            this.modules[i][8] = mod;
                        } else if (i < 8) {
                            this.modules[i + 1][8] = mod;
                        } else {
                            this.modules[this.moduleCount - 15 + i][8] = mod;
                        }
                    }
                    
                    for (let i = 0; i < 15; i++) {
                        const mod = (!test && ((bits >> i) & 1) == 1);
                        
                        if (i < 8) {
                            this.modules[8][this.moduleCount - i - 1] = mod;
                        } else if (i < 9) {
                            this.modules[8][15 - i - 1 + 1] = mod;
                        } else {
                            this.modules[8][15 - i - 1] = mod;
                        }
                    }
                    
                    this.modules[this.moduleCount - 8][8] = (!test);
                },
                
                mapData: function(data, maskPattern) {
                    let inc = -1;
                    let row = this.moduleCount - 1;
                    let bitIndex = 7;
                    let byteIndex = 0;
                    
                    for (let col = this.moduleCount - 1; col > 0; col -= 2) {
                        if (col == 6) col--;
                        
                        while (true) {
                            for (let c = 0; c < 2; c++) {
                                if (this.modules[row][col - c] == null) {
                                    let dark = false;
                                    
                                    if (byteIndex < data.length) {
                                        dark = (((data[byteIndex] >>> bitIndex) & 1) == 1);
                                    }
                                    
                                    const mask = QRUtil.getMask(maskPattern, row, col - c);
                                    
                                    if (mask) {
                                        dark = !dark;
                                    }
                                    
                                    this.modules[row][col - c] = dark;
                                    bitIndex--;
                                    
                                    if (bitIndex == -1) {
                                        byteIndex++;
                                        bitIndex = 7;
                                    }
                                }
                            }
                            
                            row += inc;
                            
                            if (row < 0 || this.moduleCount <= row) {
                                row -= inc;
                                inc = -inc;
                                break;
                            }
                        }
                    }
                }
            };
            
            QRCodeModel.PAD0 = 0xEC;
            QRCodeModel.PAD1 = 0x11;
            
            QRCodeModel.createData = function(typeNumber, errorCorrectLevel, dataList) {
                const rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
                const buffer = new QRBitBuffer();
                
                for (let i = 0; i < dataList.length; i++) {
                    const data = dataList[i];
                    buffer.put(data.mode, 4);
                    buffer.put(data.getLength(), QRUtil.getLengthInBits(data.mode, typeNumber));
                    data.write(buffer);
                }
                
                let totalDataCount = 0;
                for (let i = 0; i < rsBlocks.length; i++) {
                    totalDataCount += rsBlocks[i].dataCount;
                }
                
                if (buffer.getLengthInBits() > totalDataCount * 8) {
                    throw new Error("code length overflow. (" + buffer.getLengthInBits() + ">" + totalDataCount * 8 + ")");
                }
                
                if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
                    buffer.put(0, 4);
                }
                
                while (buffer.getLengthInBits() % 8 != 0) {
                    buffer.putBit(false);
                }
                
                while (true) {
                    if (buffer.getLengthInBits() >= totalDataCount * 8) {
                        break;
                    }
                    buffer.put(QRCodeModel.PAD0, 8);
                    
                    if (buffer.getLengthInBits() >= totalDataCount * 8) {
                        break;
                    }
                    buffer.put(QRCodeModel.PAD1, 8);
                }
                
                return QRCodeModel.createBytes(buffer, rsBlocks);
            };
            
            QRCodeModel.createBytes = function(buffer, rsBlocks) {
                let offset = 0;
                let maxDcCount = 0;
                let maxEcCount = 0;
                
                const dcdata = new Array(rsBlocks.length);
                const ecdata = new Array(rsBlocks.length);
                
                for (let r = 0; r < rsBlocks.length; r++) {
                    const dcCount = rsBlocks[r].dataCount;
                    const ecCount = rsBlocks[r].totalCount - dcCount;
                    
                    maxDcCount = Math.max(maxDcCount, dcCount);
                    maxEcCount = Math.max(maxEcCount, ecCount);
                    
                    dcdata[r] = new Array(dcCount);
                    
                    for (let i = 0; i < dcdata[r].length; i++) {
                        dcdata[r][i] = 0xff & buffer.buffer[i + offset];
                    }
                    offset += dcCount;
                    
                    const rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
                    const rawPoly = new QRPolynomial(dcdata[r], rsPoly.getLength() - 1);
                    
                    const modPoly = rawPoly.mod(rsPoly);
                    ecdata[r] = new Array(rsPoly.getLength() - 1);
                    for (let i = 0; i < ecdata[r].length; i++) {
                        const modIndex = i + modPoly.getLength() - ecdata[r].length;
                        ecdata[r][i] = (modIndex >= 0) ? modPoly.get(modIndex) : 0;
                    }
                }
                
                let totalCodeCount = 0;
                for (let i = 0; i < rsBlocks.length; i++) {
                    totalCodeCount += rsBlocks[i].totalCount;
                }
                
                const data = new Array(totalCodeCount);
                let index = 0;
                
                for (let i = 0; i < maxDcCount; i++) {
                    for (let r = 0; r < rsBlocks.length; r++) {
                        if (i < dcdata[r].length) {
                            data[index++] = dcdata[r][i];
                        }
                    }
                }
                
                for (let i = 0; i < maxEcCount; i++) {
                    for (let r = 0; r < rsBlocks.length; r++) {
                        if (i < ecdata[r].length) {
                            data[index++] = ecdata[r][i];
                        }
                    }
                }
                
                return data;
            };
            
            // QR Util
            const QRUtil = {
                PATTERN_POSITION_TABLE: [
                    [],
                    [6, 18],
                    [6, 22],
                    [6, 26],
                    [6, 30],
                    [6, 34],
                    [6, 22, 38],
                    [6, 24, 42],
                    [6, 26, 46],
                    [6, 28, 50],
                    [6, 30, 54],
                    [6, 32, 58],
                    [6, 34, 62],
                    [6, 26, 46, 66],
                    [6, 26, 48, 70],
                    [6, 26, 50, 74],
                    [6, 30, 54, 78],
                    [6, 30, 56, 82],
                    [6, 30, 58, 86],
                    [6, 34, 62, 90],
                    [6, 28, 50, 72, 94],
                    [6, 26, 50, 74, 98],
                    [6, 30, 54, 78, 102],
                    [6, 28, 54, 80, 106],
                    [6, 32, 58, 84, 110],
                    [6, 30, 58, 86, 114],
                    [6, 34, 62, 90, 118],
                    [6, 26, 50, 74, 98, 122],
                    [6, 30, 54, 78, 102, 126],
                    [6, 26, 52, 78, 104, 130],
                    [6, 30, 56, 82, 108, 134],
                    [6, 34, 60, 86, 112, 138],
                    [6, 30, 58, 86, 114, 142],
                    [6, 34, 62, 90, 118, 146],
                    [6, 30, 54, 78, 102, 126, 150],
                    [6, 24, 50, 76, 102, 128, 154],
                    [6, 28, 54, 80, 106, 132, 158],
                    [6, 32, 58, 84, 110, 136, 162],
                    [6, 26, 54, 82, 110, 138, 166],
                    [6, 30, 58, 86, 114, 142, 170]
                ],
                
                G15: (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
                G18: (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
                G15_MASK: (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1),
                
                getBCHTypeInfo: function(data) {
                    let d = data << 10;
                    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
                        d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15)));
                    }
                    return ((data << 10) | d) ^ QRUtil.G15_MASK;
                },
                
                getBCHTypeNumber: function(data) {
                    let d = data << 12;
                    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
                        d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18)));
                    }
                    return (data << 12) | d;
                },
                
                getBCHDigit: function(data) {
                    let digit = 0;
                    while (data != 0) {
                        digit++;
                        data >>>= 1;
                    }
                    return digit;
                },
                
                getPatternPosition: function(typeNumber) {
                    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
                },
                
                getMask: function(maskPattern, i, j) {
                    switch (maskPattern) {
                        case 0: return (i + j) % 2 == 0;
                        case 1: return i % 2 == 0;
                        case 2: return j % 3 == 0;
                        case 3: return (i + j) % 3 == 0;
                        case 4: return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 == 0;
                        case 5: return (i * j) % 2 + (i * j) % 3 == 0;
                        case 6: return ((i * j) % 2 + (i * j) % 3) % 2 == 0;
                        case 7: return ((i * j) % 3 + (i + j) % 2) % 2 == 0;
                        default: throw new Error("bad maskPattern:" + maskPattern);
                    }
                },
                
                getErrorCorrectPolynomial: function(errorCorrectLength) {
                    let a = new QRPolynomial([1], 0);
                    
                    for (let i = 0; i < errorCorrectLength; i++) {
                        a = a.multiply(new QRPolynomial([1, QRMath.gexp(i)], 0));
                    }
                    
                    return a;
                },
                
                getLengthInBits: function(mode, type) {
                    if (1 <= type && type < 10) {
                        switch(mode) {
                            case Mode.MODE_NUMBER: return 10;
                            case Mode.MODE_ALPHA_NUM: return 9;
                            case Mode.MODE_8BIT_BYTE: return 8;
                            case Mode.MODE_KANJI: return 8;
                            default: throw new Error("mode:" + mode);
                        }
                    } else if (type < 27) {
                        switch(mode) {
                            case Mode.MODE_NUMBER: return 12;
                            case Mode.MODE_ALPHA_NUM: return 11;
                            case Mode.MODE_8BIT_BYTE: return 16;
                            case Mode.MODE_KANJI: return 10;
                            default: throw new Error("mode:" + mode);
                        }
                    } else if (type < 41) {
                        switch(mode) {
                            case Mode.MODE_NUMBER: return 14;
                            case Mode.MODE_ALPHA_NUM: return 13;
                            case Mode.MODE_8BIT_BYTE: return 16;
                            case Mode.MODE_KANJI: return 12;
                            default: throw new Error("mode:" + mode);
                        }
                    } else {
                        throw new Error("type:" + type);
                    }
                },
                
                getLostPoint: function(qrCode) {
                    const moduleCount = qrCode.getModuleCount();
                    let lostPoint = 0;
                    
                    for (let row = 0; row < moduleCount; row++) {
                        for (let col = 0; col < moduleCount; col++) {
                            let sameCount = 0;
                            const dark = qrCode.isDark(row, col);
                            
                            for (let r = -1; r <= 1; r++) {
                                if (row + r < 0 || moduleCount <= row + r) {
                                    continue;
                                }
                                
                                for (let c = -1; c <= 1; c++) {
                                    if (col + c < 0 || moduleCount <= col + c) {
                                        continue;
                                    }
                                    
                                    if (r == 0 && c == 0) {
                                        continue;
                                    }
                                    
                                    if (dark == qrCode.isDark(row + r, col + c)) {
                                        sameCount++;
                                    }
                                }
                            }
                            
                            if (sameCount > 5) {
                                lostPoint += (3 + sameCount - 5);
                            }
                        }
                    }
                    
                    for (let row = 0; row < moduleCount - 1; row++) {
                        for (let col = 0; col < moduleCount - 1; col++) {
                            let count = 0;
                            if (qrCode.isDark(row, col)) count++;
                            if (qrCode.isDark(row + 1, col)) count++;
                            if (qrCode.isDark(row, col + 1)) count++;
                            if (qrCode.isDark(row + 1, col + 1)) count++;
                            if (count == 0 || count == 4) {
                                lostPoint += 3;
                            }
                        }
                    }
                    
                    for (let row = 0; row < moduleCount; row++) {
                        for (let col = 0; col < moduleCount - 6; col++) {
                            if (qrCode.isDark(row, col) &&
                                !qrCode.isDark(row, col + 1) &&
                                qrCode.isDark(row, col + 2) &&
                                qrCode.isDark(row, col + 3) &&
                                qrCode.isDark(row, col + 4) &&
                                !qrCode.isDark(row, col + 5) &&
                                qrCode.isDark(row, col + 6)) {
                                lostPoint += 40;
                            }
                        }
                    }
                    
                    for (let col = 0; col < moduleCount; col++) {
                        for (let row = 0; row < moduleCount - 6; row++) {
                            if (qrCode.isDark(row, col) &&
                                !qrCode.isDark(row + 1, col) &&
                                qrCode.isDark(row + 2, col) &&
                                qrCode.isDark(row + 3, col) &&
                                qrCode.isDark(row + 4, col) &&
                                !qrCode.isDark(row + 5, col) &&
                                qrCode.isDark(row + 6, col)) {
                                lostPoint += 40;
                            }
                        }
                    }
                    
                    let darkCount = 0;
                    
                    for (let col = 0; col < moduleCount; col++) {
                        for (let row = 0; row < moduleCount; row++) {
                            if (qrCode.isDark(row, col)) {
                                darkCount++;
                            }
                        }
                    }
                    
                    const ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
                    lostPoint += ratio * 10;
                    
                    return lostPoint;
                }
            };
            
            return {
                ErrorCorrectLevel: ErrorCorrectLevel,
                QRCodeModel: QRCodeModel
            };
        })();
        
        let logoImage = null;
        let bgImage = null;
        
        // Â∞∫ÂØ∏ÊªëÂùóÂíåËæìÂÖ•Ê°ÜÂèåÂêëÂêåÊ≠•
        document.getElementById('size').addEventListener('input', function(e) {
            const value = e.target.value;
            document.getElementById('sizeValue').textContent = value;
            document.getElementById('sizeInput').value = value;
        });
        
        document.getElementById('sizeInput').addEventListener('input', function(e) {
            const value = Math.max(0, parseInt(e.target.value) || 1);
            document.getElementById('sizeValue').textContent = value;
            document.getElementById('size').value = Math.min(value, 10000);
        });
        
        // ËæπË∑ùÊªëÂùóÂíåËæìÂÖ•Ê°ÜÂèåÂêëÂêåÊ≠•
        document.getElementById('margin').addEventListener('input', function(e) {
            const value = e.target.value;
            document.getElementById('marginValue').textContent = value;
            document.getElementById('marginInput').value = value;
        });
        
        document.getElementById('marginInput').addEventListener('input', function(e) {
            const value = Math.max(0, parseInt(e.target.value) || 0);
            document.getElementById('marginValue').textContent = value;
            document.getElementById('margin').value = Math.min(value, 1000);
        });
        
        // Logo‰∏ä‰º†
        document.getElementById('logoFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        logoImage = img;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        // ËÉåÊôØÂõæÁâá‰∏ä‰º†
        document.getElementById('bgImageFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    const img = new Image();
                    img.onload = function() {
                        bgImage = img;
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Version 40 ÂêÑÂÆπÈîôÁ∫ßÂà´ÁöÑÊúÄÂ§ßÂÆπÈáè(Â≠óËäÇ)
        const maxCapacity = {
            L: 2953,
            M: 2331,
            Q: 1663,
            H: 1273
        };
        
        // Êõ¥Êñ∞ÊñáÊú¨ÁªüËÆ°‰ø°ÊÅØ
        function updateTextStats() {
            const text = document.getElementById('text').value;
            const errorLevel = document.getElementById('errorLevel').value;
            const charCount = text.length;
            const byteCount = new Blob([text]).size;
            const maxBytes = maxCapacity[errorLevel];
            
            document.getElementById('charCount').textContent = charCount;
            document.getElementById('byteCount').textContent = byteCount;
            document.getElementById('maxBytes').textContent = maxBytes;
            
            // Â¶ÇÊûúË∂ÖÂá∫ÂÆπÈáè,Ê†áÁ∫¢
            const byteCountEl = document.getElementById('byteCount');
            if (byteCount > maxBytes) {
                byteCountEl.classList.add('warning');
            } else {
                byteCountEl.classList.remove('warning');
            }
        }
        
        // ÊñáÊú¨ËæìÂÖ•Ê°ÜÁõëÂê¨
        document.getElementById('text').addEventListener('input', updateTextStats);
        
        // ÂÆπÈîôÁ∫ßÂà´ÊîπÂèòÊó∂Êõ¥Êñ∞ÁªüËÆ°
        document.getElementById('errorLevel').addEventListener('change', updateTextStats);
        
        // È°µÈù¢Âä†ËΩΩÊó∂ÂàùÂßãÂåñÁªüËÆ°
        updateTextStats();
        
        // ÁîüÊàê‰∫åÁª¥Á†Å
        function generateQRCode() {
            const text = document.getElementById('text').value.trim();
            const sizeInput = parseInt(document.getElementById('sizeInput').value);
            const marginInput = parseInt(document.getElementById('marginInput').value);
            const size = sizeInput || parseInt(document.getElementById('size').value);
            const margin = marginInput || parseInt(document.getElementById('margin').value);
            const fgColor = document.getElementById('fgColor').value;
            const bgColor = document.getElementById('bgColor').value;
            const bottomText = document.getElementById('bottomText').value.trim();
            const errorLevelStr = document.getElementById('errorLevel').value;
            const errorElement = document.getElementById('error');
            const previewContent = document.getElementById('previewContent');
            const qrcodeDisplay = document.getElementById('qrcodeDisplay');
            const downloadBtn = document.getElementById('downloadBtn');
            
            errorElement.style.display = 'none';
            
            if (!text) {
                errorElement.textContent = '‚ö†Ô∏è ËØ∑ËæìÂÖ•Ë¶ÅÁîüÊàê‰∫åÁª¥Á†ÅÁöÑÂÜÖÂÆπÔºÅ';
                errorElement.style.display = 'block';
                setTimeout(() => errorElement.style.display = 'none', 3000);
                return;
            }
            
            try {
                const errorLevel = QRCode.ErrorCorrectLevel[errorLevelStr];
                
                // Êô∫ËÉΩÈÄâÊã©ÁâàÊú¨Âè∑1-40,‰∏çÂ¢ûÂä†È¢ùÂ§ñ‰ΩôÈáè
                let typeNumber = 40;
                for (let i = 1; i <= 40; i++) {
                    try {
                        const testQr = new QRCode.QRCodeModel(i, errorLevel);
                        testQr.addData(text);
                        testQr.make();
                        typeNumber = i;
                        break;
                    } catch (e) {
                        if (i === 40) {
                            throw new Error('ÊñáÊú¨ÂÜÖÂÆπËøáÈïø,Ë∂ÖÂá∫‰∫åÁª¥Á†ÅÊúÄÂ§ßÂÆπÈáè');
                        }
                        continue;
                    }
                }
                
                console.log('ÂÆπÈîôÁ∫ßÂà´: ' + errorLevelStr + '\nÈÄâÊã©ÁâàÊú¨: ' + typeNumber + '\nÊñáÊú¨ÈïøÂ∫¶: ' + text.length + '\nÂ≠óËäÇÊï∞: ' + new Blob([text]).size);
                
                console.log('‰ΩøÁî®ÁâàÊú¨:', typeNumber, 'ÊñáÊú¨ÈïøÂ∫¶:', text.length, 'Â≠óËäÇÊï∞:', new Blob([text]).size);
                
                const qr = new QRCode.QRCodeModel(typeNumber, errorLevel);
                qr.addData(text);
                qr.make();
                
                const canvas = document.getElementById('qrcode');
                const ctx = canvas.getContext('2d');
                const moduleCount = qr.getModuleCount();
                const qrSize = size - margin * 2;
                const cellSize = qrSize / moduleCount;
                canvas.width = size;
                canvas.height = size;

                // ËÉåÊôØÂõæÁâáÊàñÁ∫ØËâ≤ËÉåÊôØ
                if (bgImage) {
                    // ËÆ°ÁÆóËÉåÊôØÂõæÁâáÁöÑÁªòÂà∂Â∞∫ÂØ∏,‰øùÊåÅÂéüÂßãÊØî‰æã‰∏çÂèòÂΩ¢
                    const imgAspect = bgImage.width / bgImage.height;
                    const canvasAspect = canvas.width / canvas.height;
                    
                    let drawWidth, drawHeight, drawX, drawY;
                    
                    if (imgAspect > canvasAspect) {
                        // ÂõæÁâáÊõ¥ÂÆΩ,‰ª•È´òÂ∫¶‰∏∫ÂáÜ
                        drawHeight = canvas.height;
                        drawWidth = drawHeight * imgAspect;
                        drawX = (canvas.width - drawWidth) / 2;
                        drawY = 0;
                    } else {
                        // ÂõæÁâáÊõ¥È´ò,‰ª•ÂÆΩÂ∫¶‰∏∫ÂáÜ
                        drawWidth = canvas.width;
                        drawHeight = drawWidth / imgAspect;
                        drawX = 0;
                        drawY = (canvas.height - drawHeight) / 2;
                    }
                    
                    ctx.drawImage(bgImage, drawX, drawY, drawWidth, drawHeight);
                    
                    // Ê∑ªÂä†30%ÁôΩËâ≤ÂçäÈÄèÊòéÈÅÆÁΩ©,Á°Æ‰øù‰∫åÁª¥Á†ÅÊ∏ÖÊô∞ÂèØÊâ´
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    // Á∫ØËâ≤ËÉåÊôØ
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
                
                // ‰∫åÁª¥Á†Å
                ctx.fillStyle = fgColor;
                for (let row = 0; row < moduleCount; row++) {
                    for (let col = 0; col < moduleCount; col++) {
                        if (qr.isDark(row, col)) {
                            ctx.fillRect(
                                col * cellSize + margin,
                                row * cellSize + margin,
                                cellSize,
                                cellSize
                            );
                        }
                    }
                }
                
                // Logo
                if (logoImage) {
                    const logoSize = qrSize * 0.2;
                    const logoX = (canvas.width - logoSize) / 2;
                    const logoY = (canvas.height - logoSize) / 2;
                    
                    // LogoËÉåÊôØ
                    ctx.fillStyle = bgColor;
                    ctx.fillRect(logoX - 5, logoY - 5, logoSize + 10, logoSize + 10);
                    
                    // ÁªòÂà∂Logo,‰øùÊåÅÂéüÂßãÊ∏ÖÊô∞Â∫¶
                    ctx.drawImage(logoImage, logoX, logoY, logoSize, logoSize);
                }
                
                // Â∫ïÈÉ®ÊñáÂ≠ó
                const bottomTextDisplay = document.getElementById('bottomTextDisplay');
                if (bottomText) {
                    bottomTextDisplay.textContent = bottomText;
                    bottomTextDisplay.style.display = 'block';
                } else {
                    bottomTextDisplay.style.display = 'none';
                }
                
                previewContent.style.display = 'none';
                qrcodeDisplay.style.display = 'block';
                downloadBtn.style.display = 'flex';
            } catch (e) {
                errorElement.textContent = '‚ùå ÁîüÊàêÂ§±Ë¥•Ôºö' + e.message;
                errorElement.style.display = 'block';
                setTimeout(() => errorElement.style.display = 'none', 3000);
            }
        }
        
        // ‰∏ãËΩΩ‰∫åÁª¥Á†Å
        function downloadQRCode() {
            const canvas = document.getElementById('qrcode');
            const format = document.getElementById('exportFormat').value;
            const link = document.createElement('a');
            
            let mimeType = 'image/png';
            let extension = 'png';
            
            if (format === 'jpg') {
                mimeType = 'image/jpeg';
                extension = 'jpg';
            } else if (format === 'webp') {
                mimeType = 'image/webp';
                extension = 'webp';
            } else if (format === 'svg') {
                // SVGÂØºÂá∫
                const svgData = canvasToSVG(canvas);
                const blob = new Blob([svgData], {type: 'image/svg+xml'});
                link.href = URL.createObjectURL(blob);
                link.download = 'qrcode.svg';
                link.click();
                return;
            }
            
            link.download = 'qrcode.' + extension;
            link.href = canvas.toDataURL(mimeType, 0.95);
            link.click();
        }
        
        // CanvasËΩ¨SVG
        function canvasToSVG(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${canvas.width}" height="${canvas.height}">`;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const idx = (y * canvas.width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3] / 255;
                    
                    if (a > 0) {
                        const color = `rgb(${r},${g},${b})`;
                        svg += `<rect x="${x}" y="${y}" width="1" height="1" fill="${color}" opacity="${a}"/>`;
                    }
                }
            }
            
            svg += '</svg>';
            return svg;
        }
    </script>
</body>
</html>

